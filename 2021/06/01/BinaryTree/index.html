<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <title>二叉树 | blog of Jungle</title>
  <meta name="keywords" content=" 二叉树 ">
  <meta name="description" content="二叉树 | blog of Jungle">
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
<meta name="description" content="个人介绍Jungle  毕业于CUIT, 目前在sz工作. 喜欢学习新技术 成为一个合格的程序员, 一定要学好三样东西: 数学 编程 算法 情商 财商     最近什么的干活 面经 + 算法题hot100  提升自我  基础：  集合、反射 JVM linux命令及脚本编程 mysql 、redis、mq 基础知识点及原理   进阶：  多线程高并发【并发编程的艺术】 SSM ：Spring cl">
<meta property="og:type" content="website">
<meta property="og:title" content="个人简介">
<meta property="og:url" content="http://example.com/about/index.html">
<meta property="og:site_name" content="blog of Jungle">
<meta property="og:description" content="个人介绍Jungle  毕业于CUIT, 目前在sz工作. 喜欢学习新技术 成为一个合格的程序员, 一定要学好三样东西: 数学 编程 算法 情商 财商     最近什么的干活 面经 + 算法题hot100  提升自我  基础：  集合、反射 JVM linux命令及脚本编程 mysql 、redis、mq 基础知识点及原理   进阶：  多线程高并发【并发编程的艺术】 SSM ：Spring cl">
<meta property="og:locale" content="zh_CN">
<meta property="article:published_time" content="2020-11-13T11:42:01.000Z">
<meta property="article:modified_time" content="2023-09-14T17:15:02.611Z">
<meta property="article:author" content="Jungle">
<meta name="twitter:card" content="summary">


<link rel="icon" href="/img/avatar.jpg">

<link href="/css/style.css?v=1.1.0" rel="stylesheet">

<link href="/css/hl_theme/atom-light.css?v=1.1.0" rel="stylesheet">

<link href="//cdn.jsdelivr.net/npm/animate.css@4.1.0/animate.min.css" rel="stylesheet">

<script src="//cdn.jsdelivr.net/npm/jquery@3.5.1/dist/jquery.min.js"></script>
<script src="/js/titleTip.js?v=1.1.0" ></script>

<script src="//cdn.jsdelivr.net/npm/highlightjs@9.16.2/highlight.pack.min.js"></script>
<script>
    hljs.initHighlightingOnLoad();
</script>

<script src="//cdn.jsdelivr.net/npm/nprogress@0.2.0/nprogress.min.js"></script>



<script src="//cdn.jsdelivr.net/npm/jquery.cookie@1.4.1/jquery.cookie.min.js" ></script>

<script src="/js/iconfont.js?v=1.1.0" ></script>

<meta name="generator" content="Hexo 5.2.0"></head>
<div style="display: none">
  <input class="theme_disqus_on" value="false">
  <input class="theme_preload_comment" value="">
  <input class="theme_blog_path" value="">
  <input id="theme_shortcut" value="true" />
  <input id="theme_highlight_on" value="true" />
  <input id="theme_code_copy" value="true" />
</div>



<body>
<aside class="nav">
    <div class="nav-left">
        <a href="/" class="avatar_target">
    <img class="avatar" src="/img/avatar.jpg" />
</a>
<div class="author">
    <span>Jungle</span>
</div>

<div class="icon">
    
        
        <a title="rss" href="/atom.xml" target="_blank">
            
                <svg class="iconfont-svg" aria-hidden="true">
                    <use xlink:href="#icon-rss"></use>
                </svg>
            
        </a>
        
    
        
        <a title="github" href="https://github.com/jungle8884" target="_blank">
            
                <svg class="iconfont-svg" aria-hidden="true">
                    <use xlink:href="#icon-github"></use>
                </svg>
            
        </a>
        
    
        
        <a title="csdn" href="https://blog.csdn.net/jungle8884" target="_blank">
            
                <svg class="iconfont-svg" aria-hidden="true">
                    <use xlink:href="#icon-csdn"></use>
                </svg>
            
        </a>
        
    
        
    
        
        <a title="email" href="mailto:jungle8884@163.com" target="_blank">
            
                <svg class="iconfont-svg" aria-hidden="true">
                    <use xlink:href="#icon-email"></use>
                </svg>
            
        </a>
        
    
        
        <a title="qq" href="http://wpa.qq.com/msgrd?v=3&uin=983123369&site=qq&menu=yes" target="_blank">
            
                <svg class="iconfont-svg" aria-hidden="true">
                    <use xlink:href="#icon-qq"></use>
                </svg>
            
        </a>
        
    
        
        <a title="neteasemusic" href="https://music.163.com/#/user/home?id=88786971" target="_blank">
            
                <svg class="iconfont-svg" aria-hidden="true">
                    <use xlink:href="#icon-neteasemusic"></use>
                </svg>
            
        </a>
        
    
</div>




<ul>
    <li><div class="all active" data-rel="全部文章">全部文章<small>(74)</small></div></li>
    
        
            
            <li><div data-rel="读书"><i class="fold iconfont icon-right"></i>读书<small>(4)</small></div>
                
                    <ul class="sub hide">
                        
                        <li><div data-rel="读书<--->单词">单词<small>(1)</small></div>
                            
                        </li>
                            
                        <li><div data-rel="读书<--->软件设计师">软件设计师<small>(1)</small></div>
                            
                        </li>
                            
                        <li><div data-rel="读书<--->英语">英语<small>(1)</small></div>
                            
                        </li>
                            
                    </ul>
                
            </li>
            
        
    
        
            
            <li><div data-rel="工具"><i class="fold iconfont icon-right"></i>工具<small>(11)</small></div>
                
                    <ul class="sub hide">
                        
                        <li><div data-rel="工具<--->插件">插件<small>(2)</small></div>
                            
                        </li>
                            
                        <li><div data-rel="工具<--->audio">audio<small>(1)</small></div>
                            
                        </li>
                            
                        <li><div data-rel="工具<--->ChatGPT">ChatGPT<small>(1)</small></div>
                            
                        </li>
                            
                        <li><div data-rel="工具<--->git">git<small>(3)</small></div>
                            
                        </li>
                            
                        <li><div data-rel="工具<--->github">github<small>(1)</small></div>
                            
                        </li>
                            
                    </ul>
                
            </li>
            
        
    
        
            
            <li><div data-rel="后端"><i class="fold iconfont icon-right"></i>后端<small>(21)</small></div>
                
                    <ul class="sub hide">
                        
                        <li><div data-rel="后端<--->设计模式">设计模式<small>(8)</small></div>
                            
                        </li>
                            
                        <li><div data-rel="后端<--->C#">C#<small>(2)</small></div>
                            
                        </li>
                            
                        <li><div data-rel="后端<--->Java">Java<small>(11)</small></div>
                            
                        </li>
                            
                    </ul>
                
            </li>
            
        
    
        
            
            <li><div data-rel="数据库"><i class="fold iconfont icon-right"></i>数据库<small>(2)</small></div>
                
                    <ul class="sub hide">
                        
                        <li><div data-rel="数据库<--->MySQL">MySQL<small>(1)</small></div>
                            
                        </li>
                            
                        <li><div data-rel="数据库<--->Redis">Redis<small>(1)</small></div>
                            
                        </li>
                            
                    </ul>
                
            </li>
            
        
    
        
            
            <li><div data-rel="运维"><i class="fold iconfont icon-right"></i>运维<small>(2)</small></div>
                
                    <ul class="sub hide">
                        
                        <li><div data-rel="运维<--->Docker">Docker<small>(1)</small></div>
                            
                        </li>
                            
                    </ul>
                
            </li>
            
        
    
        
            
        
    
        
            
        
    
        
            
        
    
        
            
        
    
        
            
        
    
        
            
        
    
        
            
            <li><div data-rel="前端">前端<small>(1)</small></div>
                
            </li>
            
        
    
        
            
        
    
        
            
        
    
        
            
        
    
        
            
        
    
        
            
        
    
        
            
        
    
        
            
        
    
        
            
            <li><div data-rel="算法"><i class="fold iconfont icon-right"></i>算法<small>(17)</small></div>
                
                    <ul class="sub hide">
                        
                        <li><div data-rel="算法<--->滑动窗口">滑动窗口<small>(1)</small></div>
                            
                        </li>
                            
                        <li><div data-rel="算法<--->基础">基础<small>(1)</small></div>
                            
                        </li>
                            
                        <li><div data-rel="算法<--->面试题">面试题<small>(1)</small></div>
                            
                        </li>
                            
                        <li><div data-rel="算法<--->日期">日期<small>(2)</small></div>
                            
                        </li>
                            
                        <li><div data-rel="算法<--->树">树<small>(4)</small></div>
                            
                        </li>
                            
                        <li><div data-rel="算法<--->数学">数学<small>(1)</small></div>
                            
                        </li>
                            
                        <li><div data-rel="算法<--->数组">数组<small>(1)</small></div>
                            
                        </li>
                            
                        <li><div data-rel="算法<--->双指针">双指针<small>(1)</small></div>
                            
                        </li>
                            
                        <li><div data-rel="算法<--->图">图<small>(2)</small></div>
                            
                        </li>
                            
                        <li><div data-rel="算法<--->LeetCode">LeetCode<small>(1)</small></div>
                            
                        </li>
                            
                    </ul>
                
            </li>
            
        
    
        
            
        
    
        
            
            <li><div data-rel="项目"><i class="fold iconfont icon-right"></i>项目<small>(3)</small></div>
                
                    <ul class="sub hide">
                        
                        <li><div data-rel="项目<--->ruoyi">ruoyi<small>(2)</small></div>
                            
                        </li>
                            
                        <li><div data-rel="项目<--->SpringBoot">SpringBoot<small>(1)</small></div>
                            
                        </li>
                            
                    </ul>
                
            </li>
            
        
    
        
            
        
    
        
            
        
    
        
            
        
    
        
            
        
    
        
            
        
    
        
            
            <li><div data-rel="DL"><i class="fold iconfont icon-right"></i>DL<small>(3)</small></div>
                
                    <ul class="sub hide">
                        
                        <li><div data-rel="DL<--->Docker">Docker<small>(1)</small></div>
                            
                        </li>
                            
                        <li><div data-rel="DL<--->Python">Python<small>(1)</small></div>
                            
                        </li>
                            
                    </ul>
                
            </li>
            
        
    
        
            
        
    
        
            
        
    
        
            
        
    
        
            
        
    
        
            
        
    
        
            
        
    
        
            
        
    
        
            
            <li><div data-rel="IOT"><i class="fold iconfont icon-right"></i>IOT<small>(10)</small></div>
                
                    <ul class="sub hide">
                        
                        <li><div data-rel="IOT<--->51C">51C<small>(1)</small></div>
                            
                        </li>
                            
                        <li><div data-rel="IOT<--->codeblitz">codeblitz<small>(1)</small></div>
                            
                        </li>
                            
                        <li><div data-rel="IOT<--->ESP32">ESP32<small>(2)</small></div>
                            
                        </li>
                            
                        <li><div data-rel="IOT<--->ESP32C3">ESP32C3<small>(1)</small></div>
                            
                        </li>
                            
                        <li><div data-rel="IOT<--->FleetBee">FleetBee<small>(1)</small></div>
                            
                        </li>
                            
                        <li><div data-rel="IOT<--->STM32">STM32<small>(1)</small></div>
                            
                        </li>
                            
                        <li><div data-rel="IOT<--->wumei">wumei<small>(3)</small></div>
                            
                        </li>
                            
                    </ul>
                
            </li>
            
        
    
        
            
        
    
        
            
        
    
        
            
        
    
        
            
        
    
        
            
        
    
        
            
        
    
        
            
        
    
        
            
        
    
        
            
        
    
</ul>
<div class="left-bottom">
    <div class="menus">
    
    
    
    
    </div>
    <div><a class="about  hasFriend  site_url"  href="/about">关于</a><a style="width: 50%"  class="friends">友链</a></div>
</div>
<input type="hidden" id="yelog_site_posts_number" value="74">
<input type="hidden" id="yelog_site_word_count" value="219.5k">
<div style="display: none">
    <span id="busuanzi_value_site_uv"></span>
    <span id="busuanzi_value_site_pv"></span>
</div>

    </div>
    <div class="nav-right">
        <div class="friends-area">
    <div class="friends-title">
        友情链接
        <i class="iconfont icon-left"></i>
    </div>
    <div class="friends-content">
        <ul>
            
            <li><a target="_blank" href="http://yelog.org/">叶落阁</a></li>
            
        </ul>
    </div>
</div>
        <div class="title-list">
    <div class="right-top">
        <div id="default-panel">
            <i class="iconfont icon-search" data-title="搜索 快捷键 i"></i>
            <div class="right-title">全部文章</div>
            <i class="iconfont icon-file-tree" data-title="切换到大纲视图 快捷键 w"></i>
        </div>
        <div id="search-panel">
            <i class="iconfont icon-left" data-title="返回"></i>
            <input id="local-search-input" />
            <label class="border-line" for="input"></label>
            <i class="iconfont icon-case-sensitive" data-title="大小写敏感"></i>
            <i class="iconfont icon-tag" data-title="标签"></i>
        </div>
        <div id="outline-panel" style="display: none">
            <div class="right-title">大纲</div>
            <i class="iconfont icon-list" data-title="切换到文章列表"></i>
        </div>
    </div>

    <div class="tags-list">
    <input id="tag-search" />
    <div class="tag-wrapper">
        
            <li class="article-tag-list-item">
                <i class="iconfont icon-tag"></i><a>51C</a>
            </li>
        
            <li class="article-tag-list-item">
                <i class="iconfont icon-tag"></i><a>博客搭建</a>
            </li>
        
            <li class="article-tag-list-item">
                <i class="iconfont icon-tag"></i><a>蔡勒公式</a>
            </li>
        
            <li class="article-tag-list-item">
                <i class="iconfont icon-tag"></i><a>策略模式</a>
            </li>
        
            <li class="article-tag-list-item">
                <i class="iconfont icon-tag"></i><a>查找</a>
            </li>
        
            <li class="article-tag-list-item">
                <i class="iconfont icon-tag"></i><a>抽象工厂模式</a>
            </li>
        
            <li class="article-tag-list-item">
                <i class="iconfont icon-tag"></i><a>创建型模式</a>
            </li>
        
            <li class="article-tag-list-item">
                <i class="iconfont icon-tag"></i><a>代理模式</a>
            </li>
        
            <li class="article-tag-list-item">
                <i class="iconfont icon-tag"></i><a>单例模式</a>
            </li>
        
            <li class="article-tag-list-item">
                <i class="iconfont icon-tag"></i><a>迭代器</a>
            </li>
        
            <li class="article-tag-list-item">
                <i class="iconfont icon-tag"></i><a>多表查询</a>
            </li>
        
            <li class="article-tag-list-item">
                <i class="iconfont icon-tag"></i><a>多态</a>
            </li>
        
            <li class="article-tag-list-item">
                <i class="iconfont icon-tag"></i><a>多线程</a>
            </li>
        
            <li class="article-tag-list-item">
                <i class="iconfont icon-tag"></i><a>二叉树</a>
            </li>
        
            <li class="article-tag-list-item">
                <i class="iconfont icon-tag"></i><a>分布式数据库系统及原理</a>
            </li>
        
            <li class="article-tag-list-item">
                <i class="iconfont icon-tag"></i><a>工厂方法模式</a>
            </li>
        
            <li class="article-tag-list-item">
                <i class="iconfont icon-tag"></i><a>构建型模式</a>
            </li>
        
            <li class="article-tag-list-item">
                <i class="iconfont icon-tag"></i><a>观察者模式</a>
            </li>
        
            <li class="article-tag-list-item">
                <i class="iconfont icon-tag"></i><a>滑动窗口</a>
            </li>
        
            <li class="article-tag-list-item">
                <i class="iconfont icon-tag"></i><a>机器学习</a>
            </li>
        
            <li class="article-tag-list-item">
                <i class="iconfont icon-tag"></i><a>集合</a>
            </li>
        
            <li class="article-tag-list-item">
                <i class="iconfont icon-tag"></i><a>计算机专业英语</a>
            </li>
        
            <li class="article-tag-list-item">
                <i class="iconfont icon-tag"></i><a>简单工厂模式</a>
            </li>
        
            <li class="article-tag-list-item">
                <i class="iconfont icon-tag"></i><a>建造者模式</a>
            </li>
        
            <li class="article-tag-list-item">
                <i class="iconfont icon-tag"></i><a>结构型模式</a>
            </li>
        
            <li class="article-tag-list-item">
                <i class="iconfont icon-tag"></i><a>进制转换</a>
            </li>
        
            <li class="article-tag-list-item">
                <i class="iconfont icon-tag"></i><a>镜像</a>
            </li>
        
            <li class="article-tag-list-item">
                <i class="iconfont icon-tag"></i><a>开发</a>
            </li>
        
            <li class="article-tag-list-item">
                <i class="iconfont icon-tag"></i><a>开发框架</a>
            </li>
        
            <li class="article-tag-list-item">
                <i class="iconfont icon-tag"></i><a>快速平方根</a>
            </li>
        
            <li class="article-tag-list-item">
                <i class="iconfont icon-tag"></i><a>六大原则</a>
            </li>
        
            <li class="article-tag-list-item">
                <i class="iconfont icon-tag"></i><a>六级</a>
            </li>
        
            <li class="article-tag-list-item">
                <i class="iconfont icon-tag"></i><a>爬虫</a>
            </li>
        
            <li class="article-tag-list-item">
                <i class="iconfont icon-tag"></i><a>排序</a>
            </li>
        
            <li class="article-tag-list-item">
                <i class="iconfont icon-tag"></i><a>前端</a>
            </li>
        
            <li class="article-tag-list-item">
                <i class="iconfont icon-tag"></i><a>前缀树</a>
            </li>
        
            <li class="article-tag-list-item">
                <i class="iconfont icon-tag"></i><a>容器</a>
            </li>
        
            <li class="article-tag-list-item">
                <i class="iconfont icon-tag"></i><a>闰年</a>
            </li>
        
            <li class="article-tag-list-item">
                <i class="iconfont icon-tag"></i><a>社会的本质</a>
            </li>
        
            <li class="article-tag-list-item">
                <i class="iconfont icon-tag"></i><a>深度学习</a>
            </li>
        
            <li class="article-tag-list-item">
                <i class="iconfont icon-tag"></i><a>事务</a>
            </li>
        
            <li class="article-tag-list-item">
                <i class="iconfont icon-tag"></i><a>数据库的备份和还原</a>
            </li>
        
            <li class="article-tag-list-item">
                <i class="iconfont icon-tag"></i><a>数据库的设计</a>
            </li>
        
            <li class="article-tag-list-item">
                <i class="iconfont icon-tag"></i><a>数组</a>
            </li>
        
            <li class="article-tag-list-item">
                <i class="iconfont icon-tag"></i><a>双指针</a>
            </li>
        
            <li class="article-tag-list-item">
                <i class="iconfont icon-tag"></i><a>贪心</a>
            </li>
        
            <li class="article-tag-list-item">
                <i class="iconfont icon-tag"></i><a>图</a>
            </li>
        
            <li class="article-tag-list-item">
                <i class="iconfont icon-tag"></i><a>委托与事件</a>
            </li>
        
            <li class="article-tag-list-item">
                <i class="iconfont icon-tag"></i><a>写作</a>
            </li>
        
            <li class="article-tag-list-item">
                <i class="iconfont icon-tag"></i><a>行为型模式</a>
            </li>
        
            <li class="article-tag-list-item">
                <i class="iconfont icon-tag"></i><a>优先队列</a>
            </li>
        
            <li class="article-tag-list-item">
                <i class="iconfont icon-tag"></i><a>油猴</a>
            </li>
        
            <li class="article-tag-list-item">
                <i class="iconfont icon-tag"></i><a>原码, 反码, 补码, 移码</a>
            </li>
        
            <li class="article-tag-list-item">
                <i class="iconfont icon-tag"></i><a>原型模式</a>
            </li>
        
            <li class="article-tag-list-item">
                <i class="iconfont icon-tag"></i><a>约束</a>
            </li>
        
            <li class="article-tag-list-item">
                <i class="iconfont icon-tag"></i><a>Ado.net</a>
            </li>
        
            <li class="article-tag-list-item">
                <i class="iconfont icon-tag"></i><a>ArrayList</a>
            </li>
        
            <li class="article-tag-list-item">
                <i class="iconfont icon-tag"></i><a>AT</a>
            </li>
        
            <li class="article-tag-list-item">
                <i class="iconfont icon-tag"></i><a>audio</a>
            </li>
        
            <li class="article-tag-list-item">
                <i class="iconfont icon-tag"></i><a>C#</a>
            </li>
        
            <li class="article-tag-list-item">
                <i class="iconfont icon-tag"></i><a>ChatGPT</a>
            </li>
        
            <li class="article-tag-list-item">
                <i class="iconfont icon-tag"></i><a>codeblitz</a>
            </li>
        
            <li class="article-tag-list-item">
                <i class="iconfont icon-tag"></i><a>device</a>
            </li>
        
            <li class="article-tag-list-item">
                <i class="iconfont icon-tag"></i><a>DL</a>
            </li>
        
            <li class="article-tag-list-item">
                <i class="iconfont icon-tag"></i><a>docker</a>
            </li>
        
            <li class="article-tag-list-item">
                <i class="iconfont icon-tag"></i><a>Docker</a>
            </li>
        
            <li class="article-tag-list-item">
                <i class="iconfont icon-tag"></i><a>ESP32</a>
            </li>
        
            <li class="article-tag-list-item">
                <i class="iconfont icon-tag"></i><a>ESP32C3</a>
            </li>
        
            <li class="article-tag-list-item">
                <i class="iconfont icon-tag"></i><a>FleetBee</a>
            </li>
        
            <li class="article-tag-list-item">
                <i class="iconfont icon-tag"></i><a>git</a>
            </li>
        
            <li class="article-tag-list-item">
                <i class="iconfont icon-tag"></i><a>github</a>
            </li>
        
            <li class="article-tag-list-item">
                <i class="iconfont icon-tag"></i><a>http</a>
            </li>
        
            <li class="article-tag-list-item">
                <i class="iconfont icon-tag"></i><a>IO</a>
            </li>
        
            <li class="article-tag-list-item">
                <i class="iconfont icon-tag"></i><a>JavaScript</a>
            </li>
        
            <li class="article-tag-list-item">
                <i class="iconfont icon-tag"></i><a>Job</a>
            </li>
        
            <li class="article-tag-list-item">
                <i class="iconfont icon-tag"></i><a>LeetCode</a>
            </li>
        
            <li class="article-tag-list-item">
                <i class="iconfont icon-tag"></i><a>LinkedList</a>
            </li>
        
            <li class="article-tag-list-item">
                <i class="iconfont icon-tag"></i><a>Linux</a>
            </li>
        
            <li class="article-tag-list-item">
                <i class="iconfont icon-tag"></i><a>List</a>
            </li>
        
            <li class="article-tag-list-item">
                <i class="iconfont icon-tag"></i><a>Map</a>
            </li>
        
            <li class="article-tag-list-item">
                <i class="iconfont icon-tag"></i><a>N叉树</a>
            </li>
        
            <li class="article-tag-list-item">
                <i class="iconfont icon-tag"></i><a>N的阶乘</a>
            </li>
        
            <li class="article-tag-list-item">
                <i class="iconfont icon-tag"></i><a>NoSQL</a>
            </li>
        
            <li class="article-tag-list-item">
                <i class="iconfont icon-tag"></i><a>OJ</a>
            </li>
        
            <li class="article-tag-list-item">
                <i class="iconfont icon-tag"></i><a>python</a>
            </li>
        
            <li class="article-tag-list-item">
                <i class="iconfont icon-tag"></i><a>Python</a>
            </li>
        
            <li class="article-tag-list-item">
                <i class="iconfont icon-tag"></i><a>Resnet</a>
            </li>
        
            <li class="article-tag-list-item">
                <i class="iconfont icon-tag"></i><a>Set</a>
            </li>
        
            <li class="article-tag-list-item">
                <i class="iconfont icon-tag"></i><a>shadowsocks</a>
            </li>
        
            <li class="article-tag-list-item">
                <i class="iconfont icon-tag"></i><a>Shell</a>
            </li>
        
            <li class="article-tag-list-item">
                <i class="iconfont icon-tag"></i><a>SpringBoot</a>
            </li>
        
            <li class="article-tag-list-item">
                <i class="iconfont icon-tag"></i><a>SQL</a>
            </li>
        
            <li class="article-tag-list-item">
                <i class="iconfont icon-tag"></i><a>STM32</a>
            </li>
        
            <li class="article-tag-list-item">
                <i class="iconfont icon-tag"></i><a>Stream</a>
            </li>
        
            <li class="article-tag-list-item">
                <i class="iconfont icon-tag"></i><a>Utils</a>
            </li>
        
            <li class="article-tag-list-item">
                <i class="iconfont icon-tag"></i><a>Vector</a>
            </li>
        
            <li class="article-tag-list-item">
                <i class="iconfont icon-tag"></i><a>video</a>
            </li>
        
            <li class="article-tag-list-item">
                <i class="iconfont icon-tag"></i><a>Vue</a>
            </li>
        
            <li class="article-tag-list-item">
                <i class="iconfont icon-tag"></i><a>WebGIS</a>
            </li>
        
            <li class="article-tag-list-item">
                <i class="iconfont icon-tag"></i><a>wumei</a>
            </li>
        
    </div>

</div>

    
    <nav id="title-list-nav">
        
        <a id="top" class="全部文章 读书 单词 "
           href="/2020/11/24/WordofCS/"
           data-tag="机器学习,深度学习,计算机专业英语,分布式数据库系统及原理"
           data-author="" >
            <span class="post-title" title="WordofCS">WordofCS</span>
            <span class="post-date" title="2020-11-24 17:21:02">2020/11/24</span>
        </a>
        
        <a id="top" class="全部文章 读书 英语 "
           href="/2020/09/18/CET-6-Writing/"
           data-tag="六级,写作"
           data-author="" >
            <span class="post-title" title="六级写作">六级写作</span>
            <span class="post-date" title="2020-09-18 10:21:32">2020/09/18</span>
        </a>
        
        <a  class="全部文章 IOT FleetBee "
           href="/2024/04/12/CameraAccess/"
           data-tag="FleetBee"
           data-author="" >
            <span class="post-title" title="CameraAccess">CameraAccess</span>
            <span class="post-date" title="2024-04-12 16:48:52">2024/04/12</span>
        </a>
        
        <a  class="全部文章 项目 ruoyi "
           href="/2024/01/09/ruoyi_2Dev/"
           data-tag="开发框架"
           data-author="" >
            <span class="post-title" title="ruoyi-二次开发">ruoyi-二次开发</span>
            <span class="post-date" title="2024-01-09 11:20:00">2024/01/09</span>
        </a>
        
        <a  class="全部文章 项目 ruoyi "
           href="/2024/01/06/ruoyi/"
           data-tag="开发框架"
           data-author="" >
            <span class="post-title" title="ruoyi">ruoyi</span>
            <span class="post-date" title="2024-01-06 15:20:00">2024/01/06</span>
        </a>
        
        <a  class="全部文章 项目 SpringBoot "
           href="/2024/01/05/SpringBoor_Vue/"
           data-tag="SpringBoot,Vue"
           data-author="" >
            <span class="post-title" title="SpringBoot_Vue">SpringBoot_Vue</span>
            <span class="post-date" title="2024-01-05 11:20:01">2024/01/05</span>
        </a>
        
        <a  class="全部文章 IOT wumei "
           href="/2023/12/27/wumei_DeepIn/"
           data-tag="device"
           data-author="" >
            <span class="post-title" title="wumei-deviceDeepIn">wumei-deviceDeepIn</span>
            <span class="post-date" title="2023-12-27 10:23:00">2023/12/27</span>
        </a>
        
        <a  class="全部文章 IOT wumei "
           href="/2023/12/26/wumei_deviceInto/"
           data-tag="device"
           data-author="" >
            <span class="post-title" title="wumei-deviceInto">wumei-deviceInto</span>
            <span class="post-date" title="2023-12-26 11:20:00">2023/12/26</span>
        </a>
        
        <a  class="全部文章 IOT ESP32C3 "
           href="/2023/12/12/ESP32-C3/"
           data-tag="ESP32C3"
           data-author="" >
            <span class="post-title" title="ESP32C3">ESP32C3</span>
            <span class="post-date" title="2023-12-12 15:43:52">2023/12/12</span>
        </a>
        
        <a  class="全部文章 IOT wumei "
           href="/2023/12/11/wumei/"
           data-tag="wumei"
           data-author="" >
            <span class="post-title" title="wumei">wumei</span>
            <span class="post-date" title="2023-12-11 09:48:52">2023/12/11</span>
        </a>
        
        <a  class="全部文章 IOT ESP32 "
           href="/2023/11/08/ESP32/"
           data-tag="ESP32"
           data-author="" >
            <span class="post-title" title="ESP32">ESP32</span>
            <span class="post-date" title="2023-11-08 18:02:31">2023/11/08</span>
        </a>
        
        <a  class="全部文章 算法 数学 "
           href="/2023/11/01/Q-rsqrt/"
           data-tag="快速平方根"
           data-author="" >
            <span class="post-title" title="Q_rsqrt">Q_rsqrt</span>
            <span class="post-date" title="2023-11-01 08:52:08">2023/11/01</span>
        </a>
        
        <a  class="全部文章 工具 audio "
           href="/2023/10/16/audioConvert/"
           data-tag="python,audio"
           data-author="" >
            <span class="post-title" title="audioConvert">audioConvert</span>
            <span class="post-date" title="2023-10-16 19:34:43">2023/10/16</span>
        </a>
        
        <a  class="全部文章 IOT STM32 "
           href="/2023/10/14/STM32/"
           data-tag="STM32"
           data-author="" >
            <span class="post-title" title="STM32">STM32</span>
            <span class="post-date" title="2023-10-14 08:59:19">2023/10/14</span>
        </a>
        
        <a  class="全部文章 IOT 51C "
           href="/2023/10/08/51C/"
           data-tag="51C"
           data-author="" >
            <span class="post-title" title="51C">51C</span>
            <span class="post-date" title="2023-10-08 17:20:10">2023/10/08</span>
        </a>
        
        <a  class="全部文章 IOT codeblitz "
           href="/2023/09/28/IOT/"
           data-tag="codeblitz"
           data-author="" >
            <span class="post-title" title="codeblitz">codeblitz</span>
            <span class="post-date" title="2023-09-28 08:48:52">2023/09/28</span>
        </a>
        
        <a  class="全部文章 算法 面试题 "
           href="/2023/09/18/JobInterview/"
           data-tag="N的阶乘"
           data-author="" >
            <span class="post-title" title="JobInterview">JobInterview</span>
            <span class="post-date" title="2023-09-18 21:55:19">2023/09/18</span>
        </a>
        
        <a  class="全部文章 算法 LeetCode "
           href="/2023/09/13/hot100/"
           data-tag="LeetCode"
           data-author="" >
            <span class="post-title" title="hot100">hot100</span>
            <span class="post-date" title="2023-09-13 10:17:00">2023/09/13</span>
        </a>
        
        <a  class="全部文章 后端 Java "
           href="/2023/09/05/4Job/"
           data-tag="Job,WebGIS,Shell"
           data-author="" >
            <span class="post-title" title="Javaer&#39;s development">Javaer&#39;s development</span>
            <span class="post-date" title="2023-09-05 00:00:00">2023/09/05</span>
        </a>
        
        <a  class="全部文章 后端 Java "
           href="/2023/03/24/Stream/"
           data-tag="Stream"
           data-author="" >
            <span class="post-title" title="Stream">Stream</span>
            <span class="post-date" title="2023-03-24 09:42:49">2023/03/24</span>
        </a>
        
        <a  class="全部文章 IOT ESP32 "
           href="/2023/03/08/ESP32ATLog/"
           data-tag="ESP32,AT"
           data-author="" >
            <span class="post-title" title="ESP32AT指令集探索">ESP32AT指令集探索</span>
            <span class="post-date" title="2023-03-08 14:52:56">2023/03/08</span>
        </a>
        
        <a  class="全部文章 工具 插件 "
           href="/2023/02/09/AddOn4SpeedPlay/"
           data-tag="video"
           data-author="" >
            <span class="post-title" title="AddOn4SpeedPlay">AddOn4SpeedPlay</span>
            <span class="post-date" title="2023-02-09 13:05:26">2023/02/09</span>
        </a>
        
        <a  class="全部文章 工具 ChatGPT "
           href="/2023/02/09/ChatGPT/"
           data-tag="ChatGPT"
           data-author="" >
            <span class="post-title" title="Usage of ChatGPT">Usage of ChatGPT</span>
            <span class="post-date" title="2023-02-09 12:34:54">2023/02/09</span>
        </a>
        
        <a  class="全部文章 后端 Java "
           href="/2023/02/09/Java-io/"
           data-tag="IO"
           data-author="" >
            <span class="post-title" title="Java-io">Java-io</span>
            <span class="post-date" title="2023-02-09 12:27:55">2023/02/09</span>
        </a>
        
        <a  class="全部文章 工具 插件 "
           href="/2023/01/17/Freedom/"
           data-tag="油猴"
           data-author="" >
            <span class="post-title" title="Videos">Videos</span>
            <span class="post-date" title="2023-01-17 21:43:30">2023/01/17</span>
        </a>
        
        <a  class="全部文章 后端 Java "
           href="/2022/12/04/DevConcludes/"
           data-tag="开发"
           data-author="" >
            <span class="post-title" title="DevConcludes">DevConcludes</span>
            <span class="post-date" title="2022-12-04 22:16:46">2022/12/04</span>
        </a>
        
        <a  class="全部文章 后端 Java "
           href="/2022/10/16/Java-Utils/"
           data-tag="Utils"
           data-author="" >
            <span class="post-title" title="Java-Utils">Java-Utils</span>
            <span class="post-date" title="2022-10-16 16:15:29">2022/10/16</span>
        </a>
        
        <a  class="全部文章 算法 数组 "
           href="/2022/05/02/Array/"
           data-tag="数组"
           data-author="" >
            <span class="post-title" title="数组">数组</span>
            <span class="post-date" title="2022-05-02 00:00:00">2022/05/02</span>
        </a>
        
        <a  class="全部文章 读书 "
           href="/2022/03/12/natureOfSociety/"
           data-tag="社会的本质"
           data-author="" >
            <span class="post-title" title="natureOfSociety">natureOfSociety</span>
            <span class="post-date" title="2022-03-12 18:39:19">2022/03/12</span>
        </a>
        
        <a  class="全部文章 算法 图 "
           href="/2022/01/23/TopologicalSorting/"
           data-tag="图"
           data-author="" >
            <span class="post-title" title="拓扑排序">拓扑排序</span>
            <span class="post-date" title="2022-01-23 00:00:00">2022/01/23</span>
        </a>
        
        <a  class="全部文章 算法 图 "
           href="/2021/12/31/Graph-DataStructure/"
           data-tag="图"
           data-author="" >
            <span class="post-title" title="图的数据结构">图的数据结构</span>
            <span class="post-date" title="2021-12-31 10:41:29">2021/12/31</span>
        </a>
        
        <a  class="全部文章 后端 设计模式 "
           href="/2021/12/30/DesignPatternofSixPrinciples/"
           data-tag="六大原则"
           data-author="" >
            <span class="post-title" title="六大设计原则">六大设计原则</span>
            <span class="post-date" title="2021-12-30 15:11:05">2021/12/30</span>
        </a>
        
        <a  class="全部文章 算法 树 "
           href="/2021/12/13/BinaryTree-traverse/"
           data-tag="二叉树"
           data-author="" >
            <span class="post-title" title="二叉树的遍历框架">二叉树的遍历框架</span>
            <span class="post-date" title="2021-12-13 10:50:34">2021/12/13</span>
        </a>
        
        <a  class="全部文章 算法 "
           href="/2021/12/08/Trie-341-NestedIterator/"
           data-tag="前缀树,N叉树,迭代器"
           data-author="" >
            <span class="post-title" title="扁平化嵌套列表迭代器">扁平化嵌套列表迭代器</span>
            <span class="post-date" title="2021-12-08 16:38:11">2021/12/08</span>
        </a>
        
        <a  class="全部文章 算法 树 "
           href="/2021/11/26/BinaryTree-297-SerializeAndDeserialize/"
           data-tag="二叉树"
           data-author="" >
            <span class="post-title" title="二叉树的序列化和反序列化">二叉树的序列化和反序列化</span>
            <span class="post-date" title="2021-11-26 17:32:54">2021/11/26</span>
        </a>
        
        <a  class="全部文章 算法 日期 "
           href="/2021/09/16/Calculate-date/"
           data-tag="闰年"
           data-author="" >
            <span class="post-title" title="Calculate_date">Calculate_date</span>
            <span class="post-date" title="2021-09-16 21:05:01">2021/09/16</span>
        </a>
        
        <a  class="全部文章 后端 设计模式 "
           href="/2021/09/15/DesignPatterofStrategy/"
           data-tag="行为型模式,策略模式"
           data-author="" >
            <span class="post-title" title="策略模式">策略模式</span>
            <span class="post-date" title="2021-09-15 20:58:14">2021/09/15</span>
        </a>
        
        <a  class="全部文章 后端 设计模式 "
           href="/2021/09/15/DesignPatternofObserver/"
           data-tag="观察者模式,行为型模式"
           data-author="" >
            <span class="post-title" title="观察者模式">观察者模式</span>
            <span class="post-date" title="2021-09-15 20:41:49">2021/09/15</span>
        </a>
        
        <a  class="全部文章 后端 设计模式 "
           href="/2021/09/15/DesignPatternofProxy/"
           data-tag="代理模式,结构型模式"
           data-author="" >
            <span class="post-title" title="代理模式">代理模式</span>
            <span class="post-date" title="2021-09-15 20:30:32">2021/09/15</span>
        </a>
        
        <a  class="全部文章 算法 "
           href="/2021/09/07/PriorityQueue/"
           data-tag="优先队列,贪心"
           data-author="" >
            <span class="post-title" title="PriorityQueue">PriorityQueue</span>
            <span class="post-date" title="2021-09-07 00:00:00">2021/09/07</span>
        </a>
        
        <a  class="全部文章 算法 基础 "
           href="/2021/08/31/SearchAndSort/"
           data-tag="排序,查找"
           data-author="" >
            <span class="post-title" title="SearchAndSort">SearchAndSort</span>
            <span class="post-date" title="2021-08-31 14:27:08">2021/08/31</span>
        </a>
        
        <a  class="全部文章 后端 Java "
           href="/2021/08/13/HashSet-HashMap-analyse/"
           data-tag="集合,Set,Map"
           data-author="" >
            <span class="post-title" title="HashMap">HashMap</span>
            <span class="post-date" title="2021-08-13 14:59:19">2021/08/13</span>
        </a>
        
        <a  class="全部文章 后端 Java "
           href="/2021/08/13/LinkedList-analyse/"
           data-tag="集合,LinkedList"
           data-author="" >
            <span class="post-title" title="LinkedList-analyse">LinkedList-analyse</span>
            <span class="post-date" title="2021-08-13 13:19:52">2021/08/13</span>
        </a>
        
        <a  class="全部文章 后端 Java "
           href="/2021/08/13/Vector-analyse/"
           data-tag="集合,List,Vector"
           data-author="" >
            <span class="post-title" title="Vector-analyse">Vector-analyse</span>
            <span class="post-date" title="2021-08-13 11:42:21">2021/08/13</span>
        </a>
        
        <a  class="全部文章 后端 Java "
           href="/2021/08/13/Arraylist-analyse/"
           data-tag="集合,List,ArrayList"
           data-author="" >
            <span class="post-title" title="Arraylist_analyse">Arraylist_analyse</span>
            <span class="post-date" title="2021-08-13 08:59:00">2021/08/13</span>
        </a>
        
        <a  class="全部文章 后端 Java "
           href="/2021/08/10/Java-JUC/"
           data-tag="多线程"
           data-author="" >
            <span class="post-title" title="Java_JUC">Java_JUC</span>
            <span class="post-date" title="2021-08-10 20:42:30">2021/08/10</span>
        </a>
        
        <a  class="全部文章 算法 树 "
           href="/2021/07/09/Trie/"
           data-tag="前缀树,N叉树"
           data-author="" >
            <span class="post-title" title="过滤敏感词">过滤敏感词</span>
            <span class="post-date" title="2021-07-09 00:00:00">2021/07/09</span>
        </a>
        
        <a  class="全部文章 算法 滑动窗口 "
           href="/2021/07/02/slidingwindow/"
           data-tag="滑动窗口"
           data-author="" >
            <span class="post-title" title="滑动窗口">滑动窗口</span>
            <span class="post-date" title="2021-07-02 00:00:00">2021/07/02</span>
        </a>
        
        <a  class="全部文章 算法 双指针 "
           href="/2021/07/01/doublepointers/"
           data-tag="双指针"
           data-author="" >
            <span class="post-title" title="双指针">双指针</span>
            <span class="post-date" title="2021-07-01 00:00:00">2021/07/01</span>
        </a>
        
        <a  class="全部文章 数据库 Redis "
           href="/2021/06/29/redis-LearningNote/"
           data-tag="NoSQL"
           data-author="" >
            <span class="post-title" title="redis学习笔记">redis学习笔记</span>
            <span class="post-date" title="2021-06-29 00:00:00">2021/06/29</span>
        </a>
        
        <a  class="全部文章 算法 日期 "
           href="/2021/06/27/Zeller/"
           data-tag="蔡勒公式,OJ"
           data-author="" >
            <span class="post-title" title="Week = (Day + 2*Month + 3*(Month+1)/5 + Year + Year/4 - Year/100 + Year/400) % 7">Week = (Day + 2*Month + 3*(Month+1)/5 + Year + Year/4 - Year/100 + Year/400) % 7</span>
            <span class="post-date" title="2021-06-27 00:00:00">2021/06/27</span>
        </a>
        
        <a  class="全部文章 算法 树 "
           href="/2021/06/01/BinaryTree/"
           data-tag="二叉树"
           data-author="" >
            <span class="post-title" title="二叉树">二叉树</span>
            <span class="post-date" title="2021-06-01 00:00:00">2021/06/01</span>
        </a>
        
        <a  class="全部文章 运维 "
           href="/2021/05/27/linuxLearningNote/"
           data-tag="Shell,Linux"
           data-author="" >
            <span class="post-title" title="Linux 与 Shell">Linux 与 Shell</span>
            <span class="post-date" title="2021-05-27 00:00:00">2021/05/27</span>
        </a>
        
        <a  class="全部文章 DL "
           href="/2021/05/05/Resnet/"
           data-tag="DL,Resnet"
           data-author="" >
            <span class="post-title" title="Resnet">Resnet</span>
            <span class="post-date" title="2021-05-05 00:00:00">2021/05/05</span>
        </a>
        
        <a  class="全部文章 后端 Java "
           href="/2021/04/29/Java-polymorphism/"
           data-tag="多态"
           data-author="" >
            <span class="post-title" title="Java-polymorphism">Java-polymorphism</span>
            <span class="post-date" title="2021-04-29 00:00:00">2021/04/29</span>
        </a>
        
        <a  class="全部文章 后端 设计模式 "
           href="/2021/04/14/DesignPatternofBuilder/"
           data-tag="构建型模式,建造者模式"
           data-author="" >
            <span class="post-title" title="建造者模式">建造者模式</span>
            <span class="post-date" title="2021-04-14 00:00:00">2021/04/14</span>
        </a>
        
        <a  class="全部文章 后端 设计模式 "
           href="/2021/04/10/DesignPatternofSingleton/"
           data-tag="构建型模式,单例模式"
           data-author="" >
            <span class="post-title" title="单例模式">单例模式</span>
            <span class="post-date" title="2021-04-10 00:00:00">2021/04/10</span>
        </a>
        
        <a  class="全部文章 前端 "
           href="/2021/04/09/JavaScript-Note/"
           data-tag="前端,JavaScript"
           data-author="" >
            <span class="post-title" title="JavaScript">JavaScript</span>
            <span class="post-date" title="2021-04-09 14:27:00">2021/04/09</span>
        </a>
        
        <a  class="全部文章 DL Docker "
           href="/2021/04/09/DockerPractice/"
           data-tag="Docker,DL"
           data-author="" >
            <span class="post-title" title="DockerPractice">DockerPractice</span>
            <span class="post-date" title="2021-04-09 00:00:00">2021/04/09</span>
        </a>
        
        <a  class="全部文章 工具 git "
           href="/2021/04/06/GitLearningNote-2/"
           data-tag="git"
           data-author="" >
            <span class="post-title" title="git学习笔记">git学习笔记</span>
            <span class="post-date" title="2021-04-06 00:00:00">2021/04/06</span>
        </a>
        
        <a  class="全部文章 后端 设计模式 "
           href="/2021/04/02/DesignPatternofPrototype/"
           data-tag="原型模式,构建型模式"
           data-author="" >
            <span class="post-title" title="原型模式">原型模式</span>
            <span class="post-date" title="2021-04-02 00:00:00">2021/04/02</span>
        </a>
        
        <a  class="全部文章 后端 设计模式 "
           href="/2021/03/30/DesignPatternofFactory/"
           data-tag="创建型模式,简单工厂模式,工厂方法模式,抽象工厂模式"
           data-author="" >
            <span class="post-title" title="工厂模式">工厂模式</span>
            <span class="post-date" title="2021-03-30 00:00:00">2021/03/30</span>
        </a>
        
        <a  class="全部文章 数据库 MySQL "
           href="/2021/03/23/MySQLearningNote/"
           data-tag="SQL,约束,数据库的设计,数据库的备份和还原,多表查询,事务"
           data-author="" >
            <span class="post-title" title="MySQL学习笔记">MySQL学习笔记</span>
            <span class="post-date" title="2021-03-23 00:00:00">2021/03/23</span>
        </a>
        
        <a  class="全部文章 运维 Docker "
           href="/2021/03/19/DockerLearningNoteBase/"
           data-tag="docker,镜像,容器"
           data-author="" >
            <span class="post-title" title="Docker学习笔记">Docker学习笔记</span>
            <span class="post-date" title="2021-03-19 00:00:00">2021/03/19</span>
        </a>
        
        <a  class="全部文章 后端 C# "
           href="/2020/10/16/Ado-.net/"
           data-tag="C#,Ado.net"
           data-author="" >
            <span class="post-title" title="Ado.net">Ado.net</span>
            <span class="post-date" title="2020-10-16 00:00:00">2020/10/16</span>
        </a>
        
        <a  class="全部文章 工具 github "
           href="/2020/10/12/GitHubSearch/"
           data-tag="github"
           data-author="" >
            <span class="post-title" title="学会在github上搜索项目">学会在github上搜索项目</span>
            <span class="post-date" title="2020-10-12 13:55:57">2020/10/12</span>
        </a>
        
        <a  class="全部文章 后端 C# "
           href="/2020/09/21/Event-publisher-subscriber/"
           data-tag="C#,委托与事件"
           data-author="" >
            <span class="post-title" title="Event_publisher_subscriber">Event_publisher_subscriber</span>
            <span class="post-date" title="2020-09-21 15:17:32">2020/09/21</span>
        </a>
        
        <a  class="全部文章 读书 软件设计师 "
           href="/2019/12/16/SoftwareDesignTest/"
           data-tag="原码, 反码, 补码, 移码,进制转换"
           data-author="" >
            <span class="post-title" title="软件设计师">软件设计师</span>
            <span class="post-date" title="2019-12-16 10:46:08">2019/12/16</span>
        </a>
        
        <a  class="全部文章 工具 "
           href="/2019/12/03/douban-spider/"
           data-tag="爬虫,Python"
           data-author="" >
            <span class="post-title" title="豆瓣排行榜小爬虫">豆瓣排行榜小爬虫</span>
            <span class="post-date" title="2019-12-03 00:00:00">2019/12/03</span>
        </a>
        
        <a  class="全部文章 工具 "
           href="/2019/09/30/Crawler/"
           data-tag="爬虫,http"
           data-author="" >
            <span class="post-title" title="什么是网络爬虫">什么是网络爬虫</span>
            <span class="post-date" title="2019-09-30 14:35:05">2019/09/30</span>
        </a>
        
        <a  class="全部文章 DL Python "
           href="/2019/08/31/PythonNote/"
           data-tag="Python"
           data-author="" >
            <span class="post-title" title="Python学习笔记">Python学习笔记</span>
            <span class="post-date" title="2019-08-31 14:28:16">2019/08/31</span>
        </a>
        
        <a  class="全部文章 工具 git "
           href="/2019/08/10/HowToMakeBlog/"
           data-tag="博客搭建"
           data-author="" >
            <span class="post-title" title="搭建hexo博客">搭建hexo博客</span>
            <span class="post-date" title="2019-08-10 00:00:00">2019/08/10</span>
        </a>
        
        <a  class="全部文章 工具 git "
           href="/2019/06/13/GitLearningNote-1/"
           data-tag="git"
           data-author="" >
            <span class="post-title" title="git 初试">git 初试</span>
            <span class="post-date" title="2019-06-13 00:00:00">2019/06/13</span>
        </a>
        
        <a  class="全部文章 工具 "
           href="/2019/06/13/On-the-Internet-Scientifically/"
           data-tag="shadowsocks"
           data-author="" >
            <span class="post-title" title="科学上网">科学上网</span>
            <span class="post-date" title="2019-06-13 00:00:00">2019/06/13</span>
        </a>
        
        <div id="no-item-tips">

        </div>
    </nav>
    <div id="outline-list">
    </div>
</div>
    </div>
    <div class="hide-list">
        <div class="semicircle" data-title="切换全屏 快捷键 s">
            <div class="brackets first"><</div>
            <div class="brackets">&gt;</div>
        </div>
    </div>
</aside>
<div id="post">
    <div class="pjax">
        <article id="post-BinaryTree" class="article article-type-post" itemscope itemprop="blogPost">
    
        <h1 class="article-title">二叉树</h1>
    
    <div class="article-meta">
        
        
        
        <span class="book">
            <i class="iconfont icon-category"></i>
            
            
            <a  data-rel="算法">算法</a> > 
            
            <a  data-rel="算法&lt;---&gt;树">树</a>
            
        </span>
        
        
        <span class="tag">
            <i class="iconfont icon-tag"></i>
            
            <a class="color4">二叉树</a>
            
        </span>
        
    </div>
    <div class="article-meta">
        
            发布时间 : <time class="date" title='最后更新: 2022-04-29 15:00:55'>2021-06-01 00:00</time>
        
    </div>
    <div class="article-meta">
        
        <span>字数:8.2k</span>
        
        
        <span id="busuanzi_container_page_pv">
            阅读 :<span id="busuanzi_value_page_pv">
                <span class="count-comment">
                    <span class="spinner">
                      <div class="cube1"></div>
                      <div class="cube2"></div>
                    </span>
                </span>
            </span>
        </span>
        
        
        <span class="top-comment" title="跳转至评论区">
            <a href="#comments">
                评论:<span class="count-comment">
                    <span class="spinner">
                      <div class="cube1"></div>
                      <div class="cube2"></div>
                    </span>
                </span>
            </a>
        </span>
        
    </div>
    
    <div class="toc-ref">
    
        <ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%BA%8C%E5%8F%89%E6%A0%91"><span class="toc-text">二叉树</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#226-%E7%BF%BB%E8%BD%AC%E4%BA%8C%E5%8F%89%E6%A0%91"><span class="toc-text">226-翻转二叉树</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#116-%E5%A1%AB%E5%85%85%E6%AF%8F%E4%B8%AA%E8%8A%82%E7%82%B9%E7%9A%84%E4%B8%8B%E4%B8%80%E4%B8%AA%E5%8F%B3%E4%BE%A7%E8%8A%82%E7%82%B9%E6%8C%87%E9%92%88"><span class="toc-text">116-填充每个节点的下一个右侧节点指针</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#114-%E4%BA%8C%E5%8F%89%E6%A0%91%E5%B1%95%E5%BC%80%E4%B8%BA%E9%93%BE%E8%A1%A8"><span class="toc-text">114-二叉树展开为链表</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#654-%E6%9E%84%E9%80%A0%E6%9C%80%E5%A4%A7%E4%BA%8C%E5%8F%89%E6%A0%91"><span class="toc-text">654-构造最大二叉树</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#105-%E4%BB%8E%E5%89%8D%E5%BA%8F%E4%B8%8E%E4%B8%AD%E5%BA%8F%E9%81%8D%E5%8E%86%E5%BA%8F%E5%88%97%E6%9E%84%E9%80%A0%E4%BA%8C%E5%8F%89%E6%A0%91"><span class="toc-text">105-从前序与中序遍历序列构造二叉树</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#106-%E4%BB%8E%E4%B8%AD%E5%BA%8F%E4%B8%8E%E5%90%8E%E5%BA%8F%E9%81%8D%E5%8E%86%E5%BA%8F%E5%88%97%E6%9E%84%E9%80%A0%E4%BA%8C%E5%8F%89%E6%A0%91"><span class="toc-text">106-从中序与后序遍历序列构造二叉树</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#104-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%9C%80%E5%A4%A7%E6%B7%B1%E5%BA%A6"><span class="toc-text">104-二叉树的最大深度</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#543-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E7%9B%B4%E5%BE%84"><span class="toc-text">543-二叉树的直径</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91"><span class="toc-text">二叉搜索树</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#230-BST%E7%AC%ACK%E5%B0%8F%E7%9A%84%E5%85%83%E7%B4%A0"><span class="toc-text">230-BST第K小的元素</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#538-1038-%E6%8A%8A%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E8%BD%AC%E6%8D%A2%E4%B8%BA%E7%B4%AF%E5%8A%A0%E6%A0%91"><span class="toc-text">538&#x2F;1038-把二叉搜索树转换为累加树</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#450-%E5%88%A0%E9%99%A4%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E4%B8%AD%E7%9A%84%E8%8A%82%E7%82%B9"><span class="toc-text">450-删除二叉搜索树中的节点</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#701-%E4%BA%8C%E5%8F%89%E6%A0%91%E4%B8%AD%E7%9A%84%E6%8F%92%E5%85%A5%E6%93%8D%E4%BD%9C"><span class="toc-text">701-二叉树中的插入操作</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#700-%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E4%B8%AD%E7%9A%84%E6%90%9C%E7%B4%A2"><span class="toc-text">700-二叉搜索树中的搜索</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#98-%E9%AA%8C%E8%AF%81%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91"><span class="toc-text">98-验证二叉搜索树</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#96-%E4%B8%8D%E5%90%8C%E7%9A%84%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91"><span class="toc-text">96-不同的二叉搜索树</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#95-%E4%B8%8D%E5%90%8C%E7%9A%84%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91-II"><span class="toc-text">95-不同的二叉搜索树 II</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1373-%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E5%AD%90%E6%A0%91%E7%9A%84%E6%9C%80%E5%A4%A7%E9%94%AE%E5%80%BC%E5%92%8C"><span class="toc-text">1373-二叉搜索子树的最大键值和</span></a></li></ol></li></ol>
    
<style>
    .left-col .switch-btn,
    .left-col .switch-area {
        display: none;
    }
    .toc-level-3 i,
    .toc-level-3 ol {
        display: none !important;
    }
</style>
</div>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="二叉树"><a href="#二叉树" class="headerlink" title="二叉树"></a><a target="_blank" rel="noopener" href="https://labuladong.github.io/algo/2/18/">二叉树</a></h1><p>举个例子，比如说我们的经典算法「快速排序」和「归并排序」，对于这两个算法，你有什么理解？<strong>如果你告诉我，快速排序就是个二叉树的前序遍历，归并排序就是个二叉树的后序遍历，那么我就知道你是个算法高手了</strong>。</p>
<p><img src="/2021/06/01/BinaryTree/image-20211030164816981.png" alt="image-20211030164816981"></p>
<p><img src="/2021/06/01/BinaryTree/image-20211030164843414.png" alt="image-20211030164843414"></p>
<hr>
<h2 id="226-翻转二叉树"><a href="#226-翻转二叉树" class="headerlink" title="226-翻转二叉树"></a>226-翻转二叉树</h2><blockquote>
<p><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/invert-binary-tree/"><code>LeetCode</code>-226-简单</a></p>
<p><img src="/2021/06/01/BinaryTree/image-20211030165256560.png" alt="image-20211030165256560"></p>
</blockquote>
<pre><code class="java">public class invertTree_226 &#123;
    /**
     * 翻转一颗二叉树
     * */
    public TreeNode invertTree(TreeNode root) &#123;
        // base case
        if (root == null) &#123;
            return null;
        &#125;

        // 前序遍历
        TreeNode tmp = root.left;
        root.left = root.right;
        root.right = tmp;

        // 让左右子节点继续翻转其子节点
        invertTree(root.left);
        invertTree(root.right);

        return root;
    &#125;
&#125;
</code></pre>
<hr>
<h2 id="116-填充每个节点的下一个右侧节点指针"><a href="#116-填充每个节点的下一个右侧节点指针" class="headerlink" title="116-填充每个节点的下一个右侧节点指针"></a>116-填充每个节点的下一个右侧节点指针</h2><blockquote>
<p><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/populating-next-right-pointers-in-each-node/"><code>LeetCode</code>-116-中等</a></p>
<p>填充它的每个 next 指针，让这个指针指向其下一个右侧节点。如果找不到下一个右侧节点，则将 next 指针设置为 NULL。</p>
<p>初始状态下，所有 next 指针都被设置为 NULL。</p>
<p><img src="/2021/06/01/BinaryTree/image-20211030170136975.png" alt="image-20211030170136975"></p>
<p>节点 5 和节点 6 不属于同一个父节点，那么按照这段代码的逻辑，它俩就没办法被穿起来，这是不符合题意的。</p>
<p>回想刚才说的，<strong>二叉树的问题难点在于，如何把题目的要求细化成每个节点需要做的事情</strong>，但是如果只依赖一个节点的话，肯定是没办法连接「跨父节点」的两个相邻节点的。</p>
<p>那么，我们的做法就是增加函数参数，一个节点做不到，我们就给他安排两个节点，「将每一层二叉树节点连接起来」可以细化成「将每两个相邻节点都连接起来」：</p>
</blockquote>
<pre><code class="java">public class connect_116 &#123;

    class Node &#123;
        public int val;
        public Node left;
        public Node right;
        public Node next;

        public Node() &#123;&#125;

        public Node(int _val) &#123;
            val = _val;
        &#125;

        public Node(int _val, Node _left, Node _right, Node _next) &#123;
            val = _val;
            left = _left;
            right = _right;
            next = _next;
        &#125;
    &#125;;

    public Node connect(Node root) &#123;
        if (root == null) &#123; return null; &#125;
        connectTwoNode(root.left, root.right);

        return root;
    &#125;

    void connectTwoNode(Node node1, Node node2) &#123;
        if (node1 == null || node2 == null) &#123; return; &#125;
        // 前序遍历
        node1.next = node2;
        // 连接相同父节点的两个子节点
        connectTwoNode(node1.left, node1.right);
        connectTwoNode(node2.left, node2.right);
        // 连接跨越父节点的两个子节点
        connectTwoNode(node1.right, node2.left);
    &#125;
&#125;
</code></pre>
<hr>
<h2 id="114-二叉树展开为链表"><a href="#114-二叉树展开为链表" class="headerlink" title="114-二叉树展开为链表"></a>114-二叉树展开为链表</h2><blockquote>
<p><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/flatten-binary-tree-to-linked-list/"><code>LeetCode</code>-114-中等</a></p>
<p><img src="/2021/06/01/BinaryTree/image-20211030170735747.png" alt="image-20211030170735747"></p>
<p>我们尝试给出这个函数的定义：</p>
<p><strong>给 <code>flatten</code> 函数输入一个节点 <code>root</code>，那么以 <code>root</code> 为根的二叉树就会被拉平为一条链表</strong>。</p>
<p>我们再梳理一下，如何按题目要求把一棵树拉平成一条链表？很简单，以下流程：</p>
<p>1、将 <code>root</code> 的左子树和右子树拉平。</p>
<p>2、将 <code>root</code> 的右子树接到左子树下方，然后将整个左子树作为右子树。</p>
<p><img src="/2021/06/01/BinaryTree/image-20211030171534090.png" alt="image-20211030171534090"></p>
</blockquote>
<pre><code class="java">public class flatten_114 &#123;

    public void flatten(TreeNode root) &#123;
        // base case
        if (root == null) &#123; return; &#125;
        // 将左右子树拉平
        flatten(root.left);
        flatten(root.right);
        // 后续遍历
        // 先保存左右子树
        TreeNode left = root.left;
        TreeNode right = root.right;
        // 将左子树作为右子树
        root.left = null;
        root.right = left;
        // 最后将右子树连接到左子树的末端
        TreeNode p = root;
        while (p != null) &#123;
            p = p.right;
        &#125;
        p.right = right;
    &#125;
&#125;
</code></pre>
<p><img src="/2021/06/01/BinaryTree/image-20211030180425178.png" alt="image-20211030180425178"></p>
<hr>
<h2 id="654-构造最大二叉树"><a href="#654-构造最大二叉树" class="headerlink" title="654-构造最大二叉树"></a>654-构造最大二叉树</h2><blockquote>
<p><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/maximum-binary-tree/"><code>LeetCode-654-中等</code></a></p>
<p><img src="/2021/06/01/BinaryTree/image-20211030181007830.png" alt="image-20211030181007830"></p>
<p><img src="/2021/06/01/BinaryTree/image-20211030181037936.png" alt="image-20211030181037936"></p>
<p><img src="/2021/06/01/BinaryTree/image-20211030181336391.png" alt="image-20211030181336391"></p>
</blockquote>
<p><img src="/2021/06/01/BinaryTree/image-20211030181542295.png" alt="image-20211030181542295"></p>
<p><img src="/2021/06/01/BinaryTree/image-20211030181658488.png" alt="image-20211030181658488"></p>
<pre><code class="java">public class constructMaximumBinaryTree_654 &#123;

    void traverse(TreeNode root) &#123;
        if (root == null) &#123;
            return;
        &#125;
        System.out.println(root.val);
        traverse(root.left);
        traverse(root.right);
    &#125;

    public static void main(String[] args) &#123;
        int[] nums = &#123;3, 2, 1, 6, 0, 5&#125;;
        constructMaximumBinaryTree_654 cmb = new constructMaximumBinaryTree_654();
        cmb.traverse(cmb.constructMaximumBinaryTree(nums));
    &#125;
    
    /**
     * 最大二叉树
     * */
    public TreeNode constructMaximumBinaryTree(int[] nums) &#123;
        return build(nums, 0, nums.length-1);
    &#125;

    TreeNode build(int[] nums, int lo, int hi) &#123;
        // base case
        if (lo &gt; hi) &#123;
            return null;
        &#125;

        // 找到数组中的最大值和对应的索引
        int index = -1, maxVal = Integer.MIN_VALUE;
        for (int i = lo; i &lt;= hi; i++) &#123;
            if (maxVal &lt; nums[i]) &#123;
                maxVal = nums[i];
                index = i;
            &#125;
        &#125;
        // 前序遍历
        TreeNode root = new TreeNode(maxVal);
        // 递归调用构造左右子树
        root.left = build(nums, lo, index-1);
        root.right = build(nums, index+1, hi);

        return root;
    &#125;
&#125;
</code></pre>
<hr>
<h2 id="105-从前序与中序遍历序列构造二叉树"><a href="#105-从前序与中序遍历序列构造二叉树" class="headerlink" title="105-从前序与中序遍历序列构造二叉树"></a>105-从前序与中序遍历序列构造二叉树</h2><blockquote>
<p><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/construct-binary-tree-from-preorder-and-inorder-traversal/"><code>LeetCode-105-中等</code></a></p>
<p><img src="/2021/06/01/BinaryTree/image-20211030182837918.png" alt="image-20211030182837918"></p>
<p><img src="/2021/06/01/BinaryTree/image-20211030182921320.png" alt="image-20211030182921320"></p>
</blockquote>
<p><img src="/2021/06/01/BinaryTree/image-20211030183446967.png" alt="image-20211030183446967"></p>
<p><img src="/2021/06/01/BinaryTree/image-20211030183538855.png" alt="image-20211030183538855"></p>
<p><img src="/2021/06/01/BinaryTree/image-20211030183605110.png" alt="image-20211030183605110"></p>
<p><img src="/2021/06/01/BinaryTree/image-20211030183910977.png" alt="image-20211030183910977"></p>
<p><img src="/2021/06/01/BinaryTree/image-20211030184101522.png" alt="image-20211030184101522"></p>
<p><img src="/2021/06/01/BinaryTree/image-20211030184301483.png" alt="image-20211030184301483"></p>
<p><strong>写法一:</strong></p>
<pre><code class="java">TreeNode build(int[] preorder, int preStart, int preEnd, 
               int[] inorder, int inStart, int inEnd) &#123;

    if (preStart &gt; preEnd) &#123;
        return null;
    &#125;

    // root 节点对应的值就是前序遍历数组的第一个元素
    int rootVal = preorder[preStart];
    // rootVal 在中序遍历数组中的索引
    int index = 0;
    for (int i = inStart; i &lt;= inEnd; i++) &#123;
        if (inorder[i] == rootVal) &#123;
            index = i;
            break;
        &#125;
    &#125;

    int leftSize = index - inStart;

    // 先构造出当前根节点
    TreeNode root = new TreeNode(rootVal);
    // 递归构造左右子树
    root.left = build(preorder, preStart + 1, preStart + leftSize,
                      inorder, inStart, index - 1);

    root.right = build(preorder, preStart + leftSize + 1, preEnd,
                       inorder, index + 1, inEnd);
    return root;
&#125;
</code></pre>
<p><strong>写法二:</strong></p>
<pre><code class="java">public class buildTree_105 &#123;
    /**
     * 给定一棵树的前序遍历 preorder 与中序遍历  inorder。
     * 请构造二叉树并返回其根节点。
     * 注意: 你可以假设树中没有重复的元素
     * */
    public TreeNode buildTree(int[] preorder, int[] inorder) &#123;
        return build(preorder, 0, preorder.length-1,
                inorder, 0, inorder.length-1);
    &#125;

    /**
     * 递归构造
     */
    private TreeNode build(int[] preorder, int preStart, int preEnd,
                           int[] inorder, int inStart, int inEnd) &#123;
        // base case
        if (preStart &gt; preEnd) &#123;
            return null;
        &#125;

        // root 对应的值 及 在 中序遍历中的索引
        int rootVal = preorder[preStart];
        int index = preStart;
        for (int i = inStart; i &lt;= inEnd; i++) &#123;
            if (rootVal == inorder[i]) &#123;
                index = i;
                break;
            &#125;
        &#125;

        TreeNode root = new TreeNode(rootVal);
        int len_left = index - inStart;
        root.left = build(preorder, preStart+1, preStart+len_left,
                inorder, inStart, index-1);
        int len_right = inEnd - index;
        root.right = build(preorder, preEnd-len_right+1, preEnd,
                inorder, index+1, inEnd);

        return root;
    &#125;
&#125;
</code></pre>
<hr>
<h2 id="106-从中序与后序遍历序列构造二叉树"><a href="#106-从中序与后序遍历序列构造二叉树" class="headerlink" title="106-从中序与后序遍历序列构造二叉树"></a>106-从中序与后序遍历序列构造二叉树</h2><blockquote>
<p><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/construct-binary-tree-from-inorder-and-postorder-traversal/"><code>LeetCode-106-中等</code></a></p>
<p><img src="/2021/06/01/BinaryTree/image-20211030185204439.png" alt="image-20211030185204439"></p>
</blockquote>
<p><img src="/2021/06/01/BinaryTree/image-20211030185250551.png" alt="image-20211030185250551"></p>
<p><img src="/2021/06/01/BinaryTree/image-20211030185338241.png" alt="image-20211030185338241"></p>
<p><img src="/2021/06/01/BinaryTree/image-20211030185411657.png" alt="image-20211030185411657"></p>
<p><img src="/2021/06/01/BinaryTree/image-20211030185527648.png" alt="image-20211030185527648"></p>
<p><strong>写法一:</strong></p>
<pre><code class="java">TreeNode build(int[] inorder, int inStart, int inEnd,
               int[] postorder, int postStart, int postEnd) &#123;

    if (inStart &gt; inEnd) &#123;
        return null;
    &#125;
    // root 节点对应的值就是后序遍历数组的最后一个元素
    int rootVal = postorder[postEnd];
    // rootVal 在中序遍历数组中的索引
    int index = 0;
    for (int i = inStart; i &lt;= inEnd; i++) &#123;
        if (inorder[i] == rootVal) &#123;
            index = i;
            break;
        &#125;
    &#125;
    // 左子树的节点个数
    int leftSize = index - inStart;
    TreeNode root = new TreeNode(rootVal);
    // 递归构造左右子树
    root.left = build(inorder, inStart, index - 1,
                        postorder, postStart, postStart + leftSize - 1);

    root.right = build(inorder, index + 1, inEnd,
                        postorder, postStart + leftSize, postEnd - 1);
    return root;
&#125;
</code></pre>
<p><strong>写法二:</strong></p>
<pre><code class="java">public class buildTree_106 &#123;
    public TreeNode buildTree(int[] inorder, int[] postorder) &#123;
        return build(inorder, 0, inorder.length-1,
                postorder, 0, postorder.length-1);
    &#125;

    private TreeNode build(int[] inorder, int inStart, int inEnd,
                           int[] postorder, int postStart, int postEnd) &#123;
        // base case
        if (postStart &gt; postEnd) &#123;
            return null;
        &#125;

        // 找到root对应的值和索引
        int rootVal = postorder[postEnd];
        int index = postEnd;
        for (int i = inStart; i &lt;= inEnd; i++) &#123;
            if (inorder[i] == rootVal) &#123;
                index = i;
                break;
            &#125;
        &#125;

        TreeNode root = new TreeNode(rootVal);
        int len_left = index - inStart;
        root.left = build(inorder, inStart, index-1,
                postorder, postStart, postStart+len_left-1);
        int len_right = inEnd - index;
        root.right = build(inorder, index+1, inEnd,
                postorder, postEnd-len_right, postEnd-1);

        return root;
    &#125;
&#125;
</code></pre>
<hr>
<h2 id="104-二叉树的最大深度"><a href="#104-二叉树的最大深度" class="headerlink" title="104-二叉树的最大深度"></a>104-<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/maximum-depth-of-binary-tree/description/">二叉树的最大深度</a></h2><p>给定一个二叉树，找出其最大深度。</p>
<p>二叉树的深度为根节点到最远叶子节点的最长路径上的节点数。</p>
<p><strong>说明:</strong> 叶子节点是指没有子节点的节点。</p>
<p><strong>示例：</strong><br>给定二叉树 <code>[3,9,20,null,null,15,7]</code>，</p>
<pre><code>    3
   / \
  9  20
    /  \
   15   7
</code></pre>
<p>返回它的最大深度 3 。</p>
<p><strong>代码格式:</strong></p>
<pre><code class="java">//leetcode submit region begin(Prohibit modification and deletion)
/**
 * Definition for a binary tree node.
 * public class TreeNode &#123;
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode() &#123;&#125;
 *     TreeNode(int val) &#123; this.val = val; &#125;
 *     TreeNode(int val, TreeNode left, TreeNode right) &#123;
 *         this.val = val;
 *         this.left = left;
 *         this.right = right;
 *     &#125;
 * &#125;
 */
class Solution &#123;
    public int maxDepth(TreeNode root) &#123;
        
    &#125;
&#125;
//leetcode submit region end(Prohibit modification and deletion)
</code></pre>
<blockquote>
<p>遇到一道二叉树的题目时的通用思考过程是：</p>
<p><strong>1、是否可以通过遍历一遍二叉树得到答案</strong>？如果可以，用一个 <code>traverse</code> 函数配合外部变量来实现。</p>
<p><strong>2、是否可以定义一个递归函数，通过子问题（子树）的答案推导出原问题的答案</strong>？如果可以，写出这个递归函数的定义，并充分利用这个函数的返回值。</p>
<p><strong>3、无论使用哪一种思维模式，你都要明白二叉树的每一个节点需要做什么，需要在什么时候（前中后序）做</strong>。</p>
</blockquote>
<p><strong>解法一:</strong> 分解问题</p>
<pre><code class="java">class Solution &#123;
    public int maxDepth(TreeNode root) &#123;
        if (root == null) &#123;
           return 0;
        &#125;

        int leftMax = maxDepth(root.left);
        int rightMax = maxDepth(root.right);
        return Math.max(leftMax, rightMax) + 1;
    &#125;
&#125;
</code></pre>
<p><strong>解法二:</strong> 遍历二叉树</p>
<pre><code class="java">class Solution &#123;
    int depth = 0;
    int res = 0;

    public int maxDepth(TreeNode root) &#123;
        traverse(root);
        return res;
    &#125;

    void traverse(TreeNode root) &#123;
        if (root == null) &#123;
            // 到达叶子结点, 更新最大深度
            res = Math.max(res, depth);
            return;
        &#125;

        depth++;
        traverse(root.left);
        traverse(root.right);
        depth--;
    &#125;
&#125;
</code></pre>
<hr>
<h2 id="543-二叉树的直径"><a href="#543-二叉树的直径" class="headerlink" title="543-二叉树的直径"></a>543-<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/diameter-of-binary-tree/description/">二叉树的直径</a></h2><p>给定一棵二叉树，你需要计算它的直径长度。一棵二叉树的直径长度是任意两个结点路径长度中的最大值。这条路径可能穿过也可能不穿过根结点。</p>
<p><strong>示例 :</strong><br>给定二叉树</p>
<pre><code>          1
         / \
        2   3
       / \     
      4   5    
</code></pre>
<p>返回 <strong>3</strong>, 它的长度是路径 [4,2,1,3] 或者 [5,2,1,3]。</p>
<p><strong>注意：</strong>两结点之间的路径长度是以它们之间边的数目表示。</p>
<p><strong>代码格式:</strong></p>
<pre><code class="java">//leetcode submit region begin(Prohibit modification and deletion)
/**
 * Definition for a binary tree node.
 * public class TreeNode &#123;
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode() &#123;&#125;
 *     TreeNode(int val) &#123; this.val = val; &#125;
 *     TreeNode(int val, TreeNode left, TreeNode right) &#123;
 *         this.val = val;
 *         this.left = left;
 *         this.right = right;
 *     &#125;
 * &#125;
 */
class Solution &#123;
    public int diameterOfBinaryTree(TreeNode root) &#123;

    &#125;
&#125;
//leetcode submit region end(Prohibit modification and deletion)
</code></pre>
<blockquote>
<p>思路:</p>
<p>所谓二叉树的直径，就是左右子树的最大深度之和，那么直接的想法是对每个节点计算左右子树的最大高度，得出每个节点的直径，从而得出最大的那个直径。</p>
<p>灵活运用二叉树的后序遍历，在 <code>maxDepth</code> 的后序遍历位置顺便计算最大直径。</p>
</blockquote>
<p><strong>解题:</strong></p>
<pre><code class="java">class Solution &#123;

    int maxDiameter = 0;

    public int diameterOfBinaryTree(TreeNode root) &#123;
        maxDepth(root);
        return maxDiameter;
    &#125;

    int maxDepth(TreeNode root) &#123;
        if (root == null) &#123;
            return 0;
        &#125;

        int leftMax = maxDepth(root.left);
        int rightMax = maxDepth(root.right);
        maxDiameter = Math.max(maxDiameter, leftMax+rightMax);

        return 1 + Math.max(leftMax, rightMax);
    &#125;
&#125;
</code></pre>
<p>时间复杂度: O(N)</p>
<hr>
<h1 id="二叉搜索树"><a href="#二叉搜索树" class="headerlink" title="二叉搜索树"></a>二叉搜索树</h1><p><img src="/2021/06/01/BinaryTree/image-20211107170336844.png" alt="image-20211107170336844"></p>
<img src="/2021/06/01/BinaryTree/image-20211109163231364.png" alt="image-20211109163231364" style="zoom:80%;">

<p>对于 BST 相关的问题，你可能会经常看到类似下面这样的代码逻辑：</p>
<pre><code class="java">void BST(TreeNode root, int target) &#123;
    if (root.val == target)
        // 找到目标，做点什么
    if (root.val &lt; target) 
        BST(root.right, target);
    if (root.val &gt; target)
        BST(root.left, target);
&#125;
</code></pre>
<p>这个代码框架其实和二叉树的遍历框架差不多，无非就是利用了 BST 左小右大的特性而已。</p>
<hr>
<h2 id="230-BST第K小的元素"><a href="#230-BST第K小的元素" class="headerlink" title="230-BST第K小的元素"></a>230-BST第K小的元素</h2><blockquote>
<p>给定一个二叉搜索树的根节点 <code>root</code> ，和一个整数 <code>k</code> ，请你设计一个算法查找其中第 <code>k</code> 个最小元素（从 1 开始计数）。</p>
<p><img src="/2021/06/01/BinaryTree/image-20211109091239172.png" alt="image-20211109091239172"></p>
</blockquote>
<p>解法一:</p>
<pre><code class="java">/**
 * Definition for a binary tree node.
 * public class TreeNode &#123;
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode() &#123;&#125;
 *     TreeNode(int val) &#123; this.val = val; &#125;
 *     TreeNode(int val, TreeNode left, TreeNode right) &#123;
 *         this.val = val;
 *         this.left = left;
 *         this.right = right;
 *     &#125;
 * &#125;
 */
class Solution &#123;
    public int kthSmallest(TreeNode root, int k) &#123;
        traverse(root, k);
        return res;
    &#125;
    
    int res = 0;
    int rank = 0;
    void traverse(TreeNode root, int k) &#123;
        if (root == null) &#123;
            return;
        &#125;
        
        traverse(root.left, k);
        
        rank++;
        if (k == rank) &#123;
            res = root.val;
            return;
        &#125;
        
        traverse(root.right, k);
    &#125;
    
&#125;
</code></pre>
<p>如果按照我们刚才说的方法，利用「BST 中序遍历就是升序排序结果」这个性质，每次寻找第<code>k</code>小的元素都要中序遍历一次，最坏的时间复杂度是<code>O(N)</code>，<code>N</code>是 BST 的节点个数。</p>
<p>要知道 BST 性质是非常牛逼的，像红黑树这种改良的自平衡 BST，增删查改都是<code>O(logN)</code>的复杂度，让你算一个第<code>k</code>小元素，时间复杂度竟然要<code>O(N)</code>，有点低效了。</p>
<p>所以说，计算第<code>k</code>小元素，最好的算法肯定也是对数级别的复杂度，不过这个依赖于 BST 节点记录的信息有多少。</p>
<blockquote>
<p>优化思路</p>
</blockquote>
<p>那么回到这个问题，想找到第<code>k</code>小的元素，或者说找到排名为<code>k</code>的元素，如果想达到对数级复杂度，关键也在于每个节点得知道他自己排第几。</p>
<p>比如说你让我查找排名为<code>k</code>的元素，当前节点知道自己排名第<code>m</code>，那么我可以比较<code>m</code>和<code>k</code>的大小：</p>
<p>1、如果<code>m == k</code>，显然就是找到了第<code>k</code>个元素，返回当前节点就行了。</p>
<p>2、如果<code>k &lt; m</code>，那说明排名第<code>k</code>的元素在左子树，所以可以去左子树搜索第<code>k</code>个元素。</p>
<p>3、如果<code>k &gt; m</code>，那说明排名第<code>k</code>的元素在右子树，所以可以去右子树搜索第<code>k - m - 1</code>个元素。</p>
<p>这样就可以将时间复杂度降到<code>O(logN)</code>了。</p>
<p><strong>那么，如何让每一个节点知道自己的排名呢？</strong></p>
<p>这就是我们之前说的，需要在二叉树节点中维护额外信息。<strong>每个节点需要记录，以自己为根的这棵二叉树有多少个节点</strong>。</p>
<p>也就是说，我们<code>TreeNode</code>中的字段应该如下：</p>
<pre><code class="java">class TreeNode &#123;
    int val;
    // 以该节点为根的树的节点总数
    int size;
    TreeNode left;
    TreeNode right;
&#125;
</code></pre>
<p>有了<code>size</code>字段，外加 BST 节点左小右大的性质，对于每个节点<code>node</code>就可以通过<code>node.left</code>推导出<code>node</code>的排名，从而做到我们刚才说到的对数级算法。(应该是: <code>node.left.size+1</code>)</p>
<p>当然，<code>size</code>字段需要在增删元素的时候需要被正确维护，力扣提供的<code>TreeNode</code>是没有<code>size</code>这个字段的，所以我们这道题就只能利用 BST 中序遍历的特性实现了，但是我们上面说到的优化思路是 BST 的常见操作，还是有必要理解的。</p>
<h2 id="538-1038-把二叉搜索树转换为累加树"><a href="#538-1038-把二叉搜索树转换为累加树" class="headerlink" title="538/1038-把二叉搜索树转换为累加树"></a>538/1038-把二叉搜索树转换为累加树</h2><blockquote>
<p>给出二叉 搜索 树的根节点，该树的节点值各不相同，请你将其转换为累加树（Greater Sum Tree），使每个节点 node 的新值等于原树中大于或等于 <code>node.val</code> 的值之和。</p>
<p>提醒一下，二叉搜索树满足下列约束条件：</p>
<p>节点的左子树仅包含键 小于 节点键的节点。<br>节点的右子树仅包含键 大于 节点键的节点。<br>左右子树也必须是二叉搜索树。</p>
<p><img src="/2021/06/01/BinaryTree/image-20211109143630899.png" alt="image-20211109143630899"></p>
<p>题目应该不难理解，比如图中的节点 5，转化成累加树的话，比 5 大的节点有 6，7，8，加上 5 本身，所以累加树上这个节点的值应该是 5+6+7+8=26。</p>
</blockquote>
<p>按照二叉树的通用思路，需要思考每个节点应该做什么，但是这道题上很难想到什么思路。</p>
<p>BST 的每个节点左小右大，这似乎是一个有用的信息，既然累加和是计算大于等于当前值的所有元素之和，那么每个节点都去计算右子树的和，不就行了吗？</p>
<p>这是不行的。对于一个节点来说，确实右子树都是比它大的元素，但问题是它的父节点也可能是比它大的元素呀？这个没法确定的，我们又没有触达父节点的指针，所以二叉树的通用思路在这里用不了。</p>
<p><strong>其实，正确的解法很简单，还是利用 BST 的中序遍历特性</strong>。</p>
<blockquote>
<p><strong>只不过这里需要修改遍历的顺序, 并借助一个外部变量!</strong></p>
</blockquote>
<pre><code class="java">/**
 * Definition for a binary tree node.
 * public class TreeNode &#123;
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode() &#123;&#125;
 *     TreeNode(int val) &#123; this.val = val; &#125;
 *     TreeNode(int val, TreeNode left, TreeNode right) &#123;
 *         this.val = val;
 *         this.left = left;
 *         this.right = right;
 *     &#125;
 * &#125;
 */
class Solution &#123;
    public TreeNode convertBST(TreeNode root) &#123;
        traverse(root);
        
        return root;
    &#125;
    
    int sum = 0;
    
    void traverse(TreeNode root) &#123;
        if (root == null) &#123;
            return;
        &#125;
        
        traverse(root.right);
        
        sum += root.val;
        root.val = sum;
        
        traverse(root.left);
    &#125;
&#125;
</code></pre>
<hr>
<h2 id="450-删除二叉搜索树中的节点"><a href="#450-删除二叉搜索树中的节点" class="headerlink" title="450-删除二叉搜索树中的节点"></a>450-删除二叉搜索树中的节点</h2><blockquote>
<p>给定一个二叉搜索树的根节点 root 和一个值 key，删除二叉搜索树中的 key 对应的节点，并保证二叉搜索树的性质不变。返回二叉搜索树（有可能被更新）的根节点的引用。</p>
<p>一般来说，删除节点可分为两个步骤：</p>
<p>首先找到需要删除的节点；<br>如果找到了，删除它。</p>
<p><img src="/2021/06/01/BinaryTree/image-20211109153410734.png" alt="image-20211109153410734"></p>
<p><img src="/2021/06/01/BinaryTree/image-20211109153425487.png" alt="image-20211109153425487"></p>
</blockquote>
<blockquote>
<p>删除二叉树节点的代码逻辑:</p>
</blockquote>
<pre><code class="java">TreeNode deleteNode(TreeNode root, int key) &#123;
    if (root.val == key) &#123;
        // 找到啦，进行删除
    &#125; else if (root.val &gt; key) &#123;
        // 去左子树找
        root.left = deleteNode(root.left, key);
    &#125; else if (root.val &lt; key) &#123;
        // 去右子树找
        root.right = deleteNode(root.right, key);
    &#125;
    return root;
&#125;
</code></pre>
<blockquote>
<p>找到目标节点了，比方说是节点<code>A</code>，如何删除这个节点，这是难点。因为删除节点的同时不能破坏 BST 的性质。</p>
</blockquote>
<p><strong>有三种情况，用图片来说明:</strong> </p>
<img src="/2021/06/01/BinaryTree/image-20211109155433591.png" alt="image-20211109155433591" style="zoom:80%;">



<img src="/2021/06/01/BinaryTree/image-20211109155557750.png" alt="image-20211109155557750" style="zoom:80%;">



<img src="/2021/06/01/BinaryTree/image-20211109155648601.png" alt="image-20211109155648601" style="zoom:80%;">

<blockquote>
<p>三种情况分析完毕，填入框架，简化一下代码：</p>
</blockquote>
<pre><code class="java">/**
 * Definition for a binary tree node.
 * public class TreeNode &#123;
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode() &#123;&#125;
 *     TreeNode(int val) &#123; this.val = val; &#125;
 *     TreeNode(int val, TreeNode left, TreeNode right) &#123;
 *         this.val = val;
 *         this.left = left;
 *         this.right = right;
 *     &#125;
 * &#125;
 */
class Solution &#123;
    public TreeNode deleteNode(TreeNode root, int key) &#123;
        // base case
        if (root == null) &#123; return null; &#125;

        if (root.val == key) &#123;
            // 这两个 if 把情况 1 和 2 都正确处理了
            if (root.left == null) &#123; return root.right; &#125;
            if (root.right == null) &#123; return root.left; &#125;
            // 情况3: 两个节点都有的情况 (获得右子树中最小的)
            TreeNode minNode = getMin(root.right);
            // 把 root 改成 minNode
            root.val = minNode.val;
            // 转而去删除 minNode
            root.right = deleteNode(root.right, minNode.val);
        &#125; else if (root.val &gt; key) &#123;
            // 去左子树找
            root.left = deleteNode(root.left, key);
        &#125; else if (root.val &lt; key) &#123;
            // 去右子树找
            root.right = deleteNode(root.right, key);
        &#125;
        return root;
    &#125;

    /**
     * 获得右子树中最小的
     * */
    TreeNode getMin(TreeNode node) &#123;
        // BST 最左边的就是最小的
        while (node.left != null) &#123;
            node = node.left;
        &#125;
        return node;
    &#125;
&#125;
</code></pre>
<p>删除操作就完成了。</p>
<p>注意一下，这个删除操作并不完美，因为我们一般不会通过<code>root.val = minNode.val</code>修改节点内部的值来交换节点，而是通过一系列略微复杂的链表操作交换<code>root</code>和<code>minNode</code>两个节点。</p>
<p>因为具体应用中，<code>val</code>域可能会是一个复杂的数据结构，修改起来非常麻烦；而链表操作无非改一改指针，而不会去碰内部数据。</p>
<p>不过这里我们暂时忽略这个细节，旨在突出 BST 基本操作的共性，以及借助框架逐层细化问题的思维方式。</p>
<hr>
<h2 id="701-二叉树中的插入操作"><a href="#701-二叉树中的插入操作" class="headerlink" title="701-二叉树中的插入操作"></a>701-二叉树中的插入操作</h2><blockquote>
<p>给定二叉搜索树（BST）的根节点和要插入树中的值，将值插入二叉搜索树。 返回插入后二叉搜索树的根节点。输入数据 保证 ，新值和原始二叉搜索树中的任意节点值都不同。</p>
<p>注意，可能存在多种有效的插入方式，只要树在插入后仍保持为二叉搜索树即可。 你可以返回 任意有效的结果 。</p>
<p><img src="/2021/06/01/BinaryTree/image-20211109162625924.png" alt="image-20211109162625924"></p>
</blockquote>
<p>对数据结构的操作无非遍历 + 访问，遍历就是「找」，访问就是「改」。</p>
<p>具体到这个问题，插入一个数，就是先找到插入位置，然后进行插入操作。</p>
<p><strong>一旦涉及「改」，函数就要返回 <code>TreeNode</code> 类型，并且对递归调用的返回值进行接收</strong>。</p>
<pre><code class="java">class Solution &#123;
    TreeNode insertIntoBST(TreeNode root, int val) &#123;
        // 找到空位置插入新节点
        if (root == null) return new TreeNode(val);
        
        // if (root.val == val)
        //     BST 中一般不会插入已存在元素
        if (root.val &lt; val) 
            root.right = insertIntoBST(root.right, val);
        if (root.val &gt; val) 
            root.left = insertIntoBST(root.left, val);
        return root;
    &#125;
&#125;
</code></pre>
<hr>
<h2 id="700-二叉搜索树中的搜索"><a href="#700-二叉搜索树中的搜索" class="headerlink" title="700-二叉搜索树中的搜索"></a>700-二叉搜索树中的搜索</h2><blockquote>
<p>给定二叉搜索树（BST）的根节点和一个值。 你需要在BST中找到节点值等于给定值的节点。 返回以该节点为根的子树。 如果节点不存在，则返回 NULL。</p>
<p><img src="/2021/06/01/BinaryTree/image-20211109171235390.png" alt="image-20211109171235390"></p>
</blockquote>
<blockquote>
<p>其实不需要递归地搜索两边，类似二分查找思想，根据 <code>target</code> 和 <code>root.val</code> 的大小比较，就能排除一边。</p>
</blockquote>
<p>写法一:</p>
<pre><code class="java">class Solution &#123;
    public TreeNode searchBST(TreeNode root, int val) &#123;
        if (root == null) &#123; return null; &#125;

        if (val == root.val) &#123;
            return root;
        &#125; else if (val &lt; root.val) &#123;
            return searchBST(root.left, val);
        &#125; else if (val &gt; root.val) &#123;
            return searchBST(root.right, val);
        &#125;

        return null;
    &#125;
&#125;
</code></pre>
<p>写法二: (优化后)</p>
<pre><code class="java">class Solution &#123;
    TreeNode searchBST(TreeNode root, int target) &#123;
        if (root == null) &#123;
            return null;
        &#125;
        // 去左子树搜索
        if (root.val &gt; target) &#123;
            return searchBST(root.left, target);
        &#125;
        // 去右子树搜索
        if (root.val &lt; target) &#123;
            return searchBST(root.right, target);
        &#125;
        return root;
    &#125;
&#125;
</code></pre>
<hr>
<h2 id="98-验证二叉搜索树"><a href="#98-验证二叉搜索树" class="headerlink" title="98-验证二叉搜索树"></a>98-验证二叉搜索树</h2><blockquote>
<p>给你一个二叉树的根节点 root ，判断其是否是一个有效的二叉搜索树。</p>
<p>有效 二叉搜索树定义如下：</p>
<ul>
<li>节点的左子树只包含 <strong>小于</strong> 当前节点的数。</li>
<li>节点的右子树只包含 <strong>大于</strong> 当前节点的数。</li>
<li>所有左子树和右子树自身必须也是二叉搜索树。</li>
</ul>
<img src="/2021/06/01/BinaryTree/image-20211109173757839.png" alt="image-20211109173757839" style="zoom:80%; margin:-1px">
</blockquote>
<blockquote>
<p>分析过程</p>
</blockquote>
<img src="/2021/06/01/BinaryTree/image-20211109174819115.png" alt="image-20211109174819115" style="zoom:80%; margin:-1px;">

<p><strong>出现问题的原因在于，对于每一个节点<code>root</code>，代码值检查了它的左右孩子节点是否符合左小右大的原则；</strong></p>
<p>**但是根据 BST 的定义，<code>root</code>的整个左子树都要小于<code>root.val</code>，整个右子树都要大于<code>root.val</code>**。</p>
<blockquote>
<p>问题是，对于某一个节点<code>root</code>，他只能管得了自己的左右子节点，怎么把<code>root</code>的约束传递给左右子树呢？</p>
</blockquote>
<p>请看正确的代码：</p>
<pre><code class="java">class Solution &#123;
    public boolean isValidBST(TreeNode root) &#123;
        return isValidBST(root, null, null);
    &#125;

    private boolean isValidBST(TreeNode root, TreeNode min, TreeNode max) &#123;
        if (root == null) &#123; return true; &#125;

        if (min != null &amp;&amp; root.val &lt;= min.val) &#123; return false; &#125;
        if (max != null &amp;&amp; root.val &gt;= max.val) &#123; return false; &#125;

        // 节点的左子树只包含 **小于** 当前节点的数。
        // 节点的右子树只包含 **大于** 当前节点的数。
        // 所有左子树和右子树自身必须也是二叉搜索树。
        return isValidBST(root.left, min, root) &amp;&amp; isValidBST(root.right, root, max);
    &#125;

&#125;
</code></pre>
<p><strong>我们通过使用辅助函数，增加函数参数列表，在参数中携带额外信息，将这种约束传递给子树的所有节点，这也是二叉树算法的一个小技巧吧</strong>。</p>
<hr>
<h2 id="96-不同的二叉搜索树"><a href="#96-不同的二叉搜索树" class="headerlink" title="96-不同的二叉搜索树"></a>96-不同的二叉搜索树</h2><blockquote>
<p><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/unique-binary-search-trees/">https://leetcode-cn.com/problems/unique-binary-search-trees/</a></p>
<p>给你一个整数 <code>n</code> ，求恰由 <code>n</code> 个节点组成且节点值从 <code>1</code> 到 <code>n</code> 互不相同的 <strong>二叉搜索树</strong> 有多少种？</p>
<p>返回满足题意的二叉搜索树的种数。</p>
<img src="/2021/06/01/BinaryTree/image-20211115174049902.png" alt="image-20211115174049902" style="zoom:80%; margin:10px;">
</blockquote>
<p><strong>这就是一个正宗的穷举问题，那么什么方式能够正确地穷举合法 BST 的数量呢？</strong></p>
<p>我们前文说过，不要小看「穷举」，这是一件看起来简单但是比较有技术含量的事情，问题的关键就是不能数漏，也不能数多，你咋整？</p>
<p><strong>二叉树算法的关键就在于明确根节点需要做什么，其实 BST 作为一种特殊的二叉树，核心思路也是一样的。</strong></p>
<p>举个例子，比如给算法输入 <code>n = 5</code>，也就是说用 <code>&#123;1,2,3,4,5&#125;</code> 这些数字去构造 BST。</p>
<p><strong>首先，这棵 BST 的根节点总共有几种情况？</strong></p>
<p>显然有 5 种情况对吧，因为每个数字都可以作为根节点。</p>
<p>比如说我们固定 <code>3</code> 作为根节点，这个前提下能有几种不同的 BST 呢？</p>
<p><strong>根据 BST 的特性，根节点的左子树都比根节点的值小，右子树的值都比根节点的值大。</strong></p>
<p>所以如果固定 <code>3</code> 作为根节点，左子树节点就是 <code>&#123;1,2&#125;</code> 的组合，右子树就是 <code>&#123;4,5&#125;</code> 的组合。</p>
<p><strong>左子树的组合数和右子树的组合数乘积</strong>就是 <code>3</code> 作为根节点时的 BST 个数。</p>
<img src="/2021/06/01/BinaryTree/image-20211115174948606.png" alt="image-20211115174948606" style="zoom:80%; margin:10px;">

<p>我们这是说了 <code>3</code> 为根节点这一种特殊情况，其实其他的节点也是一样的。</p>
<p>注意 base case，显然当 <code>lo &gt; hi</code> 闭区间 <code>[lo, hi]</code> 肯定是个空区间，也就对应着空节点 null，虽然是空节点，但是也是一种情况，所以要返回 1 而不能返回 0。</p>
<p>这样，题目的要求已经实现了，但是时间复杂度非常高，肯定存在重叠子问题。</p>
<p>消除重叠子问题的方法，无非就是加一个备忘录：</p>
<pre><code class="java">class Solution &#123;
    
    /**
     * 备忘录
     * */
    private int[][] memo;
    
    public int numTrees(int n) &#123;
        // 备忘录的值初始化为 0
        memo = new int[n+1][n+1];
        
        // 计算闭区间 [1, n] 组成的 BST 个数
        return count(1, n);
    &#125;
    
    /**
     * 计算闭区间 [lo, hi] 组成的 BST 个数
     * */
    int count(int lo, int hi) &#123;
        //base code
        if (lo &gt; hi) &#123;
            return 1;
        &#125;
        
        // 查备忘录
        if (memo[lo][hi] != 0) &#123;
            return memo[lo][hi];
        &#125;

        int res = 0;
        for (int i = lo; i &lt;= hi; i++) &#123;
            // i 的值作为根节点 root
            int left = count(lo, i-1);
            int right = count(i+1, hi);
            // 左右子树的组合数乘积是 BST 的总数
            res += left * right;
        &#125;
        
        // 将结果存入备忘录
        memo[lo][hi] = res;

        return res;
    &#125;
&#125;
</code></pre>
<hr>
<h2 id="95-不同的二叉搜索树-II"><a href="#95-不同的二叉搜索树-II" class="headerlink" title="95-不同的二叉搜索树 II"></a>95-不同的二叉搜索树 II</h2><p>那么，如果给一个进阶题目，不止让你计算有几个不同的 BST，而是要你构建出所有合法的 BST，如何实现这个算法呢？</p>
<blockquote>
<p><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/unique-binary-search-trees-ii/">https://leetcode-cn.com/problems/unique-binary-search-trees-ii/</a></p>
<p>给你一个整数 <code>n</code> ，请你生成并返回所有由 <code>n</code> 个节点组成且节点值从 <code>1</code> 到 <code>n</code> 互不相同的不同 <strong>二叉搜索树</strong> 。</p>
<p>可以按 <strong>任意顺序</strong> 返回答案。</p>
<img src="/2021/06/01/BinaryTree/image-20211115175508634.png" alt="image-20211115175508634" style="zoom:80%; margin:10px;">
</blockquote>
<p><img src="/2021/06/01/BinaryTree/image-20211115175604138.png" alt="image-20211115175604138"></p>
<p><strong>直接看代码：</strong></p>
<pre><code class="java">/**
 * Definition for a binary tree node.
 * public class TreeNode &#123;
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode() &#123;&#125;
 *     TreeNode(int val) &#123; this.val = val; &#125;
 *     TreeNode(int val, TreeNode left, TreeNode right) &#123;
 *         this.val = val;
 *         this.left = left;
 *         this.right = right;
 *     &#125;
 * &#125;
 */
class Solution &#123;
    public List&lt;TreeNode&gt; generateTrees(int n) &#123;
        if (n == 0) &#123;
            return new LinkedList&lt;&gt;();
        &#125;

        // 构造闭区间 [1, n] 组成的 BST
        return build(1, n);
    &#125;
    
    /**
     * 构造闭区间 [lo, hi] 组成的 BST
     * */
    private List&lt;TreeNode&gt; build(int lo, int hi) &#123;
        List&lt;TreeNode&gt; res = new LinkedList&lt;&gt;();

        // base case
        if (lo &gt; hi) &#123;
            res.add(null);
            return res;
        &#125;

        // 1 穷举 root 节点的所有可能
        for (int i = lo; i &lt;= hi; i++) &#123;
            // 2 递归构造出左右子树的所有合法BST
            List&lt;TreeNode&gt; leftTree = build(lo, i-1);
            List&lt;TreeNode&gt; rightTree = build(i+1, hi);
            // 3 给 root 节点穷举所有左右子树的组合
            for (TreeNode left : leftTree) &#123;
                for (TreeNode right : rightTree) &#123;
                    // i 作为根节点 root 的值
                    TreeNode root = new TreeNode(i);
                    root.left = left;
                    root.right = right;
                    res.add(root);
                &#125;
            &#125;
        &#125;

        return res;
    &#125;
    
&#125;
</code></pre>
<hr>
<h2 id="1373-二叉搜索子树的最大键值和"><a href="#1373-二叉搜索子树的最大键值和" class="headerlink" title="1373-二叉搜索子树的最大键值和"></a>1373-二叉搜索子树的最大键值和</h2><blockquote>
<p><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/maximum-sum-bst-in-binary-tree/">https://leetcode-cn.com/problems/maximum-sum-bst-in-binary-tree/</a></p>
<p>给你一棵以 root 为根的 二叉树 ，请你返回 任意 二叉搜索子树的最大键值和。</p>
<p>二叉搜索树的定义如下：</p>
<p>任意节点的左子树中的键值都 小于 此节点的键值。<br>任意节点的右子树中的键值都 大于 此节点的键值。<br>任意节点的左子树和右子树都是二叉搜索树。</p>
<img src="/2021/06/01/BinaryTree/image-20211117161509256.png" alt="image-20211117161509256" style="zoom:80%; margin:10px;">

<p><strong>提示：</strong></p>
<ul>
<li>每棵树有 <code>1</code> 到 <code>40000</code> 个节点。</li>
<li>每个节点的键值在 <code>[-4 * 10^4 , 4 * 10^4]</code> 之间。</li>
</ul>
</blockquote>
<p><strong>理论分析:</strong></p>
<p>后续遍历框架:</p>
<pre><code class="java">void traverse(TreeNode root) &#123;
    traverse(root.left);
    traverse(root.right);
    /* 后序遍历代码的位置 */
    /* 在这里处理当前节点 */
&#125;
</code></pre>
<p><strong>如果当前节点要做的事情需要通过左右子树的计算结果推导出来，就要用到后序遍历</strong>。</p>
<p><strong>那么我们想计算子树中 BST 的最大和，站在当前节点的视角，需要做什么呢</strong>？</p>
<p>1、我肯定得知道左右子树是不是合法的 BST，如果这俩儿子有一个不是 BST，以我为根的这棵树肯定不会是 BST，对吧。</p>
<p>2、如果左右子树都是合法的 BST，我得瞅瞅左右子树加上自己还是不是合法的 BST 了。因为按照 BST 的定义，当前节点的值应该大于左子树的最大值，小于右子树的最小值，否则就破坏了 BST 的性质。</p>
<p>3、因为题目要计算最大的节点之和，如果左右子树加上我自己还是一棵合法的 BST，也就是说以我为根的整棵树是一棵 BST，那我需要知道我们这棵 BST 的所有节点值之和是多少，方便和别的 BST 争个高下，对吧。</p>
<p><strong>根据以上三点，站在当前节点的视角，需要知道以下具体信息</strong>：</p>
<p>1、左右子树是否是 BST。</p>
<p>2、左子树的最大值和右子树的最小值。</p>
<p>3、左右子树的节点值之和。</p>
<p>伪代码大致逻辑:</p>
<pre><code class="java">// 全局变量，记录 BST 最大节点之和
int maxSum = 0;

/* 主函数 */
public int maxSumBST(TreeNode root) &#123;
    traverse(root);
    return maxSum;
&#125;

/* 遍历二叉树 */
void traverse(TreeNode root) &#123;
    if (root == null) &#123;
        return;
    &#125;

    /******* 前序遍历位置 *******/
    // 判断左右子树是不是 BST
    if (!isBST(root.left) || !isBST(root.right)) &#123;
        goto next;
    &#125;
    // 计算左子树的最大值和右子树的最小值
    int leftMax = findMax(root.left);
    int rightMin = findMin(root.right);
    // 判断以 root 节点为根的树是不是 BST
    if (root.val &lt;= leftMax || root.val &gt;= rightMin) &#123;
        goto next;
    &#125;
    // 如果条件都符合，计算当前 BST 的节点之和
    int leftSum = findSum(root.left);
    int rightSum = findSum(root.right);
    int rootSum = leftSum + rightSum + root.val;
    // 计算 BST 节点的最大和
    this.maxSum = Math.max(maxSum, rootSum);
    /**************************/

    // 递归左右子树
    next:
    traverse(root.left);
    traverse(root.right);
&#125;

/* 计算以 root 为根的二叉树的最大值 */
int findMax(TreeNode root) &#123;&#125;

/* 计算以 root 为根的二叉树的最小值 */
int findMin(TreeNode root) &#123;&#125;

/* 计算以 root 为根的二叉树的节点和 */
int findSum(TreeNode root) &#123;&#125;

/* 判断以 root 为根的二叉树是否是 BST */
boolean isBST(TreeNode root) &#123;&#125;
</code></pre>
<p><strong>稍作分析就会发现，这几个辅助函数都是递归函数，都要遍历输入的二叉树，外加 <code>traverse</code> 函数本身的递归，可以说是递归上加递归，所以这个解法的复杂度是非常高的</strong>。</p>
<p>但是根据刚才的分析，像 <code>leftMax</code>、<code>rootSum</code> 这些变量又都得算出来，否则无法完成题目的要求。</p>
<p>我们希望既算出这些变量，又避免辅助函数带来的额外复杂度，鱼和熊掌全都要！</p>
<p>其实是可以的，<strong>只要把前序遍历变成后序遍历，让 <code>traverse</code> 函数把辅助函数做的事情顺便做掉</strong>。</p>
<p>其他代码不变，我们让 <code>traverse</code> 函数做一些计算任务，返回一个数组：</p>
<blockquote>
<p><code>traverse(root)</code> 返回一个大小为 4 的 <code>int</code> 数组，我们暂且称它为 <code>res</code>，其中：</p>
<ul>
<li><code>res[0]</code> 记录以 <code>root</code> 为根的二叉树是否是 BST，若为 1 则说明是 BST，若为 0 则说明不是 BST；</li>
<li><code>res[1]</code> 记录以 <code>root</code> 为根的二叉树所有节点中的最小值；</li>
<li><code>res[2]</code> 记录以 <code>root</code> 为根的二叉树所有节点中的最大值；</li>
<li><code>res[3]</code> 记录以 <code>root</code> 为根的二叉树所有节点值之和。</li>
</ul>
<p>其实这就是把之前分析中说到的几个值放到了 <code>res</code> 数组中，<strong>最重要的是，我们要试图通过 <code>left</code> 和 <code>right</code> 正确推导出 <code>res</code> 数组</strong>。</p>
</blockquote>
<pre><code class="java">class Solution &#123;
    // 全局变量，记录 BST 最大节点之和
    int maxSum = 0;

    /* 主函数 */
    public int maxSumBST(TreeNode root) &#123;
        traverse(root);
        return maxSum;
    &#125;

    // 函数返回 res = new int[] &#123;isBST, min, max, sum&#125;;
    int[] traverse(TreeNode root) &#123;
        // base case
        if (root == null) &#123;
            return new int[]&#123;1, Integer.MAX_VALUE, Integer.MIN_VALUE, 0&#125;;
        &#125;

        // 递归计算左右子树
        int[] left = traverse(root.left);
        int[] right = traverse(root.right);

        /******* 后序遍历位置 *******/
        int[] res = new int[4];
        // 这个 if 在判断以 root 为根的二叉树是不是 BST
        if (left[0] == 1 &amp;&amp; right[0] == 1 
        &amp;&amp; root.val &gt; left[2] &amp;&amp; root.val &lt; right[1]) &#123;
            // 以 root 为根的二叉树是 BST
            res[0] = 1;
            // 计算以 root 为根的这棵 BST 的最小值
            res[1] = Math.min(left[1], root.val);
            // 计算以 root 为根的这棵 BST 的最大值
            res[2] = Math.max(right[2], root.val);
            // 计算以 root 为根的这棵 BST 所有节点之和
            res[3] = left[3] + right[3] + root.val;
            // 更新全局变量
            maxSum = Math.max(maxSum, res[3]);
        &#125; else &#123;
            // 以 root 为根的二叉树不是 BST
            res[0] = 0;
            // 其他的值都没必要计算了，因为用不到
        &#125;

        return res;
    &#125;
&#125;
</code></pre>
<p>这样，这道题就解决了，<code>traverse</code> 函数在遍历二叉树的同时顺便把之前辅助函数做的事情都做了，避免了在递归函数中调用递归函数，时间复杂度只有 O(N)。</p>
<p>你看，这就是后序遍历的妙用，相对前序遍历的解法，现在的解法不仅效率高，而且代码量少，比较优美。</p>
<blockquote>
<p>这道题为什么用后序遍历呢，因为我们需要的这些变量都是可以通过后序遍历得到的。</p>
</blockquote>
<p>你计算以 <code>root</code> 为根的二叉树的节点之和，是不是可以通过左右子树的和加上 <code>root.val</code> 计算出来？</p>
<p>你计算以 <code>root</code> 为根的二叉树的最大值/最小值，是不是可以通过左右子树的最大值/最小值和 <code>root.val</code> 比较出来？</p>
<p>你判断以 <code>root</code> 为根的二叉树是不是 BST，是不是得先判断左右子树是不是 BST？是不是还得看看左右子树的最大值和最小值？</p>
<p>文章开头说过，<strong>如果当前节点要做的事情需要通过左右子树的计算结果推导出来，就要用到后序遍历</strong>。</p>
<p>因为以上几点都可以通过后序遍历的方式计算出来，所以这道题使用后序遍历肯定是最高效的。</p>
<hr>
<hr>

      
       <hr><span style="font-style: italic;color: gray;"> 转载请注明来源，欢迎对文章中的引用来源进行考证，欢迎指出任何有错误或不够清晰的表达。可以在下面评论区评论，也可以邮件至 jungle8884@163.com </span>
    </div>
</article>


<p>
    <a  class="dashang" onclick="dashangToggle()">赏</a>
</p>




    <div id="comments"></div>
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/gitalk@1/dist/gitalk.css">

<script type="text/javascript">
    $.getScript('/js/gitalk.js', function () {
        var gitalk = new Gitalk({
            clientID: '',
            clientSecret: '',
            repo: 'jungle8884.github.io',
            owner: 'jungle8884',
            admin: ['jungle8884'],
            id: decodeURI(location.pathname),
            distractionFreeMode: 'true',
            language: 'zh-CN',
            perPage: parseInt('10',10)
        })
        gitalk.render('comments')
    })
</script>




    




    </div>
    <div class="copyright">
        <p class="footer-entry">
    ©2019-2022 Jungle
</p>
<p class="footer-entry">Built with <a href="https://hexo.io/" target="_blank">Hexo</a> and <a href="https://github.com/yelog/hexo-theme-3-hexo" target="_blank">3-hexo</a> theme</p>

    </div>
    <div class="full-toc">
        <button class="full" data-title="切换全屏 快捷键 s"><span class="min "></span></button>
<a class="" id="rocket" ></a>

    </div>
</div>

<div class="hide_box" onclick="dashangToggle()"></div>
<div class="shang_box">
    <a class="shang_close"  onclick="dashangToggle()">×</a>
    <div class="shang_tit">
        <p>喜欢就点赞,疼爱就打赏</p>
    </div>
    <div class="shang_payimg">
        <div class="pay_img">
            <img src="/img/alipay.jpg" class="alipay" title="扫码支持">
            <img src="/img/weixin.jpg" class="weixin" title="扫码支持">
        </div>
    </div>
    <div class="shang_payselect">
        <span><label><input type="radio" name="pay" checked value="alipay">支付宝</label></span><span><label><input type="radio" name="pay" value="weixin">微信</label></span>
    </div>
</div>


</body>
<script src="/js/jquery.pjax.js?v=1.1.0" ></script>

<script src="/js/script.js?v=1.1.0" ></script>
<script>
    var img_resize = 'default';
    function initArticle() {
        /*渲染对应的表格样式*/
        
            $("#post .pjax table").addClass("green_title");
        

        /*渲染打赏样式*/
        
        $("input[name=pay]").on("click", function () {
            if($("input[name=pay]:checked").val()=="weixin"){
                $(".shang_box .shang_payimg .pay_img").addClass("weixin_img");
            } else {
                $(".shang_box .shang_payimg .pay_img").removeClass("weixin_img");
            }
        })
        

        /*高亮代码块行号*/
        

        /*访问数量*/
        
        $.getScript("//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js");
        

        /*代码高亮，行号对齐*/
        $('.pre-numbering').css('line-height',$('.has-numbering').css('line-height'));

        
        
    }

    /*打赏页面隐藏与展示*/
    
    function dashangToggle() {
        $(".shang_box").fadeToggle();
        $(".hide_box").fadeToggle();
    }
    

</script>

<!--加入行号的高亮代码块样式-->

<!--自定义样式设置-->
<style>
    
    
    .nav {
        width: 542px;
    }
    .nav.fullscreen {
        margin-left: -542px;
    }
    .nav-left {
        width: 120px;
    }
    
    
    @media screen and (max-width: 1468px) {
        .nav {
            width: 492px;
        }
        .nav.fullscreen {
            margin-left: -492px;
        }
        .nav-left {
            width: 100px;
        }
    }
    
    
    @media screen and (max-width: 1024px) {
        .nav {
            width: 492px;
            margin-left: -492px
        }
        .nav.fullscreen {
            margin-left: 0;
        }
    }
    
    @media screen and (max-width: 426px) {
        .nav {
            width: 100%;
        }
        .nav-left {
            width: 100%;
        }
    }
    
    
    .nav-right .title-list nav a .post-title, .nav-right .title-list #local-search-result a .post-title {
        color: #383636;
    }
    
    
    .nav-right .title-list nav a .post-date, .nav-right .title-list #local-search-result a .post-date {
        color: #5e5e5f;
    }
    
    
    .nav-right nav a.hover, #local-search-result a.hover{
        background-color: #e2e0e0;
    }
    
    

    /*列表样式*/
    

    /* 背景图样式 */
    
    


    /*引用块样式*/
    

    /*文章列表背景图*/
    

    
</style>







</html>
