<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <title>Vue | blog of Jungle</title>
  <meta name="keywords" content=" Vue ">
  <meta name="description" content="Vue | blog of Jungle">
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
<meta name="description" content="个人介绍Jungle  本科毕业于CUIT, 目前在沈阳读研. 喜欢学习新技术 成为一个合格的程序员, 一定要学好三样东西: 数学 情商 财商     最近什么的干活 论文 刷算法题 秋招 规范: 阿里巴巴开发手册 做项目: 项目基本功能已实现, 后续优化中… 加油， 你一定行！！！   联系方式 email: &amp;#74;&amp;#117;&amp;#110;&amp;#103;&amp;#x6c;&amp;#101;&amp;#x38;&amp;#">
<meta property="og:type" content="website">
<meta property="og:title" content="个人简介">
<meta property="og:url" content="http://example.com/about/index.html">
<meta property="og:site_name" content="blog of Jungle">
<meta property="og:description" content="个人介绍Jungle  本科毕业于CUIT, 目前在沈阳读研. 喜欢学习新技术 成为一个合格的程序员, 一定要学好三样东西: 数学 情商 财商     最近什么的干活 论文 刷算法题 秋招 规范: 阿里巴巴开发手册 做项目: 项目基本功能已实现, 后续优化中… 加油， 你一定行！！！   联系方式 email: &amp;#74;&amp;#117;&amp;#110;&amp;#103;&amp;#x6c;&amp;#101;&amp;#x38;&amp;#">
<meta property="og:locale" content="zh_CN">
<meta property="article:published_time" content="2020-11-13T11:42:01.000Z">
<meta property="article:modified_time" content="2021-09-29T14:22:42.308Z">
<meta property="article:author" content="Jungle">
<meta name="twitter:card" content="summary">


<link rel="icon" href="/img/avatar.jpg">

<link href="/css/style.css?v=1.1.0" rel="stylesheet">

<link href="/css/hl_theme/darcula.css?v=1.1.0" rel="stylesheet">

<link href="//cdn.jsdelivr.net/npm/animate.css@4.1.0/animate.min.css" rel="stylesheet">

<script src="//cdn.jsdelivr.net/npm/jquery@3.5.1/dist/jquery.min.js"></script>
<script src="/js/titleTip.js?v=1.1.0" ></script>

<script src="//cdn.jsdelivr.net/npm/highlightjs@9.16.2/highlight.pack.min.js"></script>
<script>
    hljs.initHighlightingOnLoad();
</script>

<script src="//cdn.jsdelivr.net/npm/nprogress@0.2.0/nprogress.min.js"></script>



<script src="//cdn.jsdelivr.net/npm/jquery.cookie@1.4.1/jquery.cookie.min.js" ></script>

<script src="/js/iconfont.js?v=1.1.0" ></script>

<meta name="generator" content="Hexo 5.4.2"></head>
<div style="display: none">
  <input class="theme_disqus_on" value="false">
  <input class="theme_preload_comment" value="">
  <input class="theme_blog_path" value="">
  <input id="theme_shortcut" value="true" />
  <input id="theme_highlight_on" value="true" />
  <input id="theme_code_copy" value="true" />
</div>



<body>
<aside class="nav">
    <div class="nav-left">
        <a href="/" class="avatar_target">
    <img class="avatar" src="/img/avatar.jpg" />
</a>
<div class="author">
    <span>Jungle</span>
</div>

<div class="icon">
    
        
        <a title="rss" href="/atom.xml" target="_blank">
            
                <svg class="iconfont-svg" aria-hidden="true">
                    <use xlink:href="#icon-rss"></use>
                </svg>
            
        </a>
        
    
        
        <a title="github" href="https://github.com/jungle8884" target="_blank">
            
                <svg class="iconfont-svg" aria-hidden="true">
                    <use xlink:href="#icon-github"></use>
                </svg>
            
        </a>
        
    
        
        <a title="leetcode" href="https://leetcode-cn.com/progress/" target="_blank">
            
                <svg class="iconfont-svg" aria-hidden="true">
                    <use xlink:href="#icon-leetcode"></use>
                </svg>
            
        </a>
        
    
        
        <a title="csdn" href="https://blog.csdn.net/jungle8884" target="_blank">
            
                <svg class="iconfont-svg" aria-hidden="true">
                    <use xlink:href="#icon-csdn"></use>
                </svg>
            
        </a>
        
    
        
        <a title="neteasemusic" href="https://music.163.com/#/user/home?id=88786971" target="_blank">
            
                <svg class="iconfont-svg" aria-hidden="true">
                    <use xlink:href="#icon-neteasemusic"></use>
                </svg>
            
        </a>
        
    
</div>




<ul>
    <li><div class="all active" data-rel="全部文章">全部文章<small>(109)</small></div></li>
    
        
            
            <li><div data-rel="算法"><i class="fold iconfont icon-right"></i>算法<small>(25)</small></div>
                
                    <ul class="sub hide">
                        
                        <li><div data-rel="算法<--->滑动窗口">滑动窗口<small>(1)</small></div>
                            
                        </li>
                            
                        <li><div data-rel="算法<--->基础">基础<small>(1)</small></div>
                            
                        </li>
                            
                        <li><div data-rel="算法<--->链表">链表<small>(8)</small></div>
                            
                        </li>
                            
                        <li><div data-rel="算法<--->面试题">面试题<small>(1)</small></div>
                            
                        </li>
                            
                        <li><div data-rel="算法<--->日期">日期<small>(2)</small></div>
                            
                        </li>
                            
                        <li><div data-rel="算法<--->树">树<small>(4)</small></div>
                            
                        </li>
                            
                        <li><div data-rel="算法<--->数学">数学<small>(1)</small></div>
                            
                        </li>
                            
                        <li><div data-rel="算法<--->数组">数组<small>(1)</small></div>
                            
                        </li>
                            
                        <li><div data-rel="算法<--->双指针">双指针<small>(1)</small></div>
                            
                        </li>
                            
                        <li><div data-rel="算法<--->图">图<small>(2)</small></div>
                            
                        </li>
                            
                        <li><div data-rel="算法<--->LeetCode">LeetCode<small>(1)</small></div>
                            
                        </li>
                            
                    </ul>
                
            </li>
            
        
    
        
            
            <li><div data-rel="DL"><i class="fold iconfont icon-right"></i>DL<small>(3)</small></div>
                
                    <ul class="sub hide">
                        
                        <li><div data-rel="DL<--->Docker">Docker<small>(1)</small></div>
                            
                        </li>
                            
                        <li><div data-rel="DL<--->Python">Python<small>(1)</small></div>
                            
                        </li>
                            
                    </ul>
                
            </li>
            
        
    
        
            
            <li><div data-rel="工具"><i class="fold iconfont icon-right"></i>工具<small>(11)</small></div>
                
                    <ul class="sub hide">
                        
                        <li><div data-rel="工具<--->插件">插件<small>(2)</small></div>
                            
                        </li>
                            
                        <li><div data-rel="工具<--->audio">audio<small>(1)</small></div>
                            
                        </li>
                            
                        <li><div data-rel="工具<--->ChatGPT">ChatGPT<small>(1)</small></div>
                            
                        </li>
                            
                        <li><div data-rel="工具<--->git">git<small>(3)</small></div>
                            
                        </li>
                            
                        <li><div data-rel="工具<--->github">github<small>(1)</small></div>
                            
                        </li>
                            
                    </ul>
                
            </li>
            
        
    
        
            
            <li><div data-rel="后端"><i class="fold iconfont icon-right"></i>后端<small>(27)</small></div>
                
                    <ul class="sub hide">
                        
                        <li><div data-rel="后端<--->设计模式">设计模式<small>(8)</small></div>
                            
                        </li>
                            
                        <li><div data-rel="后端<--->项目"><i class="fold iconfont icon-right"></i>项目<small>(1)</small></div>
                            
                                <ul class="sub hide">
                                    
                                    <li><div data-rel="后端<--->项目SpringBoot">SpringBoot<small>(1)</small></div>
                                    </li>
                                    
                                </ul>
                            
                        </li>
                            
                        <li><div data-rel="后端<--->C#">C#<small>(2)</small></div>
                            
                        </li>
                            
                        <li><div data-rel="后端<--->java">java<small>(1)</small></div>
                            
                        </li>
                            
                        <li><div data-rel="后端<--->Java">Java<small>(14)</small></div>
                            
                        </li>
                            
                    </ul>
                
            </li>
            
        
    
        
            
            <li><div data-rel="数据库"><i class="fold iconfont icon-right"></i>数据库<small>(2)</small></div>
                
                    <ul class="sub hide">
                        
                        <li><div data-rel="数据库<--->MySQL">MySQL<small>(1)</small></div>
                            
                        </li>
                            
                        <li><div data-rel="数据库<--->Redis">Redis<small>(1)</small></div>
                            
                        </li>
                            
                    </ul>
                
            </li>
            
        
    
        
            
            <li><div data-rel="前端">前端<small>(2)</small></div>
                
            </li>
            
        
    
        
            
            <li><div data-rel="运维"><i class="fold iconfont icon-right"></i>运维<small>(2)</small></div>
                
                    <ul class="sub hide">
                        
                        <li><div data-rel="运维<--->Docker">Docker<small>(1)</small></div>
                            
                        </li>
                            
                    </ul>
                
            </li>
            
        
    
        
            
        
    
        
            
        
    
        
            
        
    
        
            
            <li><div data-rel="沉淀一下"><i class="fold iconfont icon-right"></i>沉淀一下<small>(1)</small></div>
                
                    <ul class="sub hide">
                        
                        <li><div data-rel="沉淀一下<--->场景题">场景题<small>(1)</small></div>
                            
                        </li>
                            
                    </ul>
                
            </li>
            
        
    
        
            
        
    
        
            
            <li><div data-rel="读书"><i class="fold iconfont icon-right"></i>读书<small>(4)</small></div>
                
                    <ul class="sub hide">
                        
                        <li><div data-rel="读书<--->单词">单词<small>(1)</small></div>
                            
                        </li>
                            
                        <li><div data-rel="读书<--->软件设计师">软件设计师<small>(1)</small></div>
                            
                        </li>
                            
                        <li><div data-rel="读书<--->英语">英语<small>(1)</small></div>
                            
                        </li>
                            
                    </ul>
                
            </li>
            
        
    
        
            
        
    
        
            
        
    
        
            
        
    
        
            
        
    
        
            
        
    
        
            
        
    
        
            
        
    
        
            
        
    
        
            
        
    
        
            
        
    
        
            
        
    
        
            
        
    
        
            
        
    
        
            
        
    
        
            
        
    
        
            
            <li><div data-rel="物联网"><i class="fold iconfont icon-right"></i>物联网<small>(10)</small></div>
                
                    <ul class="sub hide">
                        
                        <li><div data-rel="物联网<--->乐鑫">乐鑫<small>(2)</small></div>
                            
                        </li>
                            
                        <li><div data-rel="物联网<--->设备端"><i class="fold iconfont icon-right"></i>设备端<small>(5)</small></div>
                            
                                <ul class="sub hide">
                                    
                                    <li><div data-rel="物联网<--->设备端IOT"><i class="fold iconfont icon-right"></i>IOT<small>(3)</small></div>
                                    </li>
                                    
                                </ul>
                            
                        </li>
                            
                        <li><div data-rel="物联网<--->物联网平台"><i class="fold iconfont icon-right"></i>物联网平台<small>(2)</small></div>
                            
                                <ul class="sub hide">
                                    
                                    <li><div data-rel="物联网<--->物联网平台IOT"><i class="fold iconfont icon-right"></i>IOT<small>(1)</small></div>
                                    </li>
                                    
                                </ul>
                            
                        </li>
                            
                    </ul>
                
            </li>
            
        
    
        
            
            <li><div data-rel="物联网平台">物联网平台<small>(3)</small></div>
                
            </li>
            
        
    
        
            
        
    
        
            
        
    
        
            
        
    
        
            
        
    
        
            
        
    
        
            
        
    
        
            
        
    
        
            
        
    
        
            
            <li><div data-rel="docker"><i class="fold iconfont icon-right"></i>docker<small>(6)</small></div>
                
                    <ul class="sub hide">
                        
                        <li><div data-rel="docker<--->项目"><i class="fold iconfont icon-right"></i>项目<small>(2)</small></div>
                            
                                <ul class="sub hide">
                                    
                                    <li><div data-rel="docker<--->项目ruoyi">ruoyi<small>(2)</small></div>
                                    </li>
                                    
                                </ul>
                            
                        </li>
                            
                        <li><div data-rel="docker<--->fastbee">fastbee<small>(1)</small></div>
                            
                        </li>
                            
                    </ul>
                
            </li>
            
        
    
        
            
        
    
        
            
        
    
        
            
        
    
        
            
        
    
        
            
        
    
        
            
        
    
        
            
        
    
        
            
        
    
        
            
            <li><div data-rel="IOT"><i class="fold iconfont icon-right"></i>IOT<small>(3)</small></div>
                
                    <ul class="sub hide">
                        
                        <li><div data-rel="IOT<--->codeblitz">codeblitz<small>(1)</small></div>
                            
                        </li>
                            
                        <li><div data-rel="IOT<--->ESP32">ESP32<small>(2)</small></div>
                            
                        </li>
                            
                    </ul>
                
            </li>
            
        
    
        
            
        
    
        
            
            <li><div data-rel="java"><i class="fold iconfont icon-right"></i>java<small>(1)</small></div>
                
                    <ul class="sub hide">
                        
                        <li><div data-rel="java<--->mq">mq<small>(1)</small></div>
                            
                        </li>
                            
                    </ul>
                
            </li>
            
        
    
        
            
        
    
        
            
        
    
        
            
        
    
        
            
            <li><div data-rel="linux"><i class="fold iconfont icon-right"></i>linux<small>(4)</small></div>
                
                    <ul class="sub hide">
                        
                        <li><div data-rel="linux<--->基本使用">基本使用<small>(1)</small></div>
                            
                        </li>
                            
                        <li><div data-rel="linux<--->shell">shell<small>(1)</small></div>
                            
                        </li>
                            
                        <li><div data-rel="linux<--->wls">wls<small>(1)</small></div>
                            
                        </li>
                            
                    </ul>
                
            </li>
            
        
    
        
            
        
    
        
            
        
    
        
            
            <li><div data-rel="Python">Python<small>(3)</small></div>
                
            </li>
            
        
    
        
            
        
    
        
            
        
    
        
            
        
    
        
            
        
    
        
            
        
    
        
            
        
    
        
            
        
    
        
            
        
    
</ul>
<div class="left-bottom">
    <div class="menus">
    
    
    
    
    </div>
    <div><a class="about  hasFriend  site_url"  href="/about">关于</a><a style="width: 50%"  class="friends">友链</a></div>
</div>
<input type="hidden" id="yelog_site_posts_number" value="109">
<input type="hidden" id="yelog_site_word_count" value="341.1k">
<div style="display: none">
    <span id="busuanzi_value_site_uv"></span>
    <span id="busuanzi_value_site_pv"></span>
</div>

    </div>
    <div class="nav-right">
        <div class="friends-area">
    <div class="friends-title">
        友情链接
        <i class="iconfont icon-left"></i>
    </div>
    <div class="friends-content">
        <ul>
            
            <li><a target="_blank" href="http://yelog.org/">叶落阁</a></li>
            
            <li><a target="_blank" href="https://lavender-z.github.io/">橘子</a></li>
            
            <li><a target="_blank" href="https://youngxhui.top/">ISLAND</a></li>
            
            <li><a target="_blank" href="https://www.liuchuo.net/about">柳神</a></li>
            
            <li><a target="_blank" href="https://programmercarl.com/">K神</a></li>
            
            <li><a target="_blank" href="https://labuladong.github.io/algo/">东哥</a></li>
            
            <li><a target="_blank" href="https://blog.csdn.net/qq_37541097?spm=1001.2014.3001.5509">D神</a></li>
            
            <li><a target="_blank" href="https://blog.csdn.net/qq_33369905?spm=1001.2014.3001.5509">狂神</a></li>
            
        </ul>
    </div>
</div>
        <div class="title-list">
    <div class="right-top">
        <div id="default-panel">
            <i class="iconfont icon-search" data-title="搜索 快捷键 i"></i>
            <div class="right-title">全部文章</div>
            <i class="iconfont icon-file-tree" data-title="切换到大纲视图 快捷键 w"></i>
        </div>
        <div id="search-panel">
            <i class="iconfont icon-left" data-title="返回"></i>
            <input id="local-search-input" />
            <label class="border-line" for="input"></label>
            <i class="iconfont icon-case-sensitive" data-title="大小写敏感"></i>
            <i class="iconfont icon-tag" data-title="标签"></i>
        </div>
        <div id="outline-panel" style="display: none">
            <div class="right-title">大纲</div>
            <i class="iconfont icon-list" data-title="切换到文章列表"></i>
        </div>
    </div>

    <div class="tags-list">
    <input id="tag-search" />
    <div class="tag-wrapper">
        
            <li class="article-tag-list-item">
                <i class="iconfont icon-tag"></i><a>160</a>
            </li>
        
            <li class="article-tag-list-item">
                <i class="iconfont icon-tag"></i><a>19</a>
            </li>
        
            <li class="article-tag-list-item">
                <i class="iconfont icon-tag"></i><a>203</a>
            </li>
        
            <li class="article-tag-list-item">
                <i class="iconfont icon-tag"></i><a>21</a>
            </li>
        
            <li class="article-tag-list-item">
                <i class="iconfont icon-tag"></i><a>23</a>
            </li>
        
            <li class="article-tag-list-item">
                <i class="iconfont icon-tag"></i><a>234</a>
            </li>
        
            <li class="article-tag-list-item">
                <i class="iconfont icon-tag"></i><a>25</a>
            </li>
        
            <li class="article-tag-list-item">
                <i class="iconfont icon-tag"></i><a>51C</a>
            </li>
        
            <li class="article-tag-list-item">
                <i class="iconfont icon-tag"></i><a>92</a>
            </li>
        
            <li class="article-tag-list-item">
                <i class="iconfont icon-tag"></i><a>博客搭建</a>
            </li>
        
            <li class="article-tag-list-item">
                <i class="iconfont icon-tag"></i><a>蔡勒公式</a>
            </li>
        
            <li class="article-tag-list-item">
                <i class="iconfont icon-tag"></i><a>策略模式</a>
            </li>
        
            <li class="article-tag-list-item">
                <i class="iconfont icon-tag"></i><a>查找</a>
            </li>
        
            <li class="article-tag-list-item">
                <i class="iconfont icon-tag"></i><a>抽象工厂模式</a>
            </li>
        
            <li class="article-tag-list-item">
                <i class="iconfont icon-tag"></i><a>创建型模式</a>
            </li>
        
            <li class="article-tag-list-item">
                <i class="iconfont icon-tag"></i><a>代理模式</a>
            </li>
        
            <li class="article-tag-list-item">
                <i class="iconfont icon-tag"></i><a>单例模式</a>
            </li>
        
            <li class="article-tag-list-item">
                <i class="iconfont icon-tag"></i><a>递归</a>
            </li>
        
            <li class="article-tag-list-item">
                <i class="iconfont icon-tag"></i><a>迭代</a>
            </li>
        
            <li class="article-tag-list-item">
                <i class="iconfont icon-tag"></i><a>迭代器</a>
            </li>
        
            <li class="article-tag-list-item">
                <i class="iconfont icon-tag"></i><a>多表查询</a>
            </li>
        
            <li class="article-tag-list-item">
                <i class="iconfont icon-tag"></i><a>多态</a>
            </li>
        
            <li class="article-tag-list-item">
                <i class="iconfont icon-tag"></i><a>多线程</a>
            </li>
        
            <li class="article-tag-list-item">
                <i class="iconfont icon-tag"></i><a>二叉树</a>
            </li>
        
            <li class="article-tag-list-item">
                <i class="iconfont icon-tag"></i><a>分布式数据库系统及原理</a>
            </li>
        
            <li class="article-tag-list-item">
                <i class="iconfont icon-tag"></i><a>工厂方法模式</a>
            </li>
        
            <li class="article-tag-list-item">
                <i class="iconfont icon-tag"></i><a>构建型模式</a>
            </li>
        
            <li class="article-tag-list-item">
                <i class="iconfont icon-tag"></i><a>观察者模式</a>
            </li>
        
            <li class="article-tag-list-item">
                <i class="iconfont icon-tag"></i><a>滑动窗口</a>
            </li>
        
            <li class="article-tag-list-item">
                <i class="iconfont icon-tag"></i><a>机器学习</a>
            </li>
        
            <li class="article-tag-list-item">
                <i class="iconfont icon-tag"></i><a>集合</a>
            </li>
        
            <li class="article-tag-list-item">
                <i class="iconfont icon-tag"></i><a>计算机专业英语</a>
            </li>
        
            <li class="article-tag-list-item">
                <i class="iconfont icon-tag"></i><a>简单工厂模式</a>
            </li>
        
            <li class="article-tag-list-item">
                <i class="iconfont icon-tag"></i><a>建造者模式</a>
            </li>
        
            <li class="article-tag-list-item">
                <i class="iconfont icon-tag"></i><a>结构型模式</a>
            </li>
        
            <li class="article-tag-list-item">
                <i class="iconfont icon-tag"></i><a>进制转换</a>
            </li>
        
            <li class="article-tag-list-item">
                <i class="iconfont icon-tag"></i><a>镜像</a>
            </li>
        
            <li class="article-tag-list-item">
                <i class="iconfont icon-tag"></i><a>开发</a>
            </li>
        
            <li class="article-tag-list-item">
                <i class="iconfont icon-tag"></i><a>开发框架</a>
            </li>
        
            <li class="article-tag-list-item">
                <i class="iconfont icon-tag"></i><a>快速平方根</a>
            </li>
        
            <li class="article-tag-list-item">
                <i class="iconfont icon-tag"></i><a>乐鑫</a>
            </li>
        
            <li class="article-tag-list-item">
                <i class="iconfont icon-tag"></i><a>链表</a>
            </li>
        
            <li class="article-tag-list-item">
                <i class="iconfont icon-tag"></i><a>六大原则</a>
            </li>
        
            <li class="article-tag-list-item">
                <i class="iconfont icon-tag"></i><a>六级</a>
            </li>
        
            <li class="article-tag-list-item">
                <i class="iconfont icon-tag"></i><a>爬虫</a>
            </li>
        
            <li class="article-tag-list-item">
                <i class="iconfont icon-tag"></i><a>排序</a>
            </li>
        
            <li class="article-tag-list-item">
                <i class="iconfont icon-tag"></i><a>前端</a>
            </li>
        
            <li class="article-tag-list-item">
                <i class="iconfont icon-tag"></i><a>前缀树</a>
            </li>
        
            <li class="article-tag-list-item">
                <i class="iconfont icon-tag"></i><a>容器</a>
            </li>
        
            <li class="article-tag-list-item">
                <i class="iconfont icon-tag"></i><a>闰年</a>
            </li>
        
            <li class="article-tag-list-item">
                <i class="iconfont icon-tag"></i><a>社会的本质</a>
            </li>
        
            <li class="article-tag-list-item">
                <i class="iconfont icon-tag"></i><a>深度学习</a>
            </li>
        
            <li class="article-tag-list-item">
                <i class="iconfont icon-tag"></i><a>事务</a>
            </li>
        
            <li class="article-tag-list-item">
                <i class="iconfont icon-tag"></i><a>数据库的备份和还原</a>
            </li>
        
            <li class="article-tag-list-item">
                <i class="iconfont icon-tag"></i><a>数据库的设计</a>
            </li>
        
            <li class="article-tag-list-item">
                <i class="iconfont icon-tag"></i><a>数组</a>
            </li>
        
            <li class="article-tag-list-item">
                <i class="iconfont icon-tag"></i><a>双指针</a>
            </li>
        
            <li class="article-tag-list-item">
                <i class="iconfont icon-tag"></i><a>贪心</a>
            </li>
        
            <li class="article-tag-list-item">
                <i class="iconfont icon-tag"></i><a>图</a>
            </li>
        
            <li class="article-tag-list-item">
                <i class="iconfont icon-tag"></i><a>委托与事件</a>
            </li>
        
            <li class="article-tag-list-item">
                <i class="iconfont icon-tag"></i><a>写作</a>
            </li>
        
            <li class="article-tag-list-item">
                <i class="iconfont icon-tag"></i><a>行为型模式</a>
            </li>
        
            <li class="article-tag-list-item">
                <i class="iconfont icon-tag"></i><a>移除链表元素</a>
            </li>
        
            <li class="article-tag-list-item">
                <i class="iconfont icon-tag"></i><a>优先队列</a>
            </li>
        
            <li class="article-tag-list-item">
                <i class="iconfont icon-tag"></i><a>油猴</a>
            </li>
        
            <li class="article-tag-list-item">
                <i class="iconfont icon-tag"></i><a>原码, 反码, 补码, 移码</a>
            </li>
        
            <li class="article-tag-list-item">
                <i class="iconfont icon-tag"></i><a>原型模式</a>
            </li>
        
            <li class="article-tag-list-item">
                <i class="iconfont icon-tag"></i><a>约束</a>
            </li>
        
            <li class="article-tag-list-item">
                <i class="iconfont icon-tag"></i><a>Ado.net</a>
            </li>
        
            <li class="article-tag-list-item">
                <i class="iconfont icon-tag"></i><a>ArrayList</a>
            </li>
        
            <li class="article-tag-list-item">
                <i class="iconfont icon-tag"></i><a>AT</a>
            </li>
        
            <li class="article-tag-list-item">
                <i class="iconfont icon-tag"></i><a>audio</a>
            </li>
        
            <li class="article-tag-list-item">
                <i class="iconfont icon-tag"></i><a>C</a>
            </li>
        
            <li class="article-tag-list-item">
                <i class="iconfont icon-tag"></i><a>C#</a>
            </li>
        
            <li class="article-tag-list-item">
                <i class="iconfont icon-tag"></i><a>ChatGPT</a>
            </li>
        
            <li class="article-tag-list-item">
                <i class="iconfont icon-tag"></i><a>codeblitz</a>
            </li>
        
            <li class="article-tag-list-item">
                <i class="iconfont icon-tag"></i><a>device</a>
            </li>
        
            <li class="article-tag-list-item">
                <i class="iconfont icon-tag"></i><a>DL</a>
            </li>
        
            <li class="article-tag-list-item">
                <i class="iconfont icon-tag"></i><a>docker</a>
            </li>
        
            <li class="article-tag-list-item">
                <i class="iconfont icon-tag"></i><a>Docker</a>
            </li>
        
            <li class="article-tag-list-item">
                <i class="iconfont icon-tag"></i><a>docker-desktop</a>
            </li>
        
            <li class="article-tag-list-item">
                <i class="iconfont icon-tag"></i><a>ESP Rainmaker</a>
            </li>
        
            <li class="article-tag-list-item">
                <i class="iconfont icon-tag"></i><a>esp-idf</a>
            </li>
        
            <li class="article-tag-list-item">
                <i class="iconfont icon-tag"></i><a>ESP32</a>
            </li>
        
            <li class="article-tag-list-item">
                <i class="iconfont icon-tag"></i><a>ESP32C3</a>
            </li>
        
            <li class="article-tag-list-item">
                <i class="iconfont icon-tag"></i><a>fastapi</a>
            </li>
        
            <li class="article-tag-list-item">
                <i class="iconfont icon-tag"></i><a>fastbee</a>
            </li>
        
            <li class="article-tag-list-item">
                <i class="iconfont icon-tag"></i><a>Fastbee</a>
            </li>
        
            <li class="article-tag-list-item">
                <i class="iconfont icon-tag"></i><a>FleetBee</a>
            </li>
        
            <li class="article-tag-list-item">
                <i class="iconfont icon-tag"></i><a>git</a>
            </li>
        
            <li class="article-tag-list-item">
                <i class="iconfont icon-tag"></i><a>github</a>
            </li>
        
            <li class="article-tag-list-item">
                <i class="iconfont icon-tag"></i><a>http</a>
            </li>
        
            <li class="article-tag-list-item">
                <i class="iconfont icon-tag"></i><a>hutool</a>
            </li>
        
            <li class="article-tag-list-item">
                <i class="iconfont icon-tag"></i><a>IO</a>
            </li>
        
            <li class="article-tag-list-item">
                <i class="iconfont icon-tag"></i><a>iot</a>
            </li>
        
            <li class="article-tag-list-item">
                <i class="iconfont icon-tag"></i><a>IOT</a>
            </li>
        
            <li class="article-tag-list-item">
                <i class="iconfont icon-tag"></i><a>Java</a>
            </li>
        
            <li class="article-tag-list-item">
                <i class="iconfont icon-tag"></i><a>JavaScript</a>
            </li>
        
            <li class="article-tag-list-item">
                <i class="iconfont icon-tag"></i><a>Job</a>
            </li>
        
            <li class="article-tag-list-item">
                <i class="iconfont icon-tag"></i><a>jwt</a>
            </li>
        
            <li class="article-tag-list-item">
                <i class="iconfont icon-tag"></i><a>k3s</a>
            </li>
        
            <li class="article-tag-list-item">
                <i class="iconfont icon-tag"></i><a>LeetCode</a>
            </li>
        
            <li class="article-tag-list-item">
                <i class="iconfont icon-tag"></i><a>LinkedList</a>
            </li>
        
            <li class="article-tag-list-item">
                <i class="iconfont icon-tag"></i><a>linux</a>
            </li>
        
            <li class="article-tag-list-item">
                <i class="iconfont icon-tag"></i><a>Linux</a>
            </li>
        
            <li class="article-tag-list-item">
                <i class="iconfont icon-tag"></i><a>List</a>
            </li>
        
            <li class="article-tag-list-item">
                <i class="iconfont icon-tag"></i><a>mall</a>
            </li>
        
            <li class="article-tag-list-item">
                <i class="iconfont icon-tag"></i><a>Map</a>
            </li>
        
            <li class="article-tag-list-item">
                <i class="iconfont icon-tag"></i><a>mqtt上传文件</a>
            </li>
        
            <li class="article-tag-list-item">
                <i class="iconfont icon-tag"></i><a>N叉树</a>
            </li>
        
            <li class="article-tag-list-item">
                <i class="iconfont icon-tag"></i><a>N的阶乘</a>
            </li>
        
            <li class="article-tag-list-item">
                <i class="iconfont icon-tag"></i><a>NoSQL</a>
            </li>
        
            <li class="article-tag-list-item">
                <i class="iconfont icon-tag"></i><a>OJ</a>
            </li>
        
            <li class="article-tag-list-item">
                <i class="iconfont icon-tag"></i><a>pyside</a>
            </li>
        
            <li class="article-tag-list-item">
                <i class="iconfont icon-tag"></i><a>python</a>
            </li>
        
            <li class="article-tag-list-item">
                <i class="iconfont icon-tag"></i><a>Python</a>
            </li>
        
            <li class="article-tag-list-item">
                <i class="iconfont icon-tag"></i><a>rabbitmq</a>
            </li>
        
            <li class="article-tag-list-item">
                <i class="iconfont icon-tag"></i><a>Resnet</a>
            </li>
        
            <li class="article-tag-list-item">
                <i class="iconfont icon-tag"></i><a>Set</a>
            </li>
        
            <li class="article-tag-list-item">
                <i class="iconfont icon-tag"></i><a>shadowsocks</a>
            </li>
        
            <li class="article-tag-list-item">
                <i class="iconfont icon-tag"></i><a>shell</a>
            </li>
        
            <li class="article-tag-list-item">
                <i class="iconfont icon-tag"></i><a>Shell</a>
            </li>
        
            <li class="article-tag-list-item">
                <i class="iconfont icon-tag"></i><a>SpringBoot</a>
            </li>
        
            <li class="article-tag-list-item">
                <i class="iconfont icon-tag"></i><a>SQL</a>
            </li>
        
            <li class="article-tag-list-item">
                <i class="iconfont icon-tag"></i><a>STM32</a>
            </li>
        
            <li class="article-tag-list-item">
                <i class="iconfont icon-tag"></i><a>Stream</a>
            </li>
        
            <li class="article-tag-list-item">
                <i class="iconfont icon-tag"></i><a>swagger</a>
            </li>
        
            <li class="article-tag-list-item">
                <i class="iconfont icon-tag"></i><a>tkinter</a>
            </li>
        
            <li class="article-tag-list-item">
                <i class="iconfont icon-tag"></i><a>Utils</a>
            </li>
        
            <li class="article-tag-list-item">
                <i class="iconfont icon-tag"></i><a>Vector</a>
            </li>
        
            <li class="article-tag-list-item">
                <i class="iconfont icon-tag"></i><a>video</a>
            </li>
        
            <li class="article-tag-list-item">
                <i class="iconfont icon-tag"></i><a>Vue</a>
            </li>
        
            <li class="article-tag-list-item">
                <i class="iconfont icon-tag"></i><a>WebGIS</a>
            </li>
        
            <li class="article-tag-list-item">
                <i class="iconfont icon-tag"></i><a>work</a>
            </li>
        
            <li class="article-tag-list-item">
                <i class="iconfont icon-tag"></i><a>wumei</a>
            </li>
        
    </div>

</div>

    
    <nav id="title-list-nav">
        
        <a id="top" class="全部文章 读书 单词 "
           href="/2020/11/24/WordofCS/"
           data-tag="机器学习,深度学习,计算机专业英语,分布式数据库系统及原理"
           data-author="" >
            <span class="post-title" title="WordofCS">WordofCS</span>
            <span class="post-date" title="2020-11-24 17:21:02">2020/11/24</span>
        </a>
        
        <a id="top" class="全部文章 读书 英语 "
           href="/2020/09/18/CET-6-Writing/"
           data-tag="六级,写作"
           data-author="" >
            <span class="post-title" title="六级写作">六级写作</span>
            <span class="post-date" title="2020-09-18 10:21:32">2020/09/18</span>
        </a>
        
        <a  class="全部文章 前端 "
           href="/2026/01/19/vue-learning/"
           data-tag="Vue"
           data-author="" >
            <span class="post-title" title="Vue">Vue</span>
            <span class="post-date" title="2026-01-19 16:47:07">2026/01/19</span>
        </a>
        
        <a  class="全部文章 后端 设计模式 "
           href="/2025/12/04/DesignPatternofSixPrinciples/"
           data-tag="六大原则"
           data-author="" >
            <span class="post-title" title="六大设计原则">六大设计原则</span>
            <span class="post-date" title="2025-12-04 10:49:33">2025/12/04</span>
        </a>
        
        <a  class="全部文章 "
           href="/2025/12/04/hello-world/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="Hello World">Hello World</span>
            <span class="post-date" title="2025-12-04 09:09:30">2025/12/04</span>
        </a>
        
        <a  class="全部文章 沉淀一下 场景题 "
           href="/2025/11/06/goodjob/"
           data-tag="work"
           data-author="" >
            <span class="post-title" title="goodjob">goodjob</span>
            <span class="post-date" title="2025-11-06 23:23:29">2025/11/06</span>
        </a>
        
        <a  class="全部文章 java mq "
           href="/2025/10/28/java-rabbitmq/"
           data-tag="rabbitmq"
           data-author="" >
            <span class="post-title" title="java_rabbitmq">java_rabbitmq</span>
            <span class="post-date" title="2025-10-28 17:12:04">2025/10/28</span>
        </a>
        
        <a  class="全部文章 后端 java "
           href="/2025/10/23/java-security/"
           data-tag="jwt"
           data-author="" >
            <span class="post-title" title="java_security">java_security</span>
            <span class="post-date" title="2025-10-23 17:40:33">2025/10/23</span>
        </a>
        
        <a  class="全部文章 后端 Java "
           href="/2025/10/23/java-swagger/"
           data-tag="swagger"
           data-author="" >
            <span class="post-title" title="java_swagger">java_swagger</span>
            <span class="post-date" title="2025-10-23 17:16:02">2025/10/23</span>
        </a>
        
        <a  class="全部文章 后端 Java "
           href="/2025/10/23/java-hutool/"
           data-tag="hutool"
           data-author="" >
            <span class="post-title" title="java_hutool">java_hutool</span>
            <span class="post-date" title="2025-10-23 16:34:49">2025/10/23</span>
        </a>
        
        <a  class="全部文章 后端 Java "
           href="/2025/10/21/mall/"
           data-tag="mall"
           data-author="" >
            <span class="post-title" title="mall">mall</span>
            <span class="post-date" title="2025-10-21 22:02:56">2025/10/21</span>
        </a>
        
        <a  class="全部文章 docker "
           href="/2025/10/11/docker-destop/"
           data-tag="docker-desktop"
           data-author="" >
            <span class="post-title" title="docker_destop">docker_destop</span>
            <span class="post-date" title="2025-10-11 09:52:56">2025/10/11</span>
        </a>
        
        <a  class="全部文章 后端 "
           href="/2025/10/10/java-mark/"
           data-tag="Java"
           data-author="" >
            <span class="post-title" title="java要点小结">java要点小结</span>
            <span class="post-date" title="2025-10-10 17:28:57">2025/10/10</span>
        </a>
        
        <a  class="全部文章 Python "
           href="/2025/09/29/pysideRecord/"
           data-tag="pyside"
           data-author="" >
            <span class="post-title" title="pysideRecord">pysideRecord</span>
            <span class="post-date" title="2025-09-29 20:46:51">2025/09/29</span>
        </a>
        
        <a  class="全部文章 docker fastbee "
           href="/2025/09/19/dockerDeploy/"
           data-tag="iot"
           data-author="" >
            <span class="post-title" title="fastbee项目部署">fastbee项目部署</span>
            <span class="post-date" title="2025-09-19 10:22:51">2025/09/19</span>
        </a>
        
        <a  class="全部文章 Python "
           href="/2025/09/18/fastapiLearning/"
           data-tag="fastapi"
           data-author="" >
            <span class="post-title" title="fastapiNote">fastapiNote</span>
            <span class="post-date" title="2025-09-18 15:42:57">2025/09/18</span>
        </a>
        
        <a  class="全部文章 linux "
           href="/2025/07/21/Ubuntu/"
           data-tag="shell"
           data-author="" >
            <span class="post-title" title="Linux">Linux</span>
            <span class="post-date" title="2025-07-21 09:57:43">2025/07/21</span>
        </a>
        
        <a  class="全部文章 物联网 "
           href="/2025/03/06/esp32-ubuntun-start/"
           data-tag="乐鑫"
           data-author="" >
            <span class="post-title" title="esp32_ubuntun_start">esp32_ubuntun_start</span>
            <span class="post-date" title="2025-03-06 15:02:56">2025/03/06</span>
        </a>
        
        <a  class="全部文章 "
           href="/2025/01/18/vim-use/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="vim-use">vim-use</span>
            <span class="post-date" title="2025-01-18 09:35:04">2025/01/18</span>
        </a>
        
        <a  class="全部文章 linux shell "
           href="/2025/01/15/shell-programming/"
           data-tag="linux"
           data-author="" >
            <span class="post-title" title="shell_programming">shell_programming</span>
            <span class="post-date" title="2025-01-15 15:40:40">2025/01/15</span>
        </a>
        
        <a  class="全部文章 物联网 乐鑫 "
           href="/2024/12/30/esp-idf-record/"
           data-tag="esp-idf"
           data-author="" >
            <span class="post-title" title="esp-idf-record">esp-idf-record</span>
            <span class="post-date" title="2024-12-30 10:46:49">2024/12/30</span>
        </a>
        
        <a  class="全部文章 物联网 乐鑫 "
           href="/2024/12/27/esp-idf-cmd/"
           data-tag="esp-idf"
           data-author="" >
            <span class="post-title" title="esp-idf-cmd">esp-idf-cmd</span>
            <span class="post-date" title="2024-12-27 16:41:01">2024/12/27</span>
        </a>
        
        <a  class="全部文章 Python "
           href="/2024/09/06/pyGUI/"
           data-tag="tkinter"
           data-author="" >
            <span class="post-title" title="tkinterecord">tkinterecord</span>
            <span class="post-date" title="2024-09-06 14:41:16">2024/09/06</span>
        </a>
        
        <a  class="全部文章 物联网 设备端 "
           href="/2024/08/26/basic-Arduino/"
           data-tag="C"
           data-author="" >
            <span class="post-title" title="basic_Arduino">basic_Arduino</span>
            <span class="post-date" title="2024-08-26 17:47:27">2024/08/26</span>
        </a>
        
        <a  class="全部文章 物联网 物联网平台 "
           href="/2024/08/13/mqtt/"
           data-tag="mqtt上传文件"
           data-author="" >
            <span class="post-title" title="MQTT">MQTT</span>
            <span class="post-date" title="2024-08-13 15:45:34">2024/08/13</span>
        </a>
        
        <a  class="全部文章 物联网 设备端 "
           href="/2024/06/07/IntelligenLEDStrip/"
           data-tag="ESP Rainmaker"
           data-author="" >
            <span class="post-title" title="智能灯带">智能灯带</span>
            <span class="post-date" title="2024-06-07 10:15:00">2024/06/07</span>
        </a>
        
        <a  class="全部文章 linux wls "
           href="/2024/05/28/linux-note/"
           data-tag="linux"
           data-author="" >
            <span class="post-title" title="linux_note">linux_note</span>
            <span class="post-date" title="2024-05-28 09:22:34">2024/05/28</span>
        </a>
        
        <a  class="全部文章 docker "
           href="/2024/05/14/k3s%E9%83%A8%E7%BD%B2%E6%96%87%E6%A1%A3/"
           data-tag="k3s"
           data-author="" >
            <span class="post-title" title="k3s">k3s</span>
            <span class="post-date" title="2024-05-14 16:36:52">2024/05/14</span>
        </a>
        
        <a  class="全部文章 docker "
           href="/2024/05/14/local_deploy/"
           data-tag="fastbee"
           data-author="" >
            <span class="post-title" title="物联网平台本地部署并接入摄像头">物联网平台本地部署并接入摄像头</span>
            <span class="post-date" title="2024-05-14 16:31:52">2024/05/14</span>
        </a>
        
        <a  class="全部文章 物联网平台 "
           href="/2024/04/12/CameraAccess/"
           data-tag="FleetBee"
           data-author="" >
            <span class="post-title" title="摄像头接入">摄像头接入</span>
            <span class="post-date" title="2024-04-12 16:48:52">2024/04/12</span>
        </a>
        
        <a  class="全部文章 linux 基本使用 "
           href="/2024/03/31/linux%E7%9A%84%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8/"
           data-tag="linux"
           data-author="" >
            <span class="post-title" title="linux的基本使用">linux的基本使用</span>
            <span class="post-date" title="2024-03-31 17:40:34">2024/03/31</span>
        </a>
        
        <a  class="全部文章 docker 项目 ruoyi "
           href="/2024/01/09/ruoyi_2Dev/"
           data-tag="开发框架"
           data-author="" >
            <span class="post-title" title="ruoyi-二次开发">ruoyi-二次开发</span>
            <span class="post-date" title="2024-01-09 11:20:00">2024/01/09</span>
        </a>
        
        <a  class="全部文章 docker 项目 ruoyi "
           href="/2024/01/06/ruoyi/"
           data-tag="开发框架"
           data-author="" >
            <span class="post-title" title="ruoyi">ruoyi</span>
            <span class="post-date" title="2024-01-06 15:20:00">2024/01/06</span>
        </a>
        
        <a  class="全部文章 后端 项目 SpringBoot "
           href="/2024/01/05/SpringBoor_Vue/"
           data-tag="SpringBoot,Vue"
           data-author="" >
            <span class="post-title" title="SpringBoot_Vue">SpringBoot_Vue</span>
            <span class="post-date" title="2024-01-05 11:20:01">2024/01/05</span>
        </a>
        
        <a  class="全部文章 物联网 物联网平台 IOT wumei "
           href="/2023/12/27/wumei_DeepIn/"
           data-tag="device"
           data-author="" >
            <span class="post-title" title="wumei-deviceDeepIn">wumei-deviceDeepIn</span>
            <span class="post-date" title="2023-12-27 10:23:00">2023/12/27</span>
        </a>
        
        <a  class="全部文章 物联网平台 "
           href="/2023/12/26/wumei_deviceInto/"
           data-tag="device"
           data-author="" >
            <span class="post-title" title="wumei-deviceInto">wumei-deviceInto</span>
            <span class="post-date" title="2023-12-26 11:20:00">2023/12/26</span>
        </a>
        
        <a  class="全部文章 物联网 设备端 IOT ESP32C3 "
           href="/2023/12/12/ESP32-C3/"
           data-tag="ESP32C3"
           data-author="" >
            <span class="post-title" title="ESP32C3">ESP32C3</span>
            <span class="post-date" title="2023-12-12 15:43:52">2023/12/12</span>
        </a>
        
        <a  class="全部文章 物联网平台 "
           href="/2023/12/11/wumei/"
           data-tag="Fastbee,IOT,wumei"
           data-author="" >
            <span class="post-title" title="wumei">wumei</span>
            <span class="post-date" title="2023-12-11 09:48:52">2023/12/11</span>
        </a>
        
        <a  class="全部文章 IOT ESP32 "
           href="/2023/11/08/ESP32/"
           data-tag="ESP32"
           data-author="" >
            <span class="post-title" title="ESP32">ESP32</span>
            <span class="post-date" title="2023-11-08 18:02:31">2023/11/08</span>
        </a>
        
        <a  class="全部文章 算法 数学 "
           href="/2023/11/01/Q-rsqrt/"
           data-tag="快速平方根"
           data-author="" >
            <span class="post-title" title="Q_rsqrt">Q_rsqrt</span>
            <span class="post-date" title="2023-11-01 08:52:08">2023/11/01</span>
        </a>
        
        <a  class="全部文章 工具 audio "
           href="/2023/10/16/audioConvert/"
           data-tag="python,audio"
           data-author="" >
            <span class="post-title" title="audioConvert">audioConvert</span>
            <span class="post-date" title="2023-10-16 19:34:43">2023/10/16</span>
        </a>
        
        <a  class="全部文章 物联网 设备端 IOT STM32 "
           href="/2023/10/14/STM32/"
           data-tag="STM32"
           data-author="" >
            <span class="post-title" title="STM32">STM32</span>
            <span class="post-date" title="2023-10-14 08:59:19">2023/10/14</span>
        </a>
        
        <a  class="全部文章 物联网 设备端 IOT 51C "
           href="/2023/10/08/51C/"
           data-tag="51C"
           data-author="" >
            <span class="post-title" title="51C">51C</span>
            <span class="post-date" title="2023-10-08 17:20:10">2023/10/08</span>
        </a>
        
        <a  class="全部文章 IOT codeblitz "
           href="/2023/09/28/IOT/"
           data-tag="codeblitz"
           data-author="" >
            <span class="post-title" title="codeblitz">codeblitz</span>
            <span class="post-date" title="2023-09-28 08:48:52">2023/09/28</span>
        </a>
        
        <a  class="全部文章 算法 面试题 "
           href="/2023/09/18/JobInterview/"
           data-tag="N的阶乘"
           data-author="" >
            <span class="post-title" title="JobInterview">JobInterview</span>
            <span class="post-date" title="2023-09-18 21:55:19">2023/09/18</span>
        </a>
        
        <a  class="全部文章 算法 LeetCode "
           href="/2023/09/13/hot100/"
           data-tag="LeetCode"
           data-author="" >
            <span class="post-title" title="hot100">hot100</span>
            <span class="post-date" title="2023-09-13 10:17:00">2023/09/13</span>
        </a>
        
        <a  class="全部文章 后端 Java "
           href="/2023/09/05/4Job/"
           data-tag="Job,WebGIS,Shell"
           data-author="" >
            <span class="post-title" title="Javaer&#39;s development">Javaer&#39;s development</span>
            <span class="post-date" title="2023-09-05 00:00:00">2023/09/05</span>
        </a>
        
        <a  class="全部文章 后端 Java "
           href="/2023/03/24/Stream/"
           data-tag="Stream"
           data-author="" >
            <span class="post-title" title="Stream">Stream</span>
            <span class="post-date" title="2023-03-24 09:42:49">2023/03/24</span>
        </a>
        
        <a  class="全部文章 IOT ESP32 "
           href="/2023/03/08/ESP32ATLog/"
           data-tag="ESP32,AT"
           data-author="" >
            <span class="post-title" title="ESP32AT指令集探索">ESP32AT指令集探索</span>
            <span class="post-date" title="2023-03-08 14:52:56">2023/03/08</span>
        </a>
        
        <a  class="全部文章 工具 插件 "
           href="/2023/02/09/AddOn4SpeedPlay/"
           data-tag="video"
           data-author="" >
            <span class="post-title" title="AddOn4SpeedPlay">AddOn4SpeedPlay</span>
            <span class="post-date" title="2023-02-09 13:05:26">2023/02/09</span>
        </a>
        
        <a  class="全部文章 工具 ChatGPT "
           href="/2023/02/09/ChatGPT/"
           data-tag="ChatGPT"
           data-author="" >
            <span class="post-title" title="Usage of ChatGPT">Usage of ChatGPT</span>
            <span class="post-date" title="2023-02-09 12:34:54">2023/02/09</span>
        </a>
        
        <a  class="全部文章 后端 Java "
           href="/2023/02/09/Java-io/"
           data-tag="IO"
           data-author="" >
            <span class="post-title" title="Java-io">Java-io</span>
            <span class="post-date" title="2023-02-09 12:27:55">2023/02/09</span>
        </a>
        
        <a  class="全部文章 工具 插件 "
           href="/2023/01/17/Freedom/"
           data-tag="油猴"
           data-author="" >
            <span class="post-title" title="Videos">Videos</span>
            <span class="post-date" title="2023-01-17 21:43:30">2023/01/17</span>
        </a>
        
        <a  class="全部文章 后端 Java "
           href="/2022/12/04/DevConcludes/"
           data-tag="开发"
           data-author="" >
            <span class="post-title" title="DevConcludes">DevConcludes</span>
            <span class="post-date" title="2022-12-04 22:16:46">2022/12/04</span>
        </a>
        
        <a  class="全部文章 后端 Java "
           href="/2022/10/16/Java-Utils/"
           data-tag="Utils"
           data-author="" >
            <span class="post-title" title="Java-Utils">Java-Utils</span>
            <span class="post-date" title="2022-10-16 16:15:29">2022/10/16</span>
        </a>
        
        <a  class="全部文章 算法 数组 "
           href="/2022/05/02/Array/"
           data-tag="数组"
           data-author="" >
            <span class="post-title" title="数组">数组</span>
            <span class="post-date" title="2022-05-02 00:00:00">2022/05/02</span>
        </a>
        
        <a  class="全部文章 读书 "
           href="/2022/03/12/natureOfSociety/"
           data-tag="社会的本质"
           data-author="" >
            <span class="post-title" title="natureOfSociety">natureOfSociety</span>
            <span class="post-date" title="2022-03-12 18:39:19">2022/03/12</span>
        </a>
        
        <a  class="全部文章 算法 图 "
           href="/2022/01/23/TopologicalSorting/"
           data-tag="图"
           data-author="" >
            <span class="post-title" title="拓扑排序">拓扑排序</span>
            <span class="post-date" title="2022-01-23 00:00:00">2022/01/23</span>
        </a>
        
        <a  class="全部文章 算法 图 "
           href="/2021/12/31/Graph-DataStructure/"
           data-tag="图"
           data-author="" >
            <span class="post-title" title="图的数据结构">图的数据结构</span>
            <span class="post-date" title="2021-12-31 10:41:29">2021/12/31</span>
        </a>
        
        <a  class="全部文章 算法 树 "
           href="/2021/12/13/BinaryTree-traverse/"
           data-tag="二叉树"
           data-author="" >
            <span class="post-title" title="二叉树的遍历框架">二叉树的遍历框架</span>
            <span class="post-date" title="2021-12-13 10:50:34">2021/12/13</span>
        </a>
        
        <a  class="全部文章 算法 "
           href="/2021/12/08/Trie-341-NestedIterator/"
           data-tag="前缀树,N叉树,迭代器"
           data-author="" >
            <span class="post-title" title="扁平化嵌套列表迭代器">扁平化嵌套列表迭代器</span>
            <span class="post-date" title="2021-12-08 16:38:11">2021/12/08</span>
        </a>
        
        <a  class="全部文章 算法 树 "
           href="/2021/11/26/BinaryTree-297-SerializeAndDeserialize/"
           data-tag="二叉树"
           data-author="" >
            <span class="post-title" title="二叉树的序列化和反序列化">二叉树的序列化和反序列化</span>
            <span class="post-date" title="2021-11-26 17:32:54">2021/11/26</span>
        </a>
        
        <a  class="全部文章 算法 链表 "
           href="/2021/11/19/LinkedList-160-getIntersectionNode/"
           data-tag="160,链表"
           data-author="" >
            <span class="post-title" title="两个链表是否相交">两个链表是否相交</span>
            <span class="post-date" title="2021-11-19 00:00:00">2021/11/19</span>
        </a>
        
        <a  class="全部文章 算法 链表 "
           href="/2021/11/19/LinkedList-19-removeNthFromEnd/"
           data-tag="链表,19"
           data-author="" >
            <span class="post-title" title="单链表的倒数第K个节点">单链表的倒数第K个节点</span>
            <span class="post-date" title="2021-11-19 00:00:00">2021/11/19</span>
        </a>
        
        <a  class="全部文章 算法 链表 "
           href="/2021/11/19/LinkedList-23-mergeKLists/"
           data-tag="链表,23"
           data-author="" >
            <span class="post-title" title="合并K个有序链表">合并K个有序链表</span>
            <span class="post-date" title="2021-11-19 00:00:00">2021/11/19</span>
        </a>
        
        <a  class="全部文章 算法 链表 "
           href="/2021/11/19/LinkedList-234-isPalindrome/"
           data-tag="链表,234"
           data-author="" >
            <span class="post-title" title="回文链表">回文链表</span>
            <span class="post-date" title="2021-11-19 00:00:00">2021/11/19</span>
        </a>
        
        <a  class="全部文章 算法 链表 "
           href="/2021/11/19/LinkedList-25-reverseKGroup/"
           data-tag="链表,25,迭代"
           data-author="" >
            <span class="post-title" title="K个一组反转链表">K个一组反转链表</span>
            <span class="post-date" title="2021-11-19 00:00:00">2021/11/19</span>
        </a>
        
        <a  class="全部文章 算法 链表 "
           href="/2021/11/19/LinkedList-92-reverseBetween/"
           data-tag="链表,92,递归"
           data-author="" >
            <span class="post-title" title="反转链表">反转链表</span>
            <span class="post-date" title="2021-11-19 00:00:00">2021/11/19</span>
        </a>
        
        <a  class="全部文章 算法 链表 "
           href="/2021/11/18/LinkedList-21-mergeTwoLists/"
           data-tag="链表,21"
           data-author="" >
            <span class="post-title" title="合并两个有序链表">合并两个有序链表</span>
            <span class="post-date" title="2021-11-18 00:00:00">2021/11/18</span>
        </a>
        
        <a  class="全部文章 算法 日期 "
           href="/2021/09/16/Calculate-date/"
           data-tag="闰年"
           data-author="" >
            <span class="post-title" title="Calculate_date">Calculate_date</span>
            <span class="post-date" title="2021-09-16 21:05:01">2021/09/16</span>
        </a>
        
        <a  class="全部文章 后端 设计模式 "
           href="/2021/09/15/DesignPatterofStrategy/"
           data-tag="行为型模式,策略模式"
           data-author="" >
            <span class="post-title" title="策略模式">策略模式</span>
            <span class="post-date" title="2021-09-15 20:58:14">2021/09/15</span>
        </a>
        
        <a  class="全部文章 后端 设计模式 "
           href="/2021/09/15/DesignPatternofObserver/"
           data-tag="观察者模式,行为型模式"
           data-author="" >
            <span class="post-title" title="观察者模式">观察者模式</span>
            <span class="post-date" title="2021-09-15 20:41:49">2021/09/15</span>
        </a>
        
        <a  class="全部文章 后端 设计模式 "
           href="/2021/09/15/DesignPatternofProxy/"
           data-tag="代理模式,结构型模式"
           data-author="" >
            <span class="post-title" title="代理模式">代理模式</span>
            <span class="post-date" title="2021-09-15 20:30:32">2021/09/15</span>
        </a>
        
        <a  class="全部文章 算法 "
           href="/2021/09/07/PriorityQueue/"
           data-tag="优先队列,贪心"
           data-author="" >
            <span class="post-title" title="PriorityQueue">PriorityQueue</span>
            <span class="post-date" title="2021-09-07 00:00:00">2021/09/07</span>
        </a>
        
        <a  class="全部文章 算法 链表 "
           href="/2021/09/05/LinkedList-203-removeElements/"
           data-tag="203,移除链表元素"
           data-author="" >
            <span class="post-title" title="移除链表元素">移除链表元素</span>
            <span class="post-date" title="2021-09-05 00:00:00">2021/09/05</span>
        </a>
        
        <a  class="全部文章 算法 基础 "
           href="/2021/08/31/SearchAndSort/"
           data-tag="排序,查找"
           data-author="" >
            <span class="post-title" title="SearchAndSort">SearchAndSort</span>
            <span class="post-date" title="2021-08-31 14:27:08">2021/08/31</span>
        </a>
        
        <a  class="全部文章 后端 Java "
           href="/2021/08/13/HashSet-HashMap-analyse/"
           data-tag="集合,Set,Map"
           data-author="" >
            <span class="post-title" title="HashMap">HashMap</span>
            <span class="post-date" title="2021-08-13 14:59:19">2021/08/13</span>
        </a>
        
        <a  class="全部文章 后端 Java "
           href="/2021/08/13/LinkedList-analyse/"
           data-tag="集合,LinkedList"
           data-author="" >
            <span class="post-title" title="LinkedList-analyse">LinkedList-analyse</span>
            <span class="post-date" title="2021-08-13 13:19:52">2021/08/13</span>
        </a>
        
        <a  class="全部文章 后端 Java "
           href="/2021/08/13/Vector-analyse/"
           data-tag="集合,List,Vector"
           data-author="" >
            <span class="post-title" title="Vector-analyse">Vector-analyse</span>
            <span class="post-date" title="2021-08-13 11:42:21">2021/08/13</span>
        </a>
        
        <a  class="全部文章 后端 Java "
           href="/2021/08/13/Arraylist-analyse/"
           data-tag="集合,List,ArrayList"
           data-author="" >
            <span class="post-title" title="Arraylist_analyse">Arraylist_analyse</span>
            <span class="post-date" title="2021-08-13 08:59:00">2021/08/13</span>
        </a>
        
        <a  class="全部文章 后端 Java "
           href="/2021/08/10/Java-JUC/"
           data-tag="多线程"
           data-author="" >
            <span class="post-title" title="Java_JUC">Java_JUC</span>
            <span class="post-date" title="2021-08-10 20:42:30">2021/08/10</span>
        </a>
        
        <a  class="全部文章 算法 树 "
           href="/2021/07/09/Trie/"
           data-tag="前缀树,N叉树"
           data-author="" >
            <span class="post-title" title="过滤敏感词">过滤敏感词</span>
            <span class="post-date" title="2021-07-09 00:00:00">2021/07/09</span>
        </a>
        
        <a  class="全部文章 算法 滑动窗口 "
           href="/2021/07/02/slidingwindow/"
           data-tag="滑动窗口"
           data-author="" >
            <span class="post-title" title="滑动窗口">滑动窗口</span>
            <span class="post-date" title="2021-07-02 00:00:00">2021/07/02</span>
        </a>
        
        <a  class="全部文章 算法 双指针 "
           href="/2021/07/01/doublepointers/"
           data-tag="双指针"
           data-author="" >
            <span class="post-title" title="双指针">双指针</span>
            <span class="post-date" title="2021-07-01 00:00:00">2021/07/01</span>
        </a>
        
        <a  class="全部文章 数据库 Redis "
           href="/2021/06/29/redis-LearningNote/"
           data-tag="NoSQL"
           data-author="" >
            <span class="post-title" title="redis学习笔记">redis学习笔记</span>
            <span class="post-date" title="2021-06-29 00:00:00">2021/06/29</span>
        </a>
        
        <a  class="全部文章 算法 日期 "
           href="/2021/06/27/Zeller/"
           data-tag="蔡勒公式,OJ"
           data-author="" >
            <span class="post-title" title="Week = (Day + 2*Month + 3*(Month+1)/5 + Year + Year/4 - Year/100 + Year/400) % 7">Week = (Day + 2*Month + 3*(Month+1)/5 + Year + Year/4 - Year/100 + Year/400) % 7</span>
            <span class="post-date" title="2021-06-27 00:00:00">2021/06/27</span>
        </a>
        
        <a  class="全部文章 算法 树 "
           href="/2021/06/01/BinaryTree/"
           data-tag="二叉树"
           data-author="" >
            <span class="post-title" title="二叉树">二叉树</span>
            <span class="post-date" title="2021-06-01 00:00:00">2021/06/01</span>
        </a>
        
        <a  class="全部文章 运维 "
           href="/2021/05/27/linuxLearningNote/"
           data-tag="Shell,Linux"
           data-author="" >
            <span class="post-title" title="Linux 与 Shell">Linux 与 Shell</span>
            <span class="post-date" title="2021-05-27 00:00:00">2021/05/27</span>
        </a>
        
        <a  class="全部文章 DL "
           href="/2021/05/05/Resnet/"
           data-tag="DL,Resnet"
           data-author="" >
            <span class="post-title" title="Resnet">Resnet</span>
            <span class="post-date" title="2021-05-05 00:00:00">2021/05/05</span>
        </a>
        
        <a  class="全部文章 后端 Java "
           href="/2021/04/29/Java-polymorphism/"
           data-tag="多态"
           data-author="" >
            <span class="post-title" title="Java-polymorphism">Java-polymorphism</span>
            <span class="post-date" title="2021-04-29 00:00:00">2021/04/29</span>
        </a>
        
        <a  class="全部文章 后端 设计模式 "
           href="/2021/04/14/DesignPatternofBuilder/"
           data-tag="建造者模式,构建型模式"
           data-author="" >
            <span class="post-title" title="建造者模式">建造者模式</span>
            <span class="post-date" title="2021-04-14 00:00:00">2021/04/14</span>
        </a>
        
        <a  class="全部文章 后端 设计模式 "
           href="/2021/04/10/DesignPatternofSingleton/"
           data-tag="构建型模式,单例模式"
           data-author="" >
            <span class="post-title" title="单例模式">单例模式</span>
            <span class="post-date" title="2021-04-10 00:00:00">2021/04/10</span>
        </a>
        
        <a  class="全部文章 前端 "
           href="/2021/04/09/JavaScript-Note/"
           data-tag="前端,JavaScript"
           data-author="" >
            <span class="post-title" title="JavaScript">JavaScript</span>
            <span class="post-date" title="2021-04-09 14:27:00">2021/04/09</span>
        </a>
        
        <a  class="全部文章 DL Docker "
           href="/2021/04/09/DockerPractice/"
           data-tag="Docker,DL"
           data-author="" >
            <span class="post-title" title="DockerPractice">DockerPractice</span>
            <span class="post-date" title="2021-04-09 00:00:00">2021/04/09</span>
        </a>
        
        <a  class="全部文章 工具 git "
           href="/2021/04/06/GitLearningNote-2/"
           data-tag="git"
           data-author="" >
            <span class="post-title" title="git学习笔记">git学习笔记</span>
            <span class="post-date" title="2021-04-06 00:00:00">2021/04/06</span>
        </a>
        
        <a  class="全部文章 后端 设计模式 "
           href="/2021/04/02/DesignPatternofPrototype/"
           data-tag="构建型模式,原型模式"
           data-author="" >
            <span class="post-title" title="原型模式">原型模式</span>
            <span class="post-date" title="2021-04-02 00:00:00">2021/04/02</span>
        </a>
        
        <a  class="全部文章 后端 设计模式 "
           href="/2021/03/30/DesignPatternofFactory/"
           data-tag="创建型模式,简单工厂模式,工厂方法模式,抽象工厂模式"
           data-author="" >
            <span class="post-title" title="工厂模式">工厂模式</span>
            <span class="post-date" title="2021-03-30 00:00:00">2021/03/30</span>
        </a>
        
        <a  class="全部文章 数据库 MySQL "
           href="/2021/03/23/MySQLearningNote/"
           data-tag="SQL,约束,数据库的设计,数据库的备份和还原,多表查询,事务"
           data-author="" >
            <span class="post-title" title="MySQL学习笔记">MySQL学习笔记</span>
            <span class="post-date" title="2021-03-23 00:00:00">2021/03/23</span>
        </a>
        
        <a  class="全部文章 运维 Docker "
           href="/2021/03/19/DockerLearningNoteBase/"
           data-tag="docker,镜像,容器"
           data-author="" >
            <span class="post-title" title="Docker学习笔记">Docker学习笔记</span>
            <span class="post-date" title="2021-03-19 00:00:00">2021/03/19</span>
        </a>
        
        <a  class="全部文章 后端 C# "
           href="/2020/10/16/Ado-.net/"
           data-tag="C#,Ado.net"
           data-author="" >
            <span class="post-title" title="Ado.net">Ado.net</span>
            <span class="post-date" title="2020-10-16 00:00:00">2020/10/16</span>
        </a>
        
        <a  class="全部文章 工具 github "
           href="/2020/10/12/GitHubSearch/"
           data-tag="github"
           data-author="" >
            <span class="post-title" title="学会在github上搜索项目">学会在github上搜索项目</span>
            <span class="post-date" title="2020-10-12 13:55:57">2020/10/12</span>
        </a>
        
        <a  class="全部文章 后端 C# "
           href="/2020/09/21/Event-publisher-subscriber/"
           data-tag="C#,委托与事件"
           data-author="" >
            <span class="post-title" title="Event_publisher_subscriber">Event_publisher_subscriber</span>
            <span class="post-date" title="2020-09-21 15:17:32">2020/09/21</span>
        </a>
        
        <a  class="全部文章 读书 软件设计师 "
           href="/2019/12/16/SoftwareDesignTest/"
           data-tag="原码, 反码, 补码, 移码,进制转换"
           data-author="" >
            <span class="post-title" title="软件设计师">软件设计师</span>
            <span class="post-date" title="2019-12-16 10:46:08">2019/12/16</span>
        </a>
        
        <a  class="全部文章 工具 "
           href="/2019/12/03/douban-spider/"
           data-tag="爬虫,Python"
           data-author="" >
            <span class="post-title" title="豆瓣排行榜小爬虫">豆瓣排行榜小爬虫</span>
            <span class="post-date" title="2019-12-03 00:00:00">2019/12/03</span>
        </a>
        
        <a  class="全部文章 工具 "
           href="/2019/09/30/Crawler/"
           data-tag="爬虫,http"
           data-author="" >
            <span class="post-title" title="什么是网络爬虫">什么是网络爬虫</span>
            <span class="post-date" title="2019-09-30 14:35:05">2019/09/30</span>
        </a>
        
        <a  class="全部文章 DL Python "
           href="/2019/08/31/PythonNote/"
           data-tag="Python"
           data-author="" >
            <span class="post-title" title="Python学习笔记">Python学习笔记</span>
            <span class="post-date" title="2019-08-31 14:28:16">2019/08/31</span>
        </a>
        
        <a  class="全部文章 工具 git "
           href="/2019/08/10/HowToMakeBlog/"
           data-tag="博客搭建"
           data-author="" >
            <span class="post-title" title="搭建hexo博客">搭建hexo博客</span>
            <span class="post-date" title="2019-08-10 00:00:00">2019/08/10</span>
        </a>
        
        <a  class="全部文章 工具 git "
           href="/2019/06/13/GitLearningNote-1/"
           data-tag="git"
           data-author="" >
            <span class="post-title" title="git 初试">git 初试</span>
            <span class="post-date" title="2019-06-13 00:00:00">2019/06/13</span>
        </a>
        
        <a  class="全部文章 工具 "
           href="/2019/06/13/On-the-Internet-Scientifically/"
           data-tag="shadowsocks"
           data-author="" >
            <span class="post-title" title="科学上网">科学上网</span>
            <span class="post-date" title="2019-06-13 00:00:00">2019/06/13</span>
        </a>
        
        <div id="no-item-tips">

        </div>
    </nav>
    <div id="outline-list">
    </div>
</div>
    </div>
    <div class="hide-list">
        <div class="semicircle" data-title="切换全屏 快捷键 s">
            <div class="brackets first"><</div>
            <div class="brackets">&gt;</div>
        </div>
    </div>
</aside>
<div id="post">
    <div class="pjax">
        <article id="post-vue-learning" class="article article-type-post" itemscope itemprop="blogPost">
    
        <h1 class="article-title">Vue</h1>
    
    <div class="article-meta">
        
        
        
        <span class="book">
            <i class="iconfont icon-category"></i>
            
            
            <a  data-rel="前端">前端</a>
            
        </span>
        
        
        <span class="tag">
            <i class="iconfont icon-tag"></i>
            
            <a class="color4">Vue</a>
            
        </span>
        
    </div>
    <div class="article-meta">
        
            发布时间 : <time class="date" title='最后更新: 2026-01-21 16:35:26'>2026-01-19 16:47</time>
        
    </div>
    <div class="article-meta">
        
        <span>字数:19.8k</span>
        
        
        <span id="busuanzi_container_page_pv">
            阅读 :<span id="busuanzi_value_page_pv">
                <span class="count-comment">
                    <span class="spinner">
                      <div class="cube1"></div>
                      <div class="cube2"></div>
                    </span>
                </span>
            </span>
        </span>
        
        
        <span class="top-comment" title="跳转至评论区">
            <a href="#comments">
                评论:<span class="count-comment">
                    <span class="spinner">
                      <div class="cube1"></div>
                      <div class="cube2"></div>
                    </span>
                </span>
            </a>
        </span>
        
    </div>
    
    <div class="toc-ref">
    
        <ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%9F%A5%E8%AF%86%E7%82%B9"><span class="toc-text">知识点</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%8F%92%E5%80%BC%E8%AF%AD%E6%B3%95-amp-amp-%E6%8C%87%E4%BB%A4%E8%AF%AD%E6%B3%95"><span class="toc-text">插值语法 &amp;&amp; 指令语法</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E7%BB%91%E5%AE%9A"><span class="toc-text">数据绑定</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#el%E5%92%8Cdata%E7%9A%84%E4%B8%A4%E7%A7%8D%E5%86%99%E6%B3%95"><span class="toc-text">el和data的两种写法</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Vue-%E4%B8%AD%E7%9A%84%E4%BD%BF%E7%94%A8%E5%8E%9F%E5%88%99"><span class="toc-text">Vue 中的使用原则</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#gt-%E5%87%BD%E6%95%B0%E4%B8%8D%E6%98%AF%E5%9C%A8new-vue%E9%87%8C%E9%9D%A2%E5%AE%9A%E4%B9%89%E7%9A%84%E5%98%9B-%E4%B8%BA%E4%BB%80%E4%B9%88%E8%BF%98%E4%BC%9A%E6%8C%87%E5%90%91window"><span class="toc-text">&#x3D;&gt; 函数不是在new vue里面定义的嘛? 为什么还会指向window?</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E5%8C%BA%E5%88%86%E2%80%9C%E5%AE%9A%E4%B9%89%E2%80%9D%E5%92%8C%E2%80%9C%E6%89%A7%E8%A1%8C%E2%80%9D"><span class="toc-text">1. 区分“定义”和“执行”</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E7%AE%AD%E5%A4%B4%E5%87%BD%E6%95%B0%E7%9A%84%E2%80%9C%E8%AF%8D%E6%B3%95%E7%BB%91%E5%AE%9A%E2%80%9D%E8%A7%84%E5%88%99"><span class="toc-text">2. 箭头函数的“词法绑定”规则</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-%E4%B8%BA%E4%BB%80%E4%B9%88%E6%99%AE%E9%80%9A%E5%87%BD%E6%95%B0%E5%B0%B1%E6%B2%A1%E9%97%AE%E9%A2%98%EF%BC%9F"><span class="toc-text">3. 为什么普通函数就没问题？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%80%BB%E7%BB%93"><span class="toc-text">总结</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AE%AD%E5%A4%B4%E5%87%BD%E6%95%B0%E6%97%A0%E6%B3%95%E8%A2%AB-call-%E6%88%96-bind-%E6%94%B9%E5%8F%98-this-%E6%8C%87%E5%90%91%E6%98%AF%E5%9B%A0%E4%B8%BA%E4%BB%96%E6%98%AF%E5%8C%BF%E5%90%8D%E5%87%BD%E6%95%B0"><span class="toc-text">箭头函数无法被 call 或 bind 改变 this 指向是因为他是匿名函数?</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E6%A0%B8%E5%BF%83%E5%8E%9F%E5%9B%A0%EF%BC%9A%E7%AE%AD%E5%A4%B4%E5%87%BD%E6%95%B0%E6%B2%A1%E6%9C%89%E2%80%9Cthis%E2%80%9D"><span class="toc-text">1. 核心原因：箭头函数没有“this”</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E4%B8%BA%E4%BB%80%E4%B9%88%E8%AF%B4%E5%92%8C%E2%80%9C%E5%8C%BF%E5%90%8D%E2%80%9D%E6%97%A0%E5%85%B3%EF%BC%9F"><span class="toc-text">2. 为什么说和“匿名”无关？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-%E4%B8%80%E4%B8%AA%E7%AE%80%E5%8D%95%E7%9A%84%E7%B1%BB%E6%AF%94"><span class="toc-text">3. 一个简单的类比</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#MVVM%E6%A8%A1%E5%9E%8B"><span class="toc-text">MVVM模型</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-text">测试一下2: {{ $options }} &lt;&#x2F;h1&gt; &lt;hr&#x2F;&gt; 
        &lt;h1&gt;测试一下3: {{ $emit }} &lt;&#x2F;h1&gt; &lt;hr&#x2F;&gt;
        &lt;h1&gt;测试一下4: {{ _c }} &lt;&#x2F;h1&gt; &lt;hr&#x2F;&gt;
    &lt;&#x2F;div&gt;
    &lt;script type&#x3D;&quot;text&#x2F;javascript&quot;&gt;
        &#x2F;&#x2F;view model view与model之间的纽带
        &#x2F;&#x2F;vm view实例对象
        const vm &#x3D;  new Vue({
            el: &#39;#root&#39;,
            data(){
                &#x2F;&#x2F;model
                return {
                    name:&#39;武汉科技大学&#39;,
                    address: &#39;武汉&#39;
                }
            }
        });
        console.log(vm);
    &lt;&#x2F;script&gt;
&lt;&#x2F;body&gt;
&lt;&#x2F;html&gt;
</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%F0%9F%A7%B1-M-%E6%A8%A1%E5%9E%8B"><span class="toc-text">🧱 M - 模型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%F0%9F%8E%A8-V-%E8%A7%86%E5%9B%BE"><span class="toc-text">🎨 V - 视图</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%F0%9F%94%84-VM-%E8%A7%86%E5%9B%BE%E6%A8%A1%E5%9E%8B"><span class="toc-text">🔄 VM - 视图模型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%F0%9F%9A%80-%E6%A0%B8%E5%BF%83%E4%BC%98%E5%8A%BF%EF%BC%9A%E5%8F%8C%E5%90%91%E7%BB%91%E5%AE%9A"><span class="toc-text">🚀 核心优势：双向绑定</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%F0%9F%94%8D-%E8%A1%A5%E5%85%85%EF%BC%9A%E4%BD%A0%E4%BB%A3%E7%A0%81%E4%B8%AD%E6%B3%A8%E9%87%8A%E7%9A%84%E9%82%A3%E4%B8%A4%E7%82%B9%E8%A7%82%E5%AF%9F"><span class="toc-text">🔍 补充：你代码中注释的那两点观察</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%F0%9F%93%8C-%E6%80%BB%E7%BB%93"><span class="toc-text">📌 总结</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E4%BB%A3%E7%90%86-Object-defineProperty%E6%96%B9%E6%B3%95"><span class="toc-text">数据代理-Object.defineProperty方法</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E6%A0%B8%E5%BF%83%E6%A6%82%E5%BF%B5%EF%BC%9A%E5%AE%83%E4%B8%8D%E5%8F%AA%E6%98%AF%E8%B5%8B%E5%80%BC"><span class="toc-text">1. 核心概念：它不只是赋值</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E4%BD%A0%E7%9A%84%E4%BB%A3%E7%A0%81%E8%A7%A3%E6%9E%90%EF%BC%9A%E6%95%B0%E6%8D%AE%E5%8A%AB%E6%8C%81%E4%B8%8E%E4%BB%A3%E7%90%86"><span class="toc-text">2. 你的代码解析：数据劫持与代理</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%B1%9E%E6%80%A7%E7%9A%84%E2%80%9C%E8%AF%BB%E5%8F%96%E2%80%9D%E7%9B%91%E6%8E%A7-get"><span class="toc-text">属性的“读取”监控 (get)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%B1%9E%E6%80%A7%E7%9A%84%E2%80%9C%E4%BF%AE%E6%94%B9%E2%80%9D%E7%9B%91%E6%8E%A7-set"><span class="toc-text">属性的“修改”监控 (set)</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-%E4%B8%BA%E4%BB%80%E4%B9%88%E9%81%8D%E5%8E%86%E4%B8%8D%E5%88%B0-age%EF%BC%9F"><span class="toc-text">3. 为什么遍历不到 age？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-%E5%BD%A2%E8%B1%A1%E7%9A%84%E6%AF%94%E5%96%BB"><span class="toc-text">4. 形象的比喻</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-%E5%AE%83%E7%9A%84%E5%AE%9E%E6%88%98%E6%84%8F%E4%B9%89%EF%BC%88Vue-2-%E7%9A%84%E6%A0%B8%E5%BF%83%EF%BC%89"><span class="toc-text">5. 它的实战意义（Vue 2 的核心）</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E4%BB%A3%E7%90%86-%E4%BD%95%E4%B8%BA%E6%95%B0%E6%8D%AE%E4%BB%A3%E7%90%86"><span class="toc-text">数据代理-何为数据代理?</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%F0%9F%A7%A9-%E4%BB%A3%E7%A0%81%E6%8B%86%E8%A7%A3%EF%BC%9A%E5%AE%83%E6%98%AF%E5%A6%82%E4%BD%95%E5%B7%A5%E4%BD%9C%E7%9A%84%EF%BC%9F"><span class="toc-text">🧩 代码拆解：它是如何工作的？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%F0%9F%8E%AC-%E7%94%9F%E6%B4%BB%E4%B8%AD%E7%9A%84%E6%AF%94%E5%96%BB"><span class="toc-text">🎬 生活中的比喻</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%F0%9F%92%A1-%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E7%94%A8%E6%95%B0%E6%8D%AE%E4%BB%A3%E7%90%86%EF%BC%9F%EF%BC%88Vue-%E7%9A%84%E8%A7%86%E8%A7%92%EF%BC%89"><span class="toc-text">💡 为什么要用数据代理？（Vue 的视角）</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#vue%E4%B8%AD%E7%9A%84%E6%95%B0%E6%8D%AE%E4%BB%A3%E7%90%86"><span class="toc-text">vue中的数据代理</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%F0%9F%8E%AD-%E4%BB%80%E4%B9%88%E6%98%AF%E6%95%B0%E6%8D%AE%E4%BB%A3%E7%90%86%EF%BC%9F"><span class="toc-text">🎭 什么是数据代理？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%F0%9F%8C%89-%E5%9F%BA%E6%9C%AC%E5%8E%9F%E7%90%86%EF%BC%9AObject-defineProperty-%E7%9A%84%E9%AD%94%E6%B3%95"><span class="toc-text">🌉 基本原理：Object.defineProperty 的魔法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%F0%9F%A4%94-%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E8%BF%99%E4%B9%88%E5%81%9A%EF%BC%9F%EF%BC%88%E5%A5%BD%E5%A4%84%EF%BC%89"><span class="toc-text">🤔 为什么要这么做？（好处）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%F0%9F%94%8D-%E9%AA%8C%E8%AF%81%E4%B8%80%E4%B8%8B"><span class="toc-text">🔍 验证一下</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%8B%E4%BB%B6%E5%A4%84%E7%90%86-%E9%94%AE%E7%9B%98%E4%BA%8B%E4%BB%B6"><span class="toc-text">事件处理-键盘事件</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%F0%9F%A7%B1-%E5%9F%BA%E7%A1%80%E7%94%A8%E6%B3%95"><span class="toc-text">🧱 基础用法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%F0%9F%8F%B7%EF%B8%8F-%E5%B8%B8%E7%94%A8%E6%8C%89%E9%94%AE%E5%88%AB%E5%90%8D"><span class="toc-text">🏷️ 常用按键别名</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E2%9A%99%EF%B8%8F-%E7%B3%BB%E7%BB%9F%E4%BF%AE%E9%A5%B0%E9%94%AE-%E7%89%B9%E6%AE%8A%E7%94%A8%E6%B3%95"><span class="toc-text">⚙️ 系统修饰键 (特殊用法)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E2%9C%A8-%E8%87%AA%E5%AE%9A%E4%B9%89%E5%88%AB%E5%90%8D%E4%B8%8E%E8%BF%9E%E7%94%A8"><span class="toc-text">✨ 自定义别名与连用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%F0%9F%92%A1-%E5%85%B3%E4%BA%8E-tab-%E9%94%AE%E7%9A%84%E7%89%B9%E5%88%AB%E8%AF%B4%E6%98%8E"><span class="toc-text">💡 关于 tab 键的特别说明</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%F0%9F%93%8C-%E6%80%BB%E7%BB%93-1"><span class="toc-text">📌 总结</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%8B%E4%BB%B6%E5%A4%84%E7%90%86-Command-%E9%94%AE"><span class="toc-text">事件处理-Command 键</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E6%A0%B8%E5%BF%83%E6%A6%82%E5%BF%B5%EF%BC%9A-meta"><span class="toc-text">1. 核心概念：.meta</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E5%85%B7%E4%BD%93%E6%8C%87%E4%BB%A3%EF%BC%9A%E7%9C%8B%E4%BD%A0%E7%9A%84%E7%94%B5%E8%84%91%E7%B3%BB%E7%BB%9F"><span class="toc-text">2. 具体指代：看你的电脑系统</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-%E4%B8%BA%E4%BB%80%E4%B9%88%E4%BC%9A%E6%9C%89-%E2%80%9Ccommand%E2%80%9D-%E8%BF%99%E7%A7%8D%E5%86%99%E6%B3%95%EF%BC%9F"><span class="toc-text">3. 为什么会有 “command” 这种写法？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%F0%9F%92%A1-%E6%80%BB%E7%BB%93%E4%B8%8E%E5%BB%BA%E8%AE%AE"><span class="toc-text">💡 总结与建议</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%8B%E4%BB%B6%E5%A4%84%E7%90%86%E7%9A%84%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8"><span class="toc-text">事件处理的基本使用</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E2%8C%A8%EF%B8%8F-%E9%94%AE%E7%9B%98%E4%BA%8B%E4%BB%B6%EF%BC%9A-meta-%E4%BF%AE%E9%A5%B0%E7%AC%A6%E7%9A%84%E5%A5%A5%E7%A7%98"><span class="toc-text">⌨️ 键盘事件：.meta 修饰符的奥秘</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#keydown-meta-quot-showInfo-quot"><span class="toc-text">@keydown.meta&#x3D;&quot;showInfo&quot;</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#keyup-meta-quot-showInfo-quot"><span class="toc-text">@keyup.meta&#x3D;&quot;showInfo&quot;</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%F0%9F%96%B1%EF%B8%8F-%E9%BC%A0%E6%A0%87%E4%BA%8B%E4%BB%B6%EF%BC%9A%E5%8F%82%E6%95%B0%E4%B8%8E-this"><span class="toc-text">🖱️ 鼠标事件：参数与 this</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-%E8%AE%BF%E9%97%AE%E5%8E%9F%E7%94%9F%E4%BA%8B%E4%BB%B6%E5%AF%B9%E8%B1%A1"><span class="toc-text">1. 访问原生事件对象</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-%E6%AD%A3%E7%A1%AE%E7%9A%84-this-%E6%8C%87%E5%90%91"><span class="toc-text">2. 正确的 this 指向</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%F0%9F%92%A1-%E4%B8%80%E4%B8%AA%E6%BD%9C%E5%9C%A8%E7%9A%84%E4%BC%98%E5%8C%96%E7%82%B9"><span class="toc-text">💡 一个潜在的优化点</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%F0%9F%93%8C-%E6%80%BB%E7%BB%93-2"><span class="toc-text">📌 总结</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%8B%E4%BB%B6%E4%BF%AE%E9%A5%B0"><span class="toc-text">事件修饰</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%F0%9F%9B%A0%EF%B8%8F-%E6%A0%B8%E5%BF%83%E6%9C%BA%E5%88%B6%EF%BC%9A%E4%BA%8B%E4%BB%B6%E4%BF%AE%E9%A5%B0%E7%AC%A6-Event-Modifiers"><span class="toc-text">🛠️ 核心机制：事件修饰符 (Event Modifiers)</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-%E9%98%BB%E6%96%AD%E4%B8%8E%E9%99%90%E5%88%B6%E7%B1%BB"><span class="toc-text">1. 阻断与限制类</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-%E9%80%BB%E8%BE%91%E4%B8%8E%E6%80%A7%E8%83%BD%E7%B1%BB"><span class="toc-text">2. 逻辑与性能类</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%F0%9F%8C%8A-%E4%BA%8B%E4%BB%B6%E6%B5%81%EF%BC%9A%E6%8D%95%E8%8E%B7%E4%B8%8E%E5%86%92%E6%B3%A1"><span class="toc-text">🌊 事件流：捕获与冒泡</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-%E9%BB%98%E8%AE%A4%E7%9A%84%E5%86%92%E6%B3%A1%E6%A8%A1%E5%BC%8F-Bubbling"><span class="toc-text">1. 默认的冒泡模式 (Bubbling)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-%E6%8D%95%E8%8E%B7%E6%A8%A1%E5%BC%8F-Capturing"><span class="toc-text">2. 捕获模式 (Capturing)</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%F0%9F%9A%80-%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%EF%BC%9A-passive-%E7%9A%84%E5%A6%99%E7%94%A8"><span class="toc-text">🚀 性能优化：.passive 的妙用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E2%9A%A0%EF%B8%8F-%E5%85%B3%E4%BA%8E-this-%E7%9A%84%E5%86%8D%E6%AC%A1%E5%BC%BA%E8%B0%83"><span class="toc-text">⚠️ 关于 this 的再次强调</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%F0%9F%93%8C-%E6%80%BB%E7%BB%93%E4%B8%8E%E5%BB%BA%E8%AE%AE"><span class="toc-text">📌 总结与建议</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%AE%A1%E7%AE%97%E5%B1%9E%E6%80%A7"><span class="toc-text">计算属性</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%F0%9F%A7%AE-%E4%BB%80%E4%B9%88%E6%98%AF%E8%AE%A1%E7%AE%97%E5%B1%9E%E6%80%A7%EF%BC%9F"><span class="toc-text">🧮 什么是计算属性？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E2%9A%99%EF%B8%8F-%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86%EF%BC%9A%E4%BE%9D%E8%B5%96%E8%BF%BD%E8%B8%AA%E4%B8%8E%E7%BC%93%E5%AD%98"><span class="toc-text">⚙️ 工作原理：依赖追踪与缓存</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%F0%9F%93%9D-%E7%AE%80%E5%86%99%E5%BD%A2%E5%BC%8F"><span class="toc-text">📝 简写形式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%F0%9F%8E%AC-%E4%BB%A3%E7%A0%81%E8%BF%90%E8%A1%8C%E6%B5%81%E7%A8%8B%E5%9B%BE%E8%A7%A3"><span class="toc-text">🎬 代码运行流程图解</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%F0%9F%92%A1-%E6%80%BB%E7%BB%93"><span class="toc-text">💡 总结</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%9B%91%E8%A7%86%E5%B1%9E%E6%80%A7"><span class="toc-text">监视属性</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E6%A0%B8%E5%BF%83%E6%9C%BA%E5%88%B6%EF%BC%9Avm-watch"><span class="toc-text">1. 核心机制：vm.$watch</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-Vue-%E7%9A%84%E7%9B%91%E6%B5%8B%E5%A5%A5%E7%A7%98%EF%BC%9Anumbers-%E5%AF%B9%E8%B1%A1"><span class="toc-text">2. Vue 的监测奥秘：numbers 对象</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E2%9D%93-%E9%97%AE%E9%A2%98%EF%BC%9A%E4%B8%BA%E4%BB%80%E4%B9%88%E4%BF%AE%E6%94%B9-numbers-c-d-%E8%83%BD%E8%A2%AB%E7%9B%91%E6%B5%8B%E5%88%B0%EF%BC%9F"><span class="toc-text">❓ 问题：为什么修改 numbers.c.d 能被监测到？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E2%9A%A0%EF%B8%8F-%E6%B3%A8%E6%84%8F%EF%BC%9Adeep-true-%E5%9C%A8%E8%BF%99%E9%87%8C%E6%98%AF%E2%80%9C%E5%A4%9A%E4%BD%99%E2%80%9D%E7%9A%84%EF%BC%9F"><span class="toc-text">⚠️ 注意：deep: true 在这里是“多余”的？</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-%E8%AE%A1%E7%AE%97%E5%B1%9E%E6%80%A7-vs-%E4%BE%A6%E5%90%AC%E5%B1%9E%E6%80%A7"><span class="toc-text">3. 计算属性 vs. 侦听属性</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-%E4%BB%A3%E7%A0%81%E8%BF%90%E8%A1%8C%E9%A2%84%E6%B5%8B"><span class="toc-text">4. 代码运行预测</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%F0%9F%93%8C-%E6%80%BB%E7%BB%93-3"><span class="toc-text">📌 总结</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%AE%A1%E7%AE%97%E5%B1%9E%E6%80%A7-amp-amp-%E7%9B%91%E8%A7%86%E5%B1%9E%E6%80%A7"><span class="toc-text">计算属性 &amp;&amp; 监视属性</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-computed-vs-watch%EF%BC%9A%E5%90%8C%E6%AD%A5%E4%B8%8E%E5%BC%82%E6%AD%A5%E7%9A%84%E9%B8%BF%E6%B2%9F"><span class="toc-text">1. computed vs watch：同步与异步的鸿沟</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#computed-%E7%9A%84%E5%B1%80%E9%99%90%E6%80%A7%EF%BC%88%E7%BA%AF%E5%90%8C%E6%AD%A5%EF%BC%89"><span class="toc-text">computed 的局限性（纯同步）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#watch-%E7%9A%84%E7%81%B5%E6%B4%BB%E6%80%A7%EF%BC%88%E5%8F%AF%E5%BC%82%E6%AD%A5%EF%BC%89"><span class="toc-text">watch 的灵活性（可异步）</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E5%85%B3%E4%BA%8E-this-%E6%8C%87%E5%90%91%E7%9A%84%E4%B8%A4%E4%B8%AA%E5%8E%9F%E5%88%99"><span class="toc-text">2. 关于 this 指向的两个原则</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8E%9F%E5%88%99%E4%B8%80%EF%BC%9AVue-%E7%AE%A1%E7%90%86%E7%9A%84%E5%87%BD%E6%95%B0%EF%BC%8C%E7%94%A8%E6%99%AE%E9%80%9A%E5%87%BD%E6%95%B0"><span class="toc-text">原则一：Vue 管理的函数，用普通函数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8E%9F%E5%88%99%E4%BA%8C%EF%BC%9A%E9%9D%9E-Vue-%E7%AE%A1%E7%90%86%E7%9A%84%E5%87%BD%E6%95%B0%EF%BC%8C%E7%94%A8%E7%AE%AD%E5%A4%B4%E5%87%BD%E6%95%B0"><span class="toc-text">原则二：非 Vue 管理的函数，用箭头函数</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-%E4%BB%A3%E7%A0%81%E8%BF%90%E8%A1%8C%E6%B5%81%E7%A8%8B%E5%9B%BE%E8%A7%A3"><span class="toc-text">3. 代码运行流程图解</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%80%BB%E7%BB%93-1"><span class="toc-text">总结</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BB%91%E5%AE%9A%E6%A0%B7%E5%BC%8F"><span class="toc-text">绑定样式</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%86%99%E6%B3%95-v-bind-class-class"><span class="toc-text">1. 字符串写法 (v-bind:class &#x2F; :class)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E6%95%B0%E7%BB%84%E5%86%99%E6%B3%95-class"><span class="toc-text">2. 数组写法 (:class)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-%E5%AF%B9%E8%B1%A1%E5%86%99%E6%B3%95-class"><span class="toc-text">3. 对象写法 (:class)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%F0%9F%93%8C-%E6%80%BB%E7%BB%93%E4%B8%8E%E5%AF%B9%E6%AF%94"><span class="toc-text">📌 总结与对比</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%F0%9F%92%A1-%E8%A1%A5%E5%85%85%E5%BB%BA%E8%AE%AE"><span class="toc-text">💡 补充建议</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9D%A1%E4%BB%B6%E6%B8%B2%E6%9F%93"><span class="toc-text">条件渲染</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-v-if-vs-v-show%EF%BC%9A%E7%A7%BB%E9%99%A4-vs-%E9%9A%90%E8%97%8F"><span class="toc-text">1. v-if vs v-show：移除 vs 隐藏</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#v-if%EF%BC%9A%E7%9C%9F%E6%AD%A3%E7%9A%84%E2%80%9C%E6%9D%A1%E4%BB%B6%E6%B8%B2%E6%9F%93%E2%80%9D"><span class="toc-text">v-if：真正的“条件渲染”</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#v-show%EF%BC%9ACSS-%E7%9A%84%E2%80%9C%E5%BC%80%E5%85%B3%E2%80%9D"><span class="toc-text">v-show：CSS 的“开关”</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E6%80%A7%E8%83%BD%E4%B8%8E%E5%9C%BA%E6%99%AF%E9%80%89%E6%8B%A9"><span class="toc-text">2. 性能与场景选择</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8-v-if-%E7%9A%84%E5%9C%BA%E6%99%AF"><span class="toc-text">使用 v-if 的场景</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8-v-show-%E7%9A%84%E5%9C%BA%E6%99%AF"><span class="toc-text">使用 v-show 的场景</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-v-if-%E7%9A%84%E8%BF%9B%E9%98%B6%E7%94%A8%E6%B3%95"><span class="toc-text">3. v-if 的进阶用法</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-v-else-if-%E4%B8%8E-v-else"><span class="toc-text">1. v-else-if 与 v-else</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-lt-template-gt-%E6%A0%87%E7%AD%BE"><span class="toc-text">2. &lt;template&gt; 标签</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-%E5%85%B3%E4%BA%8E%E2%80%9C%E8%8E%B7%E5%8F%96%E5%85%83%E7%B4%A0%E2%80%9D%E7%9A%84%E5%A4%87%E6%B3%A8"><span class="toc-text">4. 关于“获取元素”的备注</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%80%BB%E7%BB%93-2"><span class="toc-text">总结</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%88%97%E8%A1%A8%E6%B8%B2%E6%9F%93"><span class="toc-text">列表渲染</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%94%B6%E9%9B%86%E8%A1%A8%E5%8D%95%E6%95%B0%E6%8D%AE"><span class="toc-text">收集表单数据</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%BF%87%E6%BB%A4%E5%99%A8"><span class="toc-text">过滤器</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%86%85%E7%BD%AE%E6%8C%87%E4%BB%A4"><span class="toc-text">内置指令</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%87%AA%E5%AE%9A%E4%B9%89%E6%8C%87%E4%BB%A4"><span class="toc-text">自定义指令</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F"><span class="toc-text">生命周期</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%9D%9E%E5%8D%95%E6%96%87%E4%BB%B6%E7%BB%84%E4%BB%B6"><span class="toc-text">非单文件组件</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8D%95%E6%96%87%E4%BB%B6%E7%BB%84%E4%BB%B6"><span class="toc-text">单文件组件</span></a></li></ol></li></ol>
    
<style>
    .left-col .switch-btn,
    .left-col .switch-area {
        display: none;
    }
    .toc-level-3 i,
    .toc-level-3 ol {
        display: none !important;
    }
</style>
</div>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="知识点"><a href="#知识点" class="headerlink" title="知识点"></a>知识点</h1><h2 id="插值语法-amp-amp-指令语法"><a href="#插值语法-amp-amp-指令语法" class="headerlink" title="插值语法 &amp;&amp; 指令语法"></a>插值语法 &amp;&amp; 指令语法</h2><blockquote>


<p>v-bind:XXX 或者 :XXX</p>
</blockquote>
<p>案例:</p>
<pre><code class="html">&lt;!doctype html&gt;
&lt;html lang=&quot;en&quot;&gt;
&lt;head&gt;
    &lt;meta charset=&quot;UTF-8&quot;&gt;
    &lt;meta name=&quot;viewport&quot;
          content=&quot;width=device-width, user-scalable=no, initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0&quot;&gt;
    &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;ie=edge&quot;&gt;
    &lt;title&gt;插值语法&lt;/title&gt;
    &lt;script src=&quot;../js/vue.js&quot;&gt;&lt;/script&gt;
&lt;/head&gt;
&lt;body&gt;
    &lt;div id=&quot;root&quot;&gt;
        &lt;h1&gt;hello, &#123;&#123; name &#125;&#125;&lt;/h1&gt;
        &lt;hr/&gt;
        &lt;a v-bind:href=&quot;url_baidu&quot; target=&quot;_blank&quot;&gt;&#123;&#123; url_baidu_name &#125;&#125;&lt;/a&gt;
        &lt;hr/&gt;
        &lt;p&gt;学校: &lt;a :href=&quot;school.url.toString()&quot;&gt; &#123;&#123; school.name &#125;&#125; &lt;/a&gt; &lt;/p&gt;
    &lt;/div&gt;
    &lt;script&gt;
        new Vue(&#123;
            el: &#39;#root&#39;,
            data: &#123;
                name: &#39;Jungle&#39;,
                url_baidu: &#39;https://www.baidu.com&#39;,
                url_baidu_name: &#39;点击跳转-&gt;百度&#39;,
                school: &#123;
                    name: &#39;清华大学&#39;,
                    url: &#39;https://www.tsinghua.edu.cn/&#39;
                &#125;
            &#125;
        &#125;)
    &lt;/script&gt;
&lt;/body&gt;
&lt;/html&gt;
</code></pre>
<p><img src="/2026/01/19/vue-learning/image-20260119173741648.png" alt="image-20260119173741648"></p>
<hr>
<h2 id="数据绑定"><a href="#数据绑定" class="headerlink" title="数据绑定"></a>数据绑定</h2><blockquote>
<p>Vue中有2种数据绑定的方式：<br>                    1.单向绑定(v-bind)：数据只能从data流向页面。<br>                    2.双向绑定(v-model)：数据不仅能从data流向页面，还可以从页面流向data。<br>                        备注：<br>                            1.双向绑定一般都应用在表单类元素上（如：input、select等）<br>                            2.v-model:value 可以简写为 v-model，因为v-model默认收集的就是value值。</p>
</blockquote>
<pre><code class="html">&lt;!doctype html&gt;
&lt;html lang=&quot;en&quot;&gt;
&lt;head&gt;
    &lt;meta charset=&quot;UTF-8&quot;&gt;
    &lt;meta name=&quot;viewport&quot;
          content=&quot;width=device-width, user-scalable=no, initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0&quot;&gt;
    &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;ie=edge&quot;&gt;
    &lt;title&gt;vue 数据绑定&lt;/title&gt;
    &lt;script src=&quot;../js/vue.js&quot;&gt;&lt;/script&gt;
&lt;/head&gt;
&lt;body&gt;
    &lt;div id=&quot;root&quot;&gt;
        &lt;label&gt;
            单项数据绑定:
            &lt;!--&lt;input type=&#39;text&#39; v-bind:value=&quot;name&quot;/&gt;--&gt;
            &lt;!--简写--&gt;
            &lt;input type=&#39;text&#39; :value=&quot;name&quot;/&gt;
        &lt;/label&gt;
        &lt;label&gt;
            双向数据绑定:
            &lt;!--&lt;input type=&#39;text&#39; v-model:value=&quot;name&quot;/&gt;--&gt;
            &lt;input type=&#39;text&#39; v-model=&quot;name&quot;/&gt;
        &lt;/label&gt;
        &lt;br/&gt;
         &lt;!--
         不是什么都可用v-model的 这里v-model不支持h1
         v-model只能应用在表单元素上(输入元素)，与用户交互(都有共同的value属性)
         --&gt;
        &lt;h1 v-bind:x=&quot;name&quot;&gt;
            你好啊
        &lt;/h1&gt;
    &lt;/div&gt;
    &lt;script type=&quot;text/javascript&quot;&gt;
        //v-bind可以完成数据绑定(单项绑定)
        //v-model双向数据绑定
        //单项数据绑定 双向数据绑定
        Vue.config.productionTip = false;
        new Vue(&#123;
            el: &#39;#root&#39;,
            data:&#123;
                name: &#39;shanghai&#39;
            &#125;
        &#125;)
    &lt;/script&gt;
&lt;/body&gt;
&lt;/html&gt;
</code></pre>
<p><img src="/2026/01/19/vue-learning/image-20260120085800149.png" alt="image-20260120085800149"></p>
<hr>
<h2 id="el和data的两种写法"><a href="#el和data的两种写法" class="headerlink" title="el和data的两种写法"></a>el和data的两种写法</h2><blockquote>
<p>data与el的2种写法</p>
<p>​          1.el有2种写法</p>
<p>​                  (1).new Vue时候配置el属性。</p>
<p>​                  (2).先创建Vue实例，随后再通过vm.$mount(‘#root’)指定el的值。</p>
<p>​          2.data有2种写法</p>
<p>​                  (1).对象式</p>
<p>​                  (2).函数式</p>
<p>​                  如何选择：目前哪种写法都可以，以后学习到组件时，data必须使用函数式，否则会报错。</p>
<p>​          3.一个重要的原则：</p>
<p>​                  由Vue管理的函数(例如data)，一定不要写箭头函数，一旦写了箭头函数，this就不再是Vue实例了。</p>
</blockquote>
<p>el的第一种写法</p>
<pre><code class="html">&lt;!doctype html&gt;
&lt;html lang=&quot;en&quot;&gt;
&lt;head&gt;
    &lt;meta charset=&quot;UTF-8&quot;&gt;
    &lt;meta name=&quot;viewport&quot;
          content=&quot;width=device-width, user-scalable=no, initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0&quot;&gt;
    &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;ie=edge&quot;&gt;
    &lt;title&gt;el和data的两种写法&lt;/title&gt;
    &lt;script src=&quot;../js/vue.js&quot;&gt;&lt;/script&gt;
&lt;/head&gt;
&lt;body&gt;
   &lt;div id=&quot;root&quot;&gt;
       &lt;h1&gt;你好，&#123;&#123; name &#125;&#125;&lt;/h1&gt;
   &lt;/div&gt;
   &lt;script type=&quot;text/javascript&quot;&gt;
       Vue.config.productionTip = false;
       const v = new Vue(&#123;
           el: &#39;#root&#39;, //第一种写法
           data: &#123;
               name: &#39;上海&#39;
           &#125;
       &#125;);
   &lt;/script&gt;
&lt;/body&gt;
&lt;/html&gt;
</code></pre>
<p>el的第二种写法</p>
<pre><code class="html">&lt;!doctype html&gt;
&lt;html lang=&quot;en&quot;&gt;
&lt;head&gt;
    &lt;meta charset=&quot;UTF-8&quot;&gt;
    &lt;meta name=&quot;viewport&quot;
          content=&quot;width=device-width, user-scalable=no, initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0&quot;&gt;
    &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;ie=edge&quot;&gt;
    &lt;title&gt;el和data的两种写法&lt;/title&gt;
    &lt;script src=&quot;../js/vue.js&quot;&gt;&lt;/script&gt;
&lt;/head&gt;
&lt;body&gt;
   &lt;div id=&quot;root&quot;&gt;
       &lt;h1&gt;你好，&#123;&#123; name &#125;&#125;&lt;/h1&gt;
   &lt;/div&gt;
   &lt;script type=&quot;text/javascript&quot;&gt;
       Vue.config.productionTip = false;
       const vm = new Vue(&#123;
           data: &#123;
               name: &#39;上海&#39;
           &#125;
       &#125;);
       // 关联root容器，用mount方法
       setTimeout(() =&gt; &#123;
           vm.$mount(&#39;#root&#39;); //第二种写法 挂载到页面上
       &#125;, 3000);
   &lt;/script&gt;
&lt;/body&gt;
&lt;/html&gt;
</code></pre>
<p>data的第一种写法:对象式</p>
<pre><code class="html">&lt;!doctype html&gt;
&lt;html lang=&quot;en&quot;&gt;
&lt;head&gt;
    &lt;meta charset=&quot;UTF-8&quot;&gt;
    &lt;meta name=&quot;viewport&quot;
          content=&quot;width=device-width, user-scalable=no, initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0&quot;&gt;
    &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;ie=edge&quot;&gt;
    &lt;title&gt;el和data的两种写法&lt;/title&gt;
    &lt;script src=&quot;../js/vue.js&quot;&gt;&lt;/script&gt;
&lt;/head&gt;
&lt;body&gt;
   &lt;div id=&quot;root&quot;&gt;
       &lt;h1&gt;你好，&#123;&#123; name &#125;&#125;&lt;/h1&gt;
   &lt;/div&gt;
   &lt;script type=&quot;text/javascript&quot;&gt;
       Vue.config.productionTip = false;
       new Vue(&#123;
          el: &#39;#root&#39;,
          //data的第一种写法:对象式
          data: &#123;
             name: &#39;shanghai&#39;
          &#125;
       &#125;);
   &lt;/script&gt;
&lt;/body&gt;
&lt;/html&gt;
</code></pre>
<p>第二种写法: 函数式(返回对象中包含你想渲染的模版数据)</p>
<pre><code class="html">&lt;!doctype html&gt;
&lt;html lang=&quot;en&quot;&gt;
&lt;head&gt;
    &lt;meta charset=&quot;UTF-8&quot;&gt;
    &lt;meta name=&quot;viewport&quot;
          content=&quot;width=device-width, user-scalable=no, initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0&quot;&gt;
    &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;ie=edge&quot;&gt;
    &lt;title&gt;el和data的两种写法&lt;/title&gt;
    &lt;script src=&quot;../js/vue.js&quot;&gt;&lt;/script&gt;
&lt;/head&gt;
&lt;body&gt;
   &lt;div id=&quot;root&quot;&gt;
       &lt;h1&gt;你好，&#123;&#123; name &#125;&#125;&lt;/h1&gt;
   &lt;/div&gt;
   &lt;script type=&quot;text/javascript&quot;&gt;
       Vue.config.productionTip = false;
       new Vue(&#123;
          el: &#39;#root&#39;,
          //第二种写法: 函数式(返回对象中包含你想渲染的模版数据)
          //学习组件的时候要是用函数式 这个函数是Vue来调用的
          // data: () =&gt; &#123; //箭头函数
          //    console.log(`@@@@`, this); //此时this是window，因为箭头函数没有自己的this，它向外查找找到的window
          //    return (&#123;
          //         name: &#39;shanghai&#39;
          //     &#125;)
          // &#125;
          //尽量不要写成剪头函数，因为会丢失this
          data () &#123; //普通函数
             console.log(&#39;@@@&#39;, this); //此时this是Vue
             return &#123;
                 name: &#39;shanghai&#39;
             &#125;
          &#125;
       &#125;);
   &lt;/script&gt;
&lt;/body&gt;
&lt;/html&gt;
</code></pre>
<blockquote>
<h3 id="Vue-中的使用原则"><a href="#Vue-中的使用原则" class="headerlink" title="Vue 中的使用原则"></a>Vue 中的使用原则</h3><p>一个简单的判断原则：</p>
<ul>
<li><strong>由 Vue 管理的函数</strong>：例如 <code>data()</code>, <code>methods</code> 中的方法，<code>computed</code> 计算属性，生命周期钩子（如 <code>mounted</code>）等。这些函数需要被 Vue 调用，并且需要访问 Vue 实例 (<code>this</code>)，所以<strong>必须使用普通函数</strong>。</li>
<li><strong>不由 Vue 管理的函数</strong>：例如 <code>setTimeout</code> 的回调函数，或者一些需要保持 <code>this</code> 指向外部 Vue 实例的场景。为了避免 <code>this</code> 指向丢失，可以<strong>使用箭头函数</strong>来“继承”外层的 <code>this</code>。</li>
</ul>
<p><strong>总结</strong>：在 Vue 2 的选项式 API 中，除了特定的回调场景，绝大多数情况下都应该使用<strong>普通函数</strong>。</p>
</blockquote>
<h2 id="gt-函数不是在new-vue里面定义的嘛-为什么还会指向window"><a href="#gt-函数不是在new-vue里面定义的嘛-为什么还会指向window" class="headerlink" title="=&gt; 函数不是在new vue里面定义的嘛? 为什么还会指向window?"></a>=&gt; 函数不是在new vue里面定义的嘛? 为什么还会指向window?</h2><p>简单直接的回答是：<strong>虽然函数是在 <code>new Vue(&#123;&#125;)</code> 的配置对象里“定义”的，但决定 <code>this</code> 指向的不是“定义”的位置，而是“执行”的位置。</strong></p>
<p>在箭头函数的特殊规则下，它向外找的“父级作用域”确实是全局的 <code>window</code>。</p>
<p>我们来一步步拆解为什么会出现这种情况：</p>
<h3 id="1-区分“定义”和“执行”"><a href="#1-区分“定义”和“执行”" class="headerlink" title="1. 区分“定义”和“执行”"></a>1. 区分“定义”和“执行”</h3><p>请看下面这段代码，思考 <code>this</code> 指向谁：</p>
<pre><code class="javascript">const obj = &#123;
    name: &#39;我是obj&#39;,
    // 这里只是把函数定义好，存进去了，并没有运行
    sayHello: function() &#123;
        console.log(this.name); 
    &#125;
&#125;

// 这里才是函数真正被执行的时候
// 谁调用的？是 obj.sayHello() 调用的，所以 this 指向 obj。
obj.sayHello(); 
</code></pre>
<p>回到你的 Vue 代码：</p>
<ul>
<li><strong>定义时</strong>：你在 <code>new Vue(&#123;...&#125;)</code> 的大括号里写了箭头函数。此时，这段代码处于<strong>全局作用域</strong>（或者模块作用域）中。</li>
<li><strong>执行时</strong>：Vue 底层拿到你传入的对象后，会去执行这个 <code>data</code> 函数。</li>
</ul>
<p>对于<strong>普通函数</strong>，Vue 可以通过 <code>.call()</code> 或 <code>.apply()</code> 强行指定它的 <code>this</code> 是 Vue 实例。<br>对于<strong>箭头函数</strong>，它没有自己的 <code>this</code>，它会忽略 Vue 的调用方式，直接去“捕获”它<strong>定义时</strong>所在环境的 <code>this</code>。</p>
<h3 id="2-箭头函数的“词法绑定”规则"><a href="#2-箭头函数的“词法绑定”规则" class="headerlink" title="2. 箭头函数的“词法绑定”规则"></a>2. 箭头函数的“词法绑定”规则</h3><p>箭头函数的 <code>this</code> 遵循<strong>词法作用域</strong>。它不关心是谁调用的，只关心它<strong>写在哪儿</strong>。</p>
<p>在你的 HTML 文件中，<code>&lt;script&gt;</code> 标签里的代码属于<strong>全局作用域</strong>。</p>
<pre><code class="javascript">// 这里的环境就是全局环境
// this 指向 window (非严格模式下)
console.log(&#39;脚本顶层的this:&#39;, this); 

new Vue(&#123;
    data: () =&gt; &#123;
        // 箭头函数没有自己的 this
        // 它向外层（即 &lt;script&gt; 标签的顶层）查找
        // 所以这里的 this 就是上面打印出的 window
        console.log(&#39;箭头函数里的this:&#39;, this); 
        return &#123;&#125;
    &#125;
&#125;)
</code></pre>
<h3 id="3-为什么普通函数就没问题？"><a href="#3-为什么普通函数就没问题？" class="headerlink" title="3. 为什么普通函数就没问题？"></a>3. 为什么普通函数就没问题？</h3><p>普通函数（function）的 <code>this</code> 是<strong>动态绑定</strong>的，取决于“谁调用了我”。</p>
<p>Vue 源码内部大致是这样处理的：</p>
<pre><code class="javascript">// 伪代码
const vm = new Vue(options);
// Vue 拿到你传入的 data 函数，并用 call 方法调用它
// 这里的 this 就被强行指向了 vm（Vue 实例）
options.data.call(vm); 
</code></pre>
<p>因为普通函数的 <code>this</code> 是由调用者（<code>vm</code>）决定的，所以能正确指向 Vue 实例。而箭头函数<strong>无法被 <code>call</code> 或 <code>bind</code> 改变 <code>this</code> 指向</strong>，它死死地绑定了定义时的 <code>window</code>。</p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>虽然看起来箭头函数是写在 <code>new Vue(&#123;...&#125;&#125;)</code> 里面的，但在 JavaScript 引擎看来：</p>
<ol>
<li><strong>定义位置</strong>：它处于全局 <code>&lt;script&gt;</code> 环境中。</li>
<li><strong>父级作用域</strong>：它的父级就是全局作用域，也就是 <code>window</code>。</li>
<li><strong>结果</strong>：箭头函数会把 <code>this</code> 永久地绑定为 <code>window</code>，无论 Vue 怎么调用它，都无法改变。</li>
</ol>
<hr>
<h2 id="箭头函数无法被-call-或-bind-改变-this-指向是因为他是匿名函数"><a href="#箭头函数无法被-call-或-bind-改变-this-指向是因为他是匿名函数" class="headerlink" title="箭头函数无法被 call 或 bind 改变 this 指向是因为他是匿名函数?"></a>箭头函数无法被 call 或 bind 改变 this 指向是因为他是匿名函数?</h2><p>不是的，这两者没有直接关系。<strong>“是否是匿名函数”与“this指向能否被改变”无关</strong>。</p>
<p>箭头函数无法被 <code>call</code> 或 <code>bind</code> 改变 <code>this</code> 指向，根本原因在于它的<strong>设计机制</strong>：**箭头函数没有自己的 <code>this</code>**。</p>
<p>为了让你彻底理解，我来拆解一下这两者的逻辑：</p>
<h3 id="1-核心原因：箭头函数没有“this”"><a href="#1-核心原因：箭头函数没有“this”" class="headerlink" title="1. 核心原因：箭头函数没有“this”"></a>1. 核心原因：箭头函数没有“this”</h3><p>普通函数（无论具名还是匿名）在被调用时，JavaScript 引擎会为它创建一个执行上下文，并绑定一个 <code>this</code>。这个 <code>this</code> 可以被 <code>call</code>、<code>apply</code> 或 <code>bind</code> 强行修改。</p>
<p>而箭头函数不同，它**根本不去创建自己的 <code>this</code>**。它在定义时，就通过“词法作用域”直接“继承”了外层（父级）作用域的 <code>this</code>。</p>
<p>既然它内部没有属于自己的 <code>this</code>，<code>call</code> 和 <code>bind</code> 就没有东西可以去“修改”。你传入的参数（<code>thisArg</code>）会被它直接忽略。</p>
<h3 id="2-为什么说和“匿名”无关？"><a href="#2-为什么说和“匿名”无关？" class="headerlink" title="2. 为什么说和“匿名”无关？"></a>2. 为什么说和“匿名”无关？</h3><p><strong>匿名函数</strong>只是指“没有名字的函数”。普通函数也可以是匿名的，而匿名的普通函数完全可以被 <code>call</code> 改变 <code>this</code>。</p>
<p><strong>反例证明：</strong><br>下面这段代码是一个<strong>匿名的普通函数</strong>，你看它是可以被 <code>call</code> 改变 <code>this</code> 的：</p>
<pre><code class="javascript">// 这是一个匿名函数（没有名字），也是一个普通function
const normalAnon = function() &#123;
    console.log(this.name);
&#125;;

// 虽然是匿名的，但是 call 完全生效！
normalAnon.call(&#123;name: &#39;我是Call改变的&#39;&#125;); // 输出: 我是Call改变的
</code></pre>
<p><strong>结论：</strong><br>只要是<strong>普通函数</strong>（哪怕没有名字），它就有 <code>this</code>，就能被改变。<br>只要是<strong>箭头函数</strong>（哪怕你给它赋值给一个变量），它就没有 <code>this</code>，就不能被改变。</p>
<h3 id="3-一个简单的类比"><a href="#3-一个简单的类比" class="headerlink" title="3. 一个简单的类比"></a>3. 一个简单的类比</h3><p>你可以把普通函数想象成<strong>“租房客”</strong>，<code>call</code> 就像是中介，可以强行把租房客塞进不同的房子里（改变 <code>this</code>）。</p>
<p>而箭头函数就像是<strong>“跟屁虫”</strong>，它没有自己的家，它永远紧紧跟着它爸爸（外层作用域）。无论中介（<code>call</code>）怎么折腾它，它都死死抓着它爸爸不放，根本不住进你给它的新房子里。</p>
<hr>
<h2 id="MVVM模型"><a href="#MVVM模型" class="headerlink" title="MVVM模型"></a>MVVM模型</h2><blockquote>
<p>MVVM模型<br>                        1. M：模型(Model) ：data中的数据<br>                        2. V：视图(View) ：模板代码<br>                        3. VM：视图模型(ViewModel)：Vue实例<br>            观察发现：<br>                        1.data中所有的属性，最后都出现在了vm身上。<br>                        2.vm身上所有的属性 及 Vue原型上所有属性，在Vue模板中都可以直接使用。</p>
</blockquote>
<pre><code class="html">&lt;!doctype html&gt;
&lt;html lang=&quot;en&quot;&gt;
&lt;head&gt;
    &lt;meta charset=&quot;UTF-8&quot;&gt;
    &lt;meta name=&quot;viewport&quot;
          content=&quot;width=device-width, user-scalable=no, initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0&quot;&gt;
    &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;ie=edge&quot;&gt;
    &lt;title&gt;mvvm模型的理解&lt;/title&gt;
    &lt;script src=&quot;../js/vue.js&quot;&gt;&lt;/script&gt;
&lt;/head&gt;
&lt;body&gt;
    &lt;div id=&quot;root&quot;&gt;
        &lt;!--view--&gt;
        &lt;h1&gt;学校名称: &#123;&#123; name &#125;&#125; &lt;/h1&gt; &lt;hr/&gt;
        &lt;h1&gt;学校地址:&#123;&#123; address &#125;&#125; &lt;/h1&gt; &lt;hr/&gt;
        &lt;h1&gt;测试一下1:  &#123;&#123; 1 + 1 &#125;&#125; &lt;/h1&gt; &lt;hr/&gt;
        &lt;!--所有viewModel和vue原型上的属性在视图中的&#123;&#123;&#125;&#125;都可以看到-->
        <h1>测试一下2: &#123;&#123; $options &#125;&#125; &lt;/h1&gt; &lt;hr/&gt; 
        &lt;h1&gt;测试一下3: &#123;&#123; $emit &#125;&#125; &lt;/h1&gt; &lt;hr/&gt;
        &lt;h1&gt;测试一下4: &#123;&#123; _c &#125;&#125; &lt;/h1&gt; &lt;hr/&gt;
    &lt;/div&gt;
    &lt;script type=&quot;text/javascript&quot;&gt;
        //view model view与model之间的纽带
        //vm view实例对象
        const vm =  new Vue(&#123;
            el: &#39;#root&#39;,
            data()&#123;
                //model
                return &#123;
                    name:&#39;武汉科技大学&#39;,
                    address: &#39;武汉&#39;
                &#125;
            &#125;
        &#125;);
        console.log(vm);
    &lt;/script&gt;
&lt;/body&gt;
&lt;/html&gt;
</h1></code></pre>
<p>运行效果: </p>
<p><img src="/2026/01/19/vue-learning/image-20260120104546910.png" alt="image-20260120104546910"></p>
<blockquote>
<p>MVVM 其实就是一种让网页开发更高效的“分工协作”模式。结合你提供的代码来看，它把页面拆解为三个明确的角色，让数据和界面各司其职，又能自动同步。</p>
</blockquote>
<p>我们可以用你代码中的例子来具体拆解这三个部分：</p>
<h3 id="🧱-M-模型"><a href="#🧱-M-模型" class="headerlink" title="🧱 M - 模型"></a>🧱 M - 模型</h3><ul>
<li><p><strong>是什么</strong>：对应你代码中的 <code>data</code> 函数返回的对象。</p>
</li>
<li><p><strong>职责</strong>：它就是纯粹的数据，不包含任何 HTML 标签或样式。</p>
</li>
<li><p><strong>例子</strong>：</p>
<pre><code class="javascript">data()&#123;
  return &#123;
    name: &#39;武汉科技大学&#39;, // 学校名字数据
    address: &#39;武汉&#39;         // 学校地址数据
  &#125;
&#125;
</code></pre>
<p>这就是模型。它只负责存储和管理数据。</p>
</li>
</ul>
<h3 id="🎨-V-视图"><a href="#🎨-V-视图" class="headerlink" title="🎨 V - 视图"></a>🎨 V - 视图</h3><ul>
<li><p><strong>是什么</strong>：对应你代码中的 <code>&lt;div id=&quot;root&quot;&gt;</code> 里的 HTML 模板。</p>
</li>
<li><p><strong>职责</strong>：它是用户看到的界面。它负责决定数据长什么样。</p>
</li>
<li><p><strong>例子</strong>：</p>
<pre><code class="html">&lt;h1&gt;学校名称: &#123;&#123; name &#125;&#125;&lt;/h1&gt;
&lt;h1&gt;学校地址: &#123;&#123; address &#125;&#125;&lt;/h1&gt;
</code></pre>
<p>这就是视图。它只负责展示，它通过 </p>
<pre><code>&#123;&#123; &#125;&#125;
</code></pre>
<p> 告诉系统：“我要在这里显示 </p>
<pre><code>name
</code></pre>
<p> 和 </p>
<pre><code>address
</code></pre>
<p> 的值”。</p>
</li>
</ul>
<h3 id="🔄-VM-视图模型"><a href="#🔄-VM-视图模型" class="headerlink" title="🔄 VM - 视图模型"></a>🔄 VM - 视图模型</h3><ul>
<li><p><strong>是什么</strong>：对应你代码中的 <code>new Vue(&#123;&#125;)</code> 实例（也就是 <code>vm</code> 对象）。</p>
</li>
<li><p><strong>职责</strong>：它是连接 <code>M</code> 和 <code>V</code> 的纽带（桥梁）。它的核心任务是监听数据变化，并自动更新界面；或者监听用户操作（如点击、输入），并自动更新数据。</p>
</li>
<li><p><strong>例子</strong>：</p>
<pre><code class="javascript">const vm = new Vue(&#123;
  el: &#39;#root&#39;, // 指定控制哪个区域
  data()&#123; ... &#125; // 提供数据
&#125;);
</code></pre>
<p><strong>Vue 实例（VM）内部使用了数据劫持（Object.defineProperty 或 Proxy）和发布订阅模式。它会默默地盯着 data 里的数据（M），一旦数据变了（比如 data 改了），它就立刻通过 el 找到视图（V），把页面上对应的  刷新成新的值。</strong></p>
</li>
</ul>
<h3 id="🚀-核心优势：双向绑定"><a href="#🚀-核心优势：双向绑定" class="headerlink" title="🚀 核心优势：双向绑定"></a>🚀 核心优势：双向绑定</h3><p>MVVM 最大的魅力在于<strong>“自动同步”</strong>。</p>
<p>在传统的开发（如原生 JS）中，你需要手动操作 DOM：</p>
<ol>
<li>数据变了 -&gt; 2. 找到 DOM 元素 -&gt; 3. 修改 innerHTML。</li>
</ol>
<p>而在 MVVM 中，这一切都被 VM 搞定了：</p>
<ol>
<li>数据（M）变了 -&gt; 2. VM 监听到 -&gt; 3. 自动更新视图（V）。</li>
</ol>
<p>你只需要关心数据（M），视图（V）会自动跟着变。这就是所谓的<strong>数据驱动视图</strong>。</p>
<h3 id="🔍-补充：你代码中注释的那两点观察"><a href="#🔍-补充：你代码中注释的那两点观察" class="headerlink" title="🔍 补充：你代码中注释的那两点观察"></a>🔍 补充：你代码中注释的那两点观察</h3><p>你的代码注释中提到了两个非常关键的细节，这正是 Vue 实现 MVVM 的具体表现：</p>
<ul>
<li><strong><code>data</code> 中所有的属性，最后都出现在了 vm 身上</strong>： Vue 把 <code>data</code> 里的数据代理到了 Vue 实例（vm）上。所以你既可以用 <code>vm.$data.name</code> 访问，也可以直接用 <code>vm.name</code> 访问。</li>
<li><strong>vm 身上所有的属性及 Vue 原型上所有属性，在 Vue 模板中都可以直接使用</strong>： 这就是为什么你在 <code>&#123;&#123; &#125;&#125;</code> 里可以直接写 <code>1+1</code>，或者直接调用 Vue 实例上的方法（如 <code>$emit</code>）。因为模板里的代码是在 Vue 实例的上下文中执行的，<code>this</code> 指向的就是 VM。</li>
</ul>
<h3 id="📌-总结"><a href="#📌-总结" class="headerlink" title="📌 总结"></a>📌 总结</h3><ul>
<li><strong>M</strong>：就是数据（<code>data</code>）。</li>
<li><strong>V</strong>：就是页面（HTML）。</li>
<li><strong>VM</strong>：就是 Vue 实例（<code>new Vue()</code>），它让 M 和 V 保持同步，开发者无需手动操作 DOM。</li>
</ul>
<hr>
<h2 id="数据代理-Object-defineProperty方法"><a href="#数据代理-Object-defineProperty方法" class="headerlink" title="数据代理-Object.defineProperty方法"></a>数据代理-Object.defineProperty方法</h2><pre><code class="html">&lt;!doctype html&gt;
&lt;html lang=&quot;en&quot;&gt;
&lt;head&gt;
    &lt;meta charset=&quot;UTF-8&quot;&gt;
    &lt;meta name=&quot;viewport&quot;
          content=&quot;width=device-width, user-scalable=no, initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0&quot;&gt;
    &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;ie=edge&quot;&gt;
    &lt;title&gt;Object.defineProperty&lt;/title&gt;
&lt;/head&gt;
&lt;body&gt;
   &lt;script type=&quot;text/javascript&quot;&gt;
       let number = 18;
       let person = &#123;
           name: &#39;张三&#39;,
           sex:&#39;男&#39;
       &#125;

       //此时age是不可以枚举的
       //往person对象里添加属性
       //关联
       Object.defineProperty(person,&#39;age&#39;, &#123;
           // value: 18,
           // enumerable: true, //此时代表这个属性是可以枚举的
           // writable: true, //代表可以重写该属性(控制属性是否被修改)
           // configurable:true, //控制属性是否可以被删除 默认为false


           //当读取person的age属性时get属性就会被调用，且返回值就是age的值
           //invoke property proxy映射数据代理
           get: function () &#123;
               //测试它的调用情况
               console.log(&#39;@@@ GET AGE&#39;);
               //此时age的值依赖number的值
               return number
           &#125;,
           //当修改person的age属性时set(setter)属性就会被调用，且会收到修改的具体值
           set(v) &#123;
               //测试
               console.log(&#39;CHANGE AGE&#39;);
               number=v;
           &#125;
       &#125;);

       // console.log(Object.keys(person))

       //遍历
       // for(var p  in  person)&#123;
       //     console.log(&#39;@@&#39;, person[p])
       // &#125;



       console.log(person);
   &lt;/script&gt;
&lt;/body&gt;
&lt;/html&gt;
</code></pre>
<p><code>Object.defineProperty()</code> 是 JavaScript 中一个非常底层且强大的方法，你可以把它理解为给对象属性装上了一个<strong>“智能监控探头”</strong>（或者叫“拦截器”）。</p>
<p>在你的代码中，它不仅仅是在给 <code>person</code> 对象添加一个 <code>age</code> 属性，而是在<strong>定义一种关系</strong>：当你<strong>读</strong>这个属性时，执行什么逻辑；当你<strong>写</strong>这个属性时，执行什么逻辑。</p>
<p>结合你的代码，我来为你拆解这个概念：</p>
<h3 id="1-核心概念：它不只是赋值"><a href="#1-核心概念：它不只是赋值" class="headerlink" title="1. 核心概念：它不只是赋值"></a>1. 核心概念：它不只是赋值</h3><p>通常我们给对象加属性是这样做的：</p>
<pre><code class="javascript">person.age = 18; // 简单粗暴，存进去一个死数据
</code></pre>
<p>这种方式存进去的只是一个<strong>静态值</strong>。</p>
<p>而 <code>Object.defineProperty</code> 是这样做的：</p>
<pre><code class="javascript">Object.defineProperty(person, &#39;age&#39;, &#123; /* 描述符 */ &#125;);
</code></pre>
<p>它允许你通过<strong>描述符</strong>（Descriptor）对象，精确地控制这个属性的行为。它就像是给 <code>age</code> 属性立了一份“合同”，规定了读写时的规则。</p>
<h3 id="2-你的代码解析：数据劫持与代理"><a href="#2-你的代码解析：数据劫持与代理" class="headerlink" title="2. 你的代码解析：数据劫持与代理"></a>2. 你的代码解析：数据劫持与代理</h3><p>你的代码实现了一个非常经典的<strong>数据代理</strong>（Data Proxy）效果。我们来看这份“合同”是怎么签的：</p>
<h4 id="属性的“读取”监控-get"><a href="#属性的“读取”监控-get" class="headerlink" title="属性的“读取”监控 (get)"></a><strong>属性的“读取”监控 (get)</strong></h4><pre><code class="javascript">get: function () &#123;
    console.log(&#39;@@@ GET AGE&#39;); // 只要读age，这句话就会打印
    return number; // 实际返回的是外部变量 number 的值
&#125;
</code></pre>
<ul>
<li><strong>含义</strong>：你告诉 JavaScript：“每当有人问 <code>person.age</code> 是多少时，请不要直接拿内存里的值，而是先执行这个 <code>get</code> 函数，并把它的返回值当作 <code>age</code> 的值。”</li>
<li><strong>效果</strong>：<code>person.age</code> 的值不再是固定的，而是<strong>动态计算</strong>出来的（它依赖于 <code>number</code> 变量）。</li>
</ul>
<h4 id="属性的“修改”监控-set"><a href="#属性的“修改”监控-set" class="headerlink" title="属性的“修改”监控 (set)"></a><strong>属性的“修改”监控 (set)</strong></h4><pre><code class="javascript">set(v) &#123;
    console.log(&#39;CHANGE AGE&#39;); // 只要改age，这句话就会打印
    number = v; // 把新值 v 存到外部变量 number 里
&#125;
</code></pre>
<ul>
<li><strong>含义</strong>：你告诉 JavaScript：“每当有人试图修改 <code>person.age</code> 时，请执行这个 <code>set</code> 函数，并把用户赋的新值传进来。”</li>
<li><strong>效果</strong>：修改 <code>person.age</code> 并不会直接改变 <code>person</code> 内部的某个私有字段，而是改变了外部的 <code>number</code> 变量。</li>
</ul>
<h3 id="3-为什么遍历不到-age？"><a href="#3-为什么遍历不到-age？" class="headerlink" title="3. 为什么遍历不到 age？"></a>3. 为什么遍历不到 age？</h3><p>你在代码中写了：</p>
<pre><code class="javascript">console.log(Object.keys(person)) // 结果是 [&#39;name&#39;, &#39;sex&#39;]
</code></pre>
<p>你会发现 <code>age</code> 不在其中。这是 <code>Object.defineProperty</code> 的另一个特性：<strong>默认配置</strong>。</p>
<p>如果不显式设置，通过 <code>defineProperty</code> 定义的属性默认是<strong>不可枚举</strong>的（<code>enumerable: false</code>）。</p>
<ul>
<li><strong>不可枚举</strong>意味着：它不会出现在 <code>for...in</code> 循环、<code>Object.keys()</code>、<code>JSON.stringify()</code> 的结果中。</li>
<li><strong>潜台词</strong>：这个属性是“隐藏”的，虽然你可以通过 <code>person.age</code> 访问它，但程序遍历对象时会假装看不见它。</li>
</ul>
<h3 id="4-形象的比喻"><a href="#4-形象的比喻" class="headerlink" title="4. 形象的比喻"></a>4. 形象的比喻</h3><p>你可以把 <code>Object.defineProperty</code> 想象成<strong>房产中介</strong>：</p>
<ol>
<li><strong>普通属性</strong>：就像你直接把房子钥匙给了别人（直接访问内存地址）。</li>
<li><strong>defineProperty 属性</strong>：你把房子钥匙锁在自己手里，告诉中介（<code>get/set</code>）：“有人要看房（get），你带他去；有人要改装修（set），你告诉我”。</li>
</ol>
<p>在你的代码里：</p>
<ul>
<li><code>number</code> 是真正的房子（数据源）。</li>
<li><code>person.age</code> 是一个挂牌（虚拟属性）。</li>
<li><code>get/set</code> 是中介。</li>
<li>当你问 <code>person.age</code> 时，中介跑去 <code>number</code> 那里拿数据给你。</li>
<li>当你改 <code>person.age</code> 时，中介把新数据存回 <code>number</code>。</li>
</ul>
<h3 id="5-它的实战意义（Vue-2-的核心）"><a href="#5-它的实战意义（Vue-2-的核心）" class="headerlink" title="5. 它的实战意义（Vue 2 的核心）"></a>5. 它的实战意义（Vue 2 的核心）</h3><p>你在学习 Vue，这个概念至关重要。<strong>Vue 2 的响应式原理就是基于 <code>Object.defineProperty</code> 实现的。</strong></p>
<ul>
<li><strong>依赖收集</strong>：当模板渲染读取 <code>person.age</code> 时，<code>get</code> 被触发，Vue 知道“哦，这个视图依赖了 age”。</li>
<li><strong>派发更新</strong>：当数据改变（<code>set</code> 被触发）时，Vue 知道“age 变了”，于是通知所有依赖它的视图去重新渲染。</li>
</ul>
<hr>
<h2 id="数据代理-何为数据代理"><a href="#数据代理-何为数据代理" class="headerlink" title="数据代理-何为数据代理?"></a>数据代理-何为数据代理?</h2><pre><code class="html">&lt;!doctype html&gt;
&lt;html lang=&quot;en&quot;&gt;
&lt;head&gt;
    &lt;meta charset=&quot;UTF-8&quot;&gt;
    &lt;meta name=&quot;viewport&quot;
          content=&quot;width=device-width, user-scalable=no, initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0&quot;&gt;
    &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;ie=edge&quot;&gt;
    &lt;title&gt;定义数据代理&lt;/title&gt;
&lt;/head&gt;
&lt;body&gt;
    &lt;!-- 数据代理，通过一个对象代理另一个对象中属性的操作  --&gt;
    &lt;script type=&quot;text/javascript&quot;&gt;
        let obj = &#123; x:200 &#125;
        let obj2 = &#123; y:200 &#125;
        //通过obj2代理obj，来操作obj的x
        Object.defineProperty(obj2, &#39;x&#39;,&#123;
            get()&#123;
                return obj.x
            &#125;,
            set(v)&#123;
                obj.x = v;
            &#125;
        &#125;);

    &lt;/script&gt;
&lt;/body&gt;
&lt;/html&gt;
</code></pre>
<p><strong>数据代理就是：找一个“替身”（代理对象），让你通过这个替身去操作另一个对象（目标对象）的属性。</strong></p>
<p>在你的代码中，<code>obj2</code> 就是那个“替身”（代理），<code>obj</code> 是真正的“本人”（目标）。你表面上是在操作 <code>obj2.x</code>，实际上是在读写 <code>obj.x</code>。</p>
<h3 id="🧩-代码拆解：它是如何工作的？"><a href="#🧩-代码拆解：它是如何工作的？" class="headerlink" title="🧩 代码拆解：它是如何工作的？"></a>🧩 代码拆解：它是如何工作的？</h3><p>让我们看看你的代码是如何实现这个“替身”机制的：</p>
<pre><code class="javascript">let obj = &#123; x: 200 &#125;      // 目标对象（真正的数据持有者）
let obj2 = &#123; y: 200 &#125;     // 代理对象（替身）
</code></pre>
<p>这里我们有两个独立的对象。现在，我们通过 <code>Object.defineProperty</code> 给 <code>obj2</code> 装上一个“监控器”：</p>
<ol>
<li><p>**定义读取行为 (<code>get</code>)**：</p>
<pre><code class="javascript">get()&#123;
    return obj.x // 当你问 obj2.x 时，它实际上去问 obj.x
&#125;
</code></pre>
<ul>
<li><strong>效果</strong>：当你访问 <code>obj2.x</code> 时，JavaScript 会执行这里的 <code>get</code> 函数，它会去 <code>obj</code> 那里把 <code>x</code> 的值拿回来。</li>
<li><strong>比喻</strong>：你问替身“你的年龄是多少？”，替身转身去问本人，然后把本人的答案告诉你。</li>
</ul>
</li>
<li><p>**定义修改行为 (<code>set</code>)**：</p>
<pre><code class="javascript">set(v)&#123;
    obj.x = v; // 当你修改 obj2.x 时，它实际上修改的是 obj.x
&#125;
</code></pre>
<ul>
<li><strong>效果</strong>：当你给 <code>obj2.x</code> 赋值（比如 <code>obj2.x = 300</code>）时，JavaScript 会执行这里的 <code>set</code> 函数，它会把新值存入 <code>obj.x</code>。</li>
<li><strong>比喻</strong>：你告诉替身“把你的年龄改成30”，替身转身去把本人的年龄改成了30。</li>
</ul>
</li>
</ol>
<h3 id="🎬-生活中的比喻"><a href="#🎬-生活中的比喻" class="headerlink" title="🎬 生活中的比喻"></a>🎬 生活中的比喻</h3><p>想象一下<strong>“明星”</strong>和<strong>“经纪人”</strong>的关系：</p>
<ul>
<li>**目标对象 (<code>obj</code>)**：大牌明星（真正的数据源）。</li>
<li>**代理对象 (<code>obj2</code>)**：明星的经纪人（代理）。</li>
<li><strong>你</strong>：应用程序。</li>
</ul>
<p>当你想知道明星的行程（数据）时，你<strong>不直接联系明星</strong>（<code>obj</code>），而是联系经纪人（<code>obj2</code>）。</p>
<ul>
<li><strong>读取</strong>：你问经纪人：“明星明天在哪？” 经纪人（<code>get</code>）去查明星的日程表，然后告诉你。</li>
<li><strong>修改</strong>：你告诉经纪人：“把明星明天的行程改到上海。” 经纪人（<code>set</code>）去修改明星的日程表。</li>
</ul>
<p><strong>你操作的一直是经纪人，但你影响的却是明星。</strong> 这就是数据代理。</p>
<h3 id="💡-为什么要用数据代理？（Vue-的视角）"><a href="#💡-为什么要用数据代理？（Vue-的视角）" class="headerlink" title="💡 为什么要用数据代理？（Vue 的视角）"></a>💡 为什么要用数据代理？（Vue 的视角）</h3><p>在 Vue 2 中，这个机制被用来实现<strong>响应式系统</strong>：</p>
<ol>
<li><strong>数据劫持</strong>：Vue 把你的 <code>data</code> 对象（<code>obj</code>）里的所有属性，通过 <code>Object.defineProperty</code> 代理到了 Vue 实例（<code>vm</code> / <code>obj2</code>）上。</li>
<li><strong>监听变化</strong>：因为有了 <code>get</code> 和 <code>set</code>，Vue 就能在你<strong>读数据时</strong>（<code>get</code>）知道“哦，这个组件依赖了这个数据”，在你<strong>改数据时</strong>（<code>set</code>）知道“哦，数据变了，我要去更新页面”。</li>
</ol>
<hr>
<h2 id="vue中的数据代理"><a href="#vue中的数据代理" class="headerlink" title="vue中的数据代理"></a>vue中的数据代理</h2><blockquote>
<p>1.Vue中的数据代理：<br>                            通过vm对象来代理data对象中属性的操作（读/写）<br>                2.Vue中数据代理的好处：<br>                            更加方便的操作data中的数据<br>                3.基本原理：<br>                            通过Object.defineProperty()把data对象中所有属性添加到vm上。<br>                            为每一个添加到vm上的属性，都指定一个getter/setter。<br>                            在getter/setter内部去操作（读/写）data中对应的属性。                </p>
</blockquote>
<pre><code class="html">&lt;!doctype html&gt;
&lt;html lang=&quot;en&quot;&gt;
&lt;head&gt;
    &lt;meta charset=&quot;UTF-8&quot;&gt;
    &lt;meta name=&quot;viewport&quot;
          content=&quot;width=device-width, user-scalable=no, initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0&quot;&gt;
    &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;ie=edge&quot;&gt;
    &lt;title&gt;vue中的数据代理&lt;/title&gt;
    &lt;script src=&quot;../js/vue.js&quot;&gt;&lt;/script&gt;
&lt;/head&gt;
&lt;body&gt;
     &lt;div id=&quot;root&quot;&gt;
         &lt;h2&gt;学校名称:&#123;&#123; name &#125;&#125;&lt;/h2&gt;
         &lt;h2&gt;学校地址: &#123;&#123; address &#125;&#125;&lt;/h2&gt;
     &lt;/div&gt;
    &lt;script type=&quot;text/javascript&quot;&gt;
        Vue.config.productionTip = false;
        let data;
        //通过vm代理
        const vm = new Vue(&#123;
           el:&#39;#root&#39;,
            //vm._data === options.data = data
            //
           data()&#123;
               return data = &#123;
                   name:&#39;panyue&#39;,
                   address:&#39;shanghai&#39;
               &#125;
           &#125;
        &#125;);
    &lt;/script&gt;
&lt;/body&gt;
&lt;/html&gt;
</code></pre>
<p>Vue 2 的数据代理机制确实就是这么运作的。</p>
<p>结合你的代码，我们可以把这个过程看作是 Vue 在 <code>vm</code>（Vue 实例）和 <code>data</code>（数据源）之间搭建了一座“隐形桥梁”。下面我来配合代码，一步步拆解你列出的这三个点：</p>
<h3 id="🎭-什么是数据代理？"><a href="#🎭-什么是数据代理？" class="headerlink" title="🎭 什么是数据代理？"></a>🎭 什么是数据代理？</h3><p><strong>定义</strong>：通过 <code>vm</code> 对象来代理对 <code>data</code> 对象中属性的操作（读/写）。</p>
<p>在你的代码中：</p>
<ul>
<li><strong>目标对象（真正的数据）</strong>：<code>data</code> 变量（值为 <code>&#123; name: &#39;panyue&#39;, address: &#39;shanghai&#39; &#125;</code>）。</li>
<li><strong>代理对象（替身）</strong>：<code>vm</code>（Vue 实例）。</li>
</ul>
<p><strong>现象</strong>：</p>
<ul>
<li>你<strong>模板</strong>中写的是 <code>&#123;&#123; name &#125;&#125;</code>（看起来像是在找 <code>vm</code> 要 <code>name</code>）。</li>
<li>你<strong>脚本</strong>中写的是 <code>vm.name = &#39;new&#39;</code>。</li>
<li>但实际上，<code>name</code> 属性原本并不属于 <code>vm</code>，它属于 <code>data</code>。<code>vm</code> 只是充当了“中间人”。</li>
</ul>
<h3 id="🌉-基本原理：Object-defineProperty-的魔法"><a href="#🌉-基本原理：Object-defineProperty-的魔法" class="headerlink" title="🌉 基本原理：Object.defineProperty 的魔法"></a>🌉 基本原理：<code>Object.defineProperty</code> 的魔法</h3><p>Vue 内部在初始化时，大致做了这么一件事（模拟源码逻辑）：</p>
<pre><code class="javascript">// 1. 拿到你的 data
let data = &#123; name: &#39;panyue&#39;, address: &#39;shanghai&#39; &#125;;

// 2. 遍历 data 的所有属性
Object.keys(data).forEach(key =&gt; &#123;
  // 3. 把属性添加到 vm 上，并定义 get/set
  Object.defineProperty(vm, key, &#123;
    get() &#123;
      // 读取 vm.name 时，实际读取 data.name
      return data[key]; 
    &#125;,
    set(newValue) &#123;
      // 修改 vm.name 时，实际修改 data.name
      data[key] = newValue; 
    &#125;
  &#125;);
&#125;);
</code></pre>
<p><strong>发生了什么？</strong></p>
<ul>
<li>当你访问 <code>vm.name</code> 时，触发了 <code>get</code>，它去 <code>data</code> 里取值。</li>
<li>当你修改 <code>vm.name = &#39;hello&#39;</code> 时，触发了 <code>set</code>，它去 <code>data</code> 里改值。</li>
</ul>
<h3 id="🤔-为什么要这么做？（好处）"><a href="#🤔-为什么要这么做？（好处）" class="headerlink" title="🤔 为什么要这么做？（好处）"></a>🤔 为什么要这么做？（好处）</h3><p>你提到“方便操作数据”，这不仅仅是少打几个字，而是有更深层的设计考量：</p>
<ol>
<li><strong>模板中无需前缀</strong>：<ul>
<li>如果没有代理，你在模板里可能得写 <code>&#123;&#123; data.name &#125;&#125;</code>。</li>
<li>有了代理，直接写 <code>&#123;&#123; name &#125;&#125;</code>，代码更简洁，语义更清晰。</li>
</ul>
</li>
<li><strong>统一上下文</strong>：<ul>
<li>在 Vue 的 <code>methods</code>、<code>computed</code> 中，<code>this</code> 指向 <code>vm</code>。</li>
<li>因为有了代理，你直接用 <code>this.name</code> 就能拿到数据，不需要去查文档或者记混该用 <code>this.$data.name</code> 还是 <code>this.name</code>。</li>
</ul>
</li>
<li><strong>实现响应式的基础（最关键！）</strong>：<ul>
<li>代理层（<code>get/set</code>）是 Vue 的“监控室”。</li>
<li><strong>依赖收集</strong>：在 <code>get</code> 里，Vue 知道“哦，这个视图用到了这个数据”。</li>
<li><strong>派发更新</strong>：在 <code>set</code> 里，Vue 知道“哦，数据变了，我要去通知视图更新”。</li>
</ul>
</li>
</ol>
<h3 id="🔍-验证一下"><a href="#🔍-验证一下" class="headerlink" title="🔍 验证一下"></a>🔍 验证一下</h3><p>你可以试着在你的代码后面加上这几行，看看代理的“痕迹”：</p>
<pre><code class="javascript">// 1. 证明 vm 代理了 data
console.log(vm.name); // &#39;panyue&#39; (直接通过 vm 读取)

// 2. 修改 vm 的属性，实际上修改了 data
vm.name = &#39;changed&#39;;
console.log(data.name); // &#39;changed&#39; (data 被同步修改了)

// 3. 查看 vm 的属性描述符
// 你会发现 vm.name 是一个访问器属性 (有 get/set)，而不是一个数据属性
console.log(Object.getOwnPropertyDescriptor(vm, &#39;name&#39;));
</code></pre>
<p><strong>总结：</strong><br>Vue 通过 <code>Object.defineProperty</code> 把 <code>data</code> 的属性“映射”到了 <code>vm</code> 上，让你感觉数据就在 <code>vm</code> 上一样。这既方便了开发者，又让 Vue 有机会在底层监听所有的数据变动，从而实现视图的自动更新。</p>
<hr>
<h2 id="事件处理-键盘事件"><a href="#事件处理-键盘事件" class="headerlink" title="事件处理-键盘事件"></a>事件处理-键盘事件</h2><p>1.Vue中常用的按键别名：<br>                回车 =&gt; enter<br>                删除 =&gt; delete (捕获“删除”和“退格”键)<br>                退出 =&gt; esc<br>                空格 =&gt; space<br>                换行 =&gt; tab (特殊，必须配合keydown去使用)<br>                上 =&gt; up<br>                下 =&gt; down<br>                左 =&gt; left<br>                右 =&gt; right</p>
<p>2.Vue未提供别名的按键，可以使用按键原始的key值去绑定，但注意要转为kebab-case（短横线命名）</p>
<p>3.系统修饰键（用法特殊）：ctrl、alt、shift、meta<br>            (1).配合keyup使用：按下修饰键的同时，再按下其他键，随后释放其他键，事件才被触发。<br>            (2).配合keydown使用：正常触发事件。</p>
<p>4.也可以使用keyCode去指定具体的按键（不推荐）</p>
<p>5.Vue.config.keyCodes.自定义键名 = 键码，可以去定制按键别名</p>
<pre><code class="html">&lt;!doctype html&gt;
&lt;html lang=&quot;en&quot;&gt;
&lt;head&gt;
    &lt;meta charset=&quot;UTF-8&quot;&gt;
    &lt;meta name=&quot;viewport&quot;
          content=&quot;width=device-width, user-scalable=no, initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0&quot;&gt;
    &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;ie=edge&quot;&gt;
    &lt;title&gt;vue 键盘事件&lt;/title&gt;
    &lt;script src=&quot;../js/vue.js&quot;&gt;&lt;/script&gt;
&lt;/head&gt;
&lt;body&gt;
  &lt;div id=&quot;root&quot;&gt;
        &lt;!--vue中键盘事件的绑定 一般用keyUp(keydown)--&gt;
        &lt;h1&gt;欢迎来到&#123;&#123; name &#125;&#125;&lt;/h1&gt;
        &lt;input type=&quot;text&quot; @keyup=&quot;showKeyInfo&quot; placeholder=&quot;按键映射---按下回车提示输入&quot;/&gt;
        &lt;input type=&quot;text&quot; @keyup.enter=&quot;showInfo&quot; placeholder=&quot;按下回车提示输入&quot;/&gt;
        &lt;input type=&quot;text&quot; @keyup.delete=&quot;showInfo&quot; placeholder=&quot;退格或删除提示输入&quot;/&gt;
        &lt;input type=&quot;text&quot; @keyup.esc=&quot;showInfo&quot; placeholder=&quot;按下esc提示输入&quot;/&gt;
        &lt;input type=&quot;text&quot; @keydown.tab=&quot;showInfo&quot; placeholder=&quot;按下tab示输入&quot;/&gt;
        &lt;input type=&quot;text&quot; @keyup.ctrl=&quot;showInfo&quot; placeholder=&quot;[ctrl]按下command提示输入&quot;/&gt;
        &lt;input type=&quot;text&quot; @keydown.p=&quot;showInfo&quot; placeholder=&quot;[ctrl]按下p提示输入&quot;/&gt;
        &lt;!--键盘事件的修饰符也可以连用--&gt;
       &lt;input type=&quot;text&quot; @keydown.command.g=&quot;showInfo&quot; placeholder=&quot;[ctrl]按下command和g提示输入&quot;/&gt;
    &lt;/div&gt;
    &lt;script type=&quot;text/javascript&quot;&gt;
        new Vue(&#123;
            el:&#39;#root&#39;,
            data:&#123;
                name: &#39;shanghai&#39;
            &#125;,
            methods:&#123;
                showKeyInfo:function (e)&#123;
                    console.log(&quot;按键名: &quot;, e.key, &quot;按键码: &quot;,  e.keyCode);
                    console.log(e.target.value);
                &#125;,
                showInfo:function (e)&#123;
                    // if(e.keyCode === 13) &#123;
                    //     console.log(e.target.value);
                    // &#125;
                    console.log(e.target.value);
                    console.log(e.key); //按下的名字
                &#125;
            &#125;
        &#125;)
    &lt;/script&gt;
&lt;/body&gt;
&lt;/html&gt;
</code></pre>
<p>这段代码完美地演示了 Vue 2 中如何优雅地处理键盘事件。Vue 对原生的 <code>keydown</code> 和 <code>keyup</code> 事件进行了增强，提供了<strong>按键别名</strong>和<strong>修饰符</strong>，让我们不再需要死记硬背 <code>keyCode</code>。</p>
<p>结合你的代码和注释，我来为你梳理一下 Vue 键盘事件的核心要点：</p>
<h3 id="🧱-基础用法"><a href="#🧱-基础用法" class="headerlink" title="🧱 基础用法"></a>🧱 基础用法</h3><p>绑定方式：<code>@keyup</code> 或 <code>@keydown</code></p>
<ul>
<li>**<code>@keyup</code>**：释放按键时触发。</li>
<li>**<code>@keydown</code>**：按下按键时触发（不放会一直触发）。</li>
</ul>
<h3 id="🏷️-常用按键别名"><a href="#🏷️-常用按键别名" class="headerlink" title="🏷️ 常用按键别名"></a>🏷️ 常用按键别名</h3><p>Vue 为常用的按键提供了别名，直接通过 <code>.</code> 调用，无需记忆 keyCode。</p>
<table>
<thead>
<tr>
<th>别名</th>
<th>对应按键</th>
<th>备注</th>
</tr>
</thead>
<tbody><tr>
<td><code>.enter</code></td>
<td>回车键</td>
<td>常用于表单提交</td>
</tr>
<tr>
<td><code>.delete</code></td>
<td>删除/退格键</td>
<td>捕获 Delete 和 Backspace</td>
</tr>
<tr>
<td><code>.esc</code></td>
<td>退出键</td>
<td>常用于关闭弹窗</td>
</tr>
<tr>
<td><code>.space</code></td>
<td>空格键</td>
<td></td>
</tr>
<tr>
<td><code>.tab</code></td>
<td>制表键</td>
<td><strong>特殊</strong>：一般配合 <code>keydown</code> 使用，因为无法监听“释放 tab”</td>
</tr>
<tr>
<td><code>.up</code> / <code>.down</code> / <code>.left</code> / <code>.right</code></td>
<td>方向键</td>
<td></td>
</tr>
</tbody></table>
<h3 id="⚙️-系统修饰键-特殊用法"><a href="#⚙️-系统修饰键-特殊用法" class="headerlink" title="⚙️ 系统修饰键 (特殊用法)"></a>⚙️ 系统修饰键 (特殊用法)</h3><p>修饰键包括 <code>.ctrl</code>、<code>.alt</code>、<code>.shift</code>、<code>.meta</code> (Mac 上的 command 键)。</p>
<p>它们的触发逻辑取决于你配合的是 <code>keydown</code> 还是 <code>keyup</code>：</p>
<ul>
<li><strong>配合 <code>@keydown</code><strong>：按下修饰键时，事件</strong>正常触发</strong>。</li>
<li><strong>配合 <code>@keyup</code><strong>：必须</strong>先按住修饰键，再按其他键，最后释放其他键</strong>，事件才会触发。</li>
</ul>
<p><strong>代码示例解析：</strong></p>
<pre><code class="html">&lt;!-- 按下 command 键时，事件就会触发 --&gt;
&lt;input type=&quot;text&quot; @keydown.meta=&quot;showInfo&quot; /&gt;

&lt;!-- 必须先按住 command，再按其他键，最后松开其他键才会触发 --&gt;
&lt;input type=&quot;text&quot; @keyup.meta=&quot;showInfo&quot; /&gt;
</code></pre>
<h3 id="✨-自定义别名与连用"><a href="#✨-自定义别名与连用" class="headerlink" title="✨ 自定义别名与连用"></a>✨ 自定义别名与连用</h3><ol>
<li><p><strong>连用修饰符</strong>：<br>你可以将多个修饰符连在一起使用，表示“组合键”。</p>
<pre><code class="html">&lt;!-- 按下 command + g 才触发 --&gt;
&lt;input type=&quot;text&quot; @keydown.command.g=&quot;showInfo&quot; /&gt;
</code></pre>
</li>
<li><p><strong>自定义按键别名</strong>：<br>如果 Vue 没有提供你需要的别名（比如 F1 键），你可以通过全局配置添加：</p>
<pre><code class="javascript">// 定义一个叫 &#39;f1&#39; 的别名，对应 keyCode 112
Vue.config.keyCodes.f1 = 112;
</code></pre>
<p>然后就可以这样使用：</p>
<pre><code class="html">&lt;input type=&quot;text&quot; @keyup.f1=&quot;showInfo&quot; /&gt;
</code></pre>
</li>
</ol>
<h3 id="💡-关于-tab-键的特别说明"><a href="#💡-关于-tab-键的特别说明" class="headerlink" title="💡 关于 tab 键的特别说明"></a>💡 关于 <code>tab</code> 键的特别说明</h3><p>在你的代码中，<code>tab</code> 键必须配合 <code>keydown</code> 使用：</p>
<pre><code class="html">&lt;input type=&quot;text&quot; @keydown.tab=&quot;showInfo&quot; /&gt;
</code></pre>
<p><strong>原因</strong>：<code>tab</code> 键的主要功能是切换焦点。如果你使用 <code>@keyup.tab</code>，当用户按下 tab 并释放时，焦点已经转移到下一个元素了，此时 <code>keyup</code> 事件往往无法被正确监听到。</p>
<h3 id="📌-总结-1"><a href="#📌-总结-1" class="headerlink" title="📌 总结"></a>📌 总结</h3><p>Vue 的键盘事件修饰符极大地简化了开发体验：</p>
<ul>
<li><strong>别名</strong>：告别记忆 <code>keyCode</code>。</li>
<li><strong>修饰符</strong>：轻松实现组合键判断。</li>
<li><strong>自定义</strong>：灵活扩展。</li>
</ul>
<p><strong>注意</strong>：在 Vue 3 中，<code>.keyCode</code> 的使用已被移除，推荐直接使用按键名称（kebab-case 格式，如 <code>.page-down</code>）。</p>
<hr>
<h2 id="事件处理-Command-键"><a href="#事件处理-Command-键" class="headerlink" title="事件处理-Command 键"></a>事件处理-Command 键</h2><p>在 Vue 的键盘事件修饰符中，<code>command</code> 实际上是 <strong><code>.meta</code></strong> 修饰符的别名（在 Mac 系统下）。</p>
<p>为了让你彻底理解，我们需要把它拆解为 <strong>“概念名称”</strong> 和 <strong>“具体按键”</strong> 两个层面来看：</p>
<h3 id="1-核心概念：-meta"><a href="#1-核心概念：-meta" class="headerlink" title="1. 核心概念：.meta"></a>1. 核心概念：<code>.meta</code></h3><p>在 Vue 的官方文档和源码中，这个修饰符正式的名字叫 **<code>.meta</code><strong>。<br>它的设计初衷是为了匹配操作系统键盘上的</strong>“元键” (Meta Key)**。</p>
<h3 id="2-具体指代：看你的电脑系统"><a href="#2-具体指代：看你的电脑系统" class="headerlink" title="2. 具体指代：看你的电脑系统"></a>2. 具体指代：看你的电脑系统</h3><p>这个 <code>.meta</code> 键在不同操作系统对应的物理按键是不同的：</p>
<table>
<thead>
<tr>
<th>系统</th>
<th>对应的物理按键</th>
<th>符号</th>
<th>备注</th>
</tr>
</thead>
<tbody><tr>
<td><strong>Mac OS</strong></td>
<td><strong>Command 键 (Cmd)</strong></td>
<td>⌘</td>
<td>在 Mac 下，<code>.meta</code> 就是 <code>command</code> 键</td>
</tr>
<tr>
<td><strong>Windows</strong></td>
<td><strong>Windows 徽标键 (Win)</strong></td>
<td>⊞</td>
<td>在 Windows 下，<code>.meta</code> 就是开始键</td>
</tr>
</tbody></table>
<h3 id="3-为什么会有-“command”-这种写法？"><a href="#3-为什么会有-“command”-这种写法？" class="headerlink" title="3. 为什么会有 “command” 这种写法？"></a>3. 为什么会有 “command” 这种写法？</h3><p>虽然 Vue 官方定义的修饰符是 <code>.meta</code>，但在实际开发中（特别是 Mac 用户居多的开发环境），大家习惯称之为 command。</p>
<p>在你的代码中，Vue 为了方便开发者，<strong>允许你直接使用按键的名称</strong>作为修饰符。</p>
<ul>
<li>因为 Mac 键盘上那个键印的是 “command”，</li>
<li>所以 Vue 支持你直接写 <code>.command</code>，它会自动识别这等同于 <code>.meta</code>。</li>
</ul>
<h3 id="💡-总结与建议"><a href="#💡-总结与建议" class="headerlink" title="💡 总结与建议"></a>💡 总结与建议</h3><p>在你的代码中：</p>
<pre><code class="html">&lt;!-- 这两种写法在 Mac 上是等价的 --&gt;
&lt;input @keydown.meta=&quot;doSomething&quot;&gt; 
&lt;input @keydown.command=&quot;doSomething&quot;&gt; 
</code></pre>
<ul>
<li>**<code>.meta</code>**：是标准的、跨平台的写法（推荐，因为它更通用）。</li>
<li>**<code>.command</code>**：是语义化的写法，特指 Mac 上的 command 键（可读性更好，但仅限于你知道目标用户是 Mac 的情况）。</li>
</ul>
<hr>
<h2 id="事件处理的基本使用"><a href="#事件处理的基本使用" class="headerlink" title="事件处理的基本使用"></a>事件处理的基本使用</h2><blockquote>
<p>事件的基本使用：<br>                            1.使用v-on:xxx 或 @xxx 绑定事件，其中xxx是事件名；<br>                            2.事件的回调需要配置在methods对象中，最终会在vm上；<br>                            3.methods中配置的函数，不要用箭头函数！否则this就不是vm了；<br>                            4.methods中配置的函数，都是被Vue所管理的函数，this的指向是vm 或 组件实例对象；<br>                            5.@click=”demo” 和 @click=”demo($event)” 效果一致，但后者可以传参；</p>
</blockquote>
<pre><code class="html">&lt;!doctype html&gt;
&lt;html lang=&quot;en&quot;&gt;
&lt;head&gt;
    &lt;meta charset=&quot;UTF-8&quot;&gt;
    &lt;meta name=&quot;viewport&quot;
          content=&quot;width=device-width, user-scalable=no, initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0&quot;&gt;
    &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;ie=edge&quot;&gt;
    &lt;title&gt;vue 键盘事件&lt;/title&gt;
    &lt;script src=&quot;../js/vue.js&quot;&gt;&lt;/script&gt;
&lt;/head&gt;
&lt;body&gt;
  &lt;div id=&quot;root&quot;&gt;
        &lt;!--vue中键盘事件的绑定 一般用keyUp(keydown)--&gt;
        &lt;h1&gt;欢迎来到 &#123;&#123; name &#125;&#125; &lt;/h1&gt;
        &lt;!-- 按下 command 键时，事件就会触发 --&gt;
        &lt;input type=&quot;text&quot; @keydown.meta=&quot;showInfo&quot; placeholder=&quot;按下command键提示输入&quot;/&gt;
        &lt;!-- 必须先按住 command，再按其他键，最后松开其他键才会触发 --&gt;
        &lt;input type=&quot;text&quot; @keyup.meta=&quot;showInfo&quot; placeholder=&quot;松开command键提示输入&quot;/&gt;
        &lt;hr/&gt;
        &lt;!--指令语法 v开头 例如v-on:click点击事件--&gt;
        &lt;button v-on:click=&quot;ClickInfo&quot;&gt; 点击提示输入1 &lt;/button&gt;
        &lt;!--简写形式 @click--&gt;
        &lt;button @click=&quot;showClickInfo($event, &#39;hello vue&#39;)&quot;&gt; 点击提示输入2 &lt;/button&gt;
    &lt;/div&gt;
    &lt;script type=&quot;text/javascript&quot;&gt;
        Vue.config.productionTip = false;
        const vm= new Vue(&#123;
            el:&#39;#root&#39;,
            data:&#123;
                name: &#39;江西-南昌&#39;
            &#125;,
            methods:&#123;
                showInfo:function (e)&#123;
                    console.log(e.target.value);
                    console.log(e.key); //按下的名字
                &#125;, 
                ClickInfo(e) &#123;
                    console.log(&#39;点击提示输入1&#39;);
                    console.log(e.target);
                    console.log(this === vm ? &#39;this 指向 vm&#39; : &#39;this 指向 事件触发的元素&#39;);
                &#125;,
                showClickInfo(e, msg) &#123;
                    console.log(&#39;点击提示输入2&#39;);
                    console.log(e.target);
                    console.log(&#39;接收的参数是:  &#39; + msg);
                &#125;
            &#125;
        &#125;)
    &lt;/script&gt;
&lt;/body&gt;
&lt;/html&gt;
</code></pre>
<p>这段代码非常棒，它同时涵盖了 Vue 中<strong>键盘事件</strong>的特殊机制和<strong>鼠标事件</strong>的基础用法。通过它，我们可以清晰地对比 Vue 如何处理不同类型的用户交互。</p>
<p>结合你的代码，我来为你详细解读其中的关键点：</p>
<h3 id="⌨️-键盘事件：-meta-修饰符的奥秘"><a href="#⌨️-键盘事件：-meta-修饰符的奥秘" class="headerlink" title="⌨️ 键盘事件：.meta 修饰符的奥秘"></a>⌨️ 键盘事件：<code>.meta</code> 修饰符的奥秘</h3><p>你代码中的输入框完美展示了 <code>.meta</code>（Command/Win 键）在 <code>keydown</code> 和 <code>keyup</code> 下的不同表现：</p>
<h4 id="keydown-meta-quot-showInfo-quot"><a href="#keydown-meta-quot-showInfo-quot" class="headerlink" title="@keydown.meta=&quot;showInfo&quot;"></a><code>@keydown.meta=&quot;showInfo&quot;</code></h4><ul>
<li><strong>触发逻辑</strong>：只要按下 Command 键，事件就会立即触发。</li>
<li><strong>场景</strong>：适用于需要“长按”执行操作的功能（比如连续加速）。</li>
</ul>
<h4 id="keyup-meta-quot-showInfo-quot"><a href="#keyup-meta-quot-showInfo-quot" class="headerlink" title="@keyup.meta=&quot;showInfo&quot;"></a><code>@keyup.meta=&quot;showInfo&quot;</code></h4><ul>
<li><strong>触发逻辑</strong>：必须<strong>先按住 Command 键</strong>，再按另一个键（如 A），然后<strong>释放那个另一个键</strong>，事件才会触发。</li>
<li><strong>注意</strong>：如果你只按 Command 键然后松开，是不会触发的。</li>
<li><strong>场景</strong>：这种写法比较少用，通常我们更习惯用 <code>keydown</code> 来监听组合键。</li>
</ul>
<h3 id="🖱️-鼠标事件：参数与-this"><a href="#🖱️-鼠标事件：参数与-this" class="headerlink" title="🖱️ 鼠标事件：参数与 this"></a>🖱️ 鼠标事件：参数与 <code>this</code></h3><p>你定义的两个按钮展示了 Vue 事件处理的两个核心细节：</p>
<h4 id="1-访问原生事件对象"><a href="#1-访问原生事件对象" class="headerlink" title="1. 访问原生事件对象"></a>1. 访问原生事件对象</h4><p>在原生 JS 中，获取事件对象可能需要处理兼容性问题。但在 Vue 中，Vue 会将原生 DOM 事件作为<strong>第一个参数</strong>传入回调函数。</p>
<ul>
<li>代码中：<code>ClickInfo(e)</code> 和 <code>showClickInfo(e, msg)</code> 的第一个参数 <code>e</code> 就是原生事件对象。</li>
<li>用法：你可以通过 <code>e.target</code> 获取触发事件的 DOM 元素。</li>
</ul>
<h4 id="2-正确的-this-指向"><a href="#2-正确的-this-指向" class="headerlink" title="2. 正确的 this 指向"></a>2. 正确的 <code>this</code> 指向</h4><p>在 <code>methods</code> 中定义的方法，Vue 会自动将 <code>this</code> 绑定为 Vue 实例（<code>vm</code>）。</p>
<ul>
<li>代码中：<code>console.log(this === vm ? ...)</code> 会输出 <code>this 指向 vm</code>。</li>
<li><strong>重要性</strong>：这意味着你可以在事件处理函数中直接通过 <code>this.name</code> 访问数据，或者调用 <code>this</code> 上的其他方法。</li>
</ul>
<h3 id="💡-一个潜在的优化点"><a href="#💡-一个潜在的优化点" class="headerlink" title="💡 一个潜在的优化点"></a>💡 一个潜在的优化点</h3><p>在你的 <code>showClickInfo</code> 方法中，你传入了字符串 <code>&#39;hello vue&#39;</code>。在 Vue 模板中，如果你不加引号，Vue 会把它当成变量名去 <code>data</code> 里找；<strong>加了引号</strong>，它才会被当作普通的字符串参数。</p>
<p>你的写法是完全正确的：</p>
<pre><code class="html">@click=&quot;showClickInfo($event, &#39;hello vue&#39;)&quot;
&lt;!-- 注意 &#39;hello vue&#39; 的单引号 --&gt;
</code></pre>
<h3 id="📌-总结-2"><a href="#📌-总结-2" class="headerlink" title="📌 总结"></a>📌 总结</h3><p>这段代码展示了 Vue 事件处理的三大支柱：</p>
<ul>
<li><strong>指令</strong>：<code>v-on:</code> 或 <code>@</code> 绑定监听。</li>
<li><strong>修饰符</strong>：<code>.meta</code>、<code>.enter</code> 等让按键监听更语义化。</li>
<li><strong>方法</strong>：在 <code>methods</code> 中集中管理逻辑，享受自动绑定的 <code>this</code> 和便捷的参数传递。</li>
</ul>
<hr>
<h2 id="事件修饰"><a href="#事件修饰" class="headerlink" title="事件修饰"></a>事件修饰</h2><blockquote>
<p>Vue中的事件修饰符：</p>
<p>​            1.prevent：阻止默认事件（常用）；</p>
<p>​            2.stop：阻止事件冒泡（常用）；</p>
<p>​            3.once：事件只触发一次（常用）；</p>
<p>​            4.capture：使用事件的捕获模式；</p>
<p>​            5.self：只有event.target是当前操作的元素时才触发事件；</p>
<p>​            6.passive：事件的默认行为立即执行，无需等待事件回调执行完毕；</p>
</blockquote>
<pre><code class="html">&lt;!doctype html&gt;
&lt;html lang=&quot;en&quot;&gt;
&lt;head&gt;
    &lt;meta charset=&quot;UTF-8&quot;&gt;
    &lt;meta name=&quot;viewport&quot;
          content=&quot;width=device-width, user-scalable=no, initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0&quot;&gt;
    &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;ie=edge&quot;&gt;
    &lt;title&gt;vue 键盘事件&lt;/title&gt;
    &lt;script src=&quot;../js/vue.js&quot;&gt;&lt;/script&gt;
    &lt;style&gt;
        .demo1&#123;
            height: 100px;
            background: deepskyblue;
            padding: 20px;
        &#125;
        .box1&#123;
            height: 100px;
            background: pink;
            padding: 20px;
        &#125;
        .box2&#123;
            height: 50px;
            background: lightgreen;
            padding: 20px;
        &#125;
        .btn3&#123;
            height: 30px;
            background: rgb(185, 230, 173);
            padding: 5px;
            border-radius: 5px;
        &#125;
        .list&#123;
            height: 200px;
            width: 200px;
            background: salmon;
            overflow: auto;
        &#125;
        .list li &#123;
            height: 100px;
        &#125;
    &lt;/style&gt;
&lt;/head&gt;
&lt;body&gt;
  &lt;div id=&quot;root&quot;&gt;
        &lt;!--vue中键盘事件的绑定 一般用keyUp(keydown)--&gt;
        &lt;h1&gt;欢迎来到 &#123;&#123; name &#125;&#125; &lt;/h1&gt;
        &lt;br/&gt;&lt;br/&gt;
        &lt;a href=&quot;https://www.baidu.com&quot; @click.prevent=&quot;showInfo&quot;&gt; 阻止默认事件(常用) &lt;/a&gt;
        &lt;div class=&quot;demo1&quot; @click=&quot;showInfo&quot;&gt;
            &lt;button @click.stop=&quot;showInfo&quot;&gt; 阻止事件冒泡(常用) &lt;/button&gt;
        &lt;/div&gt;
        &lt;br/&gt;&lt;br/&gt;
        &lt;button @click.once=&quot;showInfo&quot;&gt; 点击只能触发一次 &lt;/button&gt;
        &lt;div class=&quot;box1&quot; @click.capture=&quot;showMsg(&#39;box1&#39;)&quot;&gt;
            box1 - capture事件的捕获模式, 让事件以捕获的方式来处理(先捕获再冒泡)
            &lt;div class=&quot;box2&quot; @click=&quot;showMsg(&#39;box2&#39;)&quot;&gt;
                box2 - 点击事件默认是冒泡模式, 点击box2时, 先触发box2的点击事件, 再触发box1的点击事件 
                &lt;br/&gt;
                &lt;button class=&quot;btn3&quot; @click=&quot;showMsg(&#39;btn3&#39;)&quot;&gt; btn3 &lt;/button&gt;
            &lt;/div&gt;
        &lt;/div&gt;
        &lt;br/&gt;&lt;br/&gt;
        &lt;button v-on:click=&quot;ClickInfo&quot;&gt; 点击提示输入1 &lt;/button&gt;
        &lt;button @click=&quot;showClickInfo($event, &#39;hello vue&#39;)&quot;&gt; 点击提示输入2 &lt;/button&gt;
        &lt;br/&gt;&lt;br/&gt;
        &lt;div class=&quot;demo1&quot; @click.self=&quot;showInfo&quot;&gt;
            &lt;p&gt;self 只有 event.target 是当前操作的元素时, 才会触发事件 (变相阻止冒泡)&lt;/p&gt;
            &lt;button @click=&quot;showInfo&quot;&gt; click.self &lt;/button&gt;
        &lt;/div&gt;
        &lt;br/&gt;&lt;br/&gt;
        &lt;p&gt;passive: 事件的默认行为立即执行, 无需等待事件回调执行完毕.&lt;/p&gt;
        &lt;p&gt;scroll: 滚动条一滚动就会触发的事件 wheel 鼠标滚轮事件&lt;/p&gt;
        &lt;ul class=&quot;list&quot; @scroll.passive=&quot;demo&quot;&gt;
            &lt;li&gt;1&lt;/li&gt;
            &lt;li&gt;2&lt;/li&gt;
            &lt;li&gt;3&lt;/li&gt;
            &lt;li&gt;4&lt;/li&gt;
            &lt;li&gt;5&lt;/li&gt;
            &lt;li&gt;6&lt;/li&gt;
            &lt;li&gt;7&lt;/li&gt;
            &lt;li&gt;8&lt;/li&gt;
            &lt;li&gt;9&lt;/li&gt;
            &lt;li&gt;10&lt;/li&gt;
        &lt;/ul&gt;
        &lt;br/&gt;&lt;br/&gt;
    &lt;/div&gt;
    &lt;script type=&quot;text/javascript&quot;&gt;
        Vue.config.productionTip = false;
        const vm= new Vue(&#123;
            el:&#39;#root&#39;,
            data:&#123;
                name: &#39;江西-南昌&#39;
            &#125;,
            methods:&#123;
                showInfo:function (e)&#123;
                    // e.preventDefault(); // 阻止默认事件
                    // e.stopPropagation(); // 阻止事件冒泡
                    console.log(e.target);
                &#125;, 
                showMsg(msg) &#123;
                    console.log(msg);
                &#125;,
                demo() &#123;
                    console.log(&#39;@@@ demo 滚动事件开始&#39;);
                    for (let i = 0; i &lt; 1000; i++) &#123;
                        console.log(&#39;#&#39;);
                    &#125;
                    console.log(&#39;demo 滚动事件结束&#39;);
                &#125;,
                ClickInfo(e) &#123;
                    console.log(&#39;点击提示输入1&#39;);
                    console.log(e.target);
                    console.log(this === vm ? &#39;this 指向 vm&#39; : &#39;this 指向 事件触发的元素&#39;);
                &#125;,
                showClickInfo(e, msg) &#123;
                    console.log(&#39;点击提示输入2&#39;);
                    console.log(e.target);
                    console.log(&#39;接收的参数是:  &#39; + msg);
                &#125;
            &#125;
        &#125;)
    &lt;/script&gt;
&lt;/body&gt;
&lt;/html&gt;
</code></pre>
<p><img src="/2026/01/19/vue-learning/image-20260121102821210.png" alt="image-20260121102821210"></p>
<p>这段代码是 Vue.js 事件处理机制的<strong>集大成者</strong>。它不仅涵盖了上一轮讨论的<strong>键盘事件</strong>，更深入展示了 Vue 强大的<strong>事件修饰符</strong>系统。</p>
<p>通过这段代码，我们可以看到 Vue 如何通过简单的指令修饰，解决了原生 DOM 事件处理中繁琐的兼容性判断和逻辑控制问题。结合你的代码，我将从<strong>修饰符的深度解析</strong>、<strong>事件流的控制</strong>以及<strong>性能优化</strong>三个维度来为你解读。</p>
<h3 id="🛠️-核心机制：事件修饰符-Event-Modifiers"><a href="#🛠️-核心机制：事件修饰符-Event-Modifiers" class="headerlink" title="🛠️ 核心机制：事件修饰符 (Event Modifiers)"></a>🛠️ 核心机制：事件修饰符 (Event Modifiers)</h3><p>Vue 的修饰符是 Vue.js 事件系统中最优雅的设计，它们通过链式调用的方式，让模板代码直接表达意图，而不需要在方法逻辑中混杂 DOM 操作。</p>
<h4 id="1-阻断与限制类"><a href="#1-阻断与限制类" class="headerlink" title="1. 阻断与限制类"></a>1. 阻断与限制类</h4><table>
<thead>
<tr>
<th>修饰符</th>
<th>代码示例</th>
<th>核心作用</th>
<th>实际应用场景</th>
</tr>
</thead>
<tbody><tr>
<td><strong><code>.prevent</code></strong></td>
<td><code>@click.prevent</code></td>
<td>阻止默认行为</td>
<td>表单提交验证、A 标签拦截</td>
</tr>
<tr>
<td><strong><code>.stop</code></strong></td>
<td><code>@click.stop</code></td>
<td>阻止事件冒泡</td>
<td>嵌套元素点击、模态框遮罩</td>
</tr>
<tr>
<td><strong><code>.once</code></strong></td>
<td><code>@click.once</code></td>
<td>事件只触发一次</td>
<td>防止重复提交、一次性引导</td>
</tr>
</tbody></table>
<h4 id="2-逻辑与性能类"><a href="#2-逻辑与性能类" class="headerlink" title="2. 逻辑与性能类"></a>2. 逻辑与性能类</h4><table>
<thead>
<tr>
<th>修饰符</th>
<th>代码示例</th>
<th>核心作用</th>
<th>实际应用场景</th>
</tr>
</thead>
<tbody><tr>
<td><strong><code>.self</code></strong></td>
<td><code>@click.self</code></td>
<td>仅目标元素触发</td>
<td>点击模态框外部关闭（点击内容不关闭）</td>
</tr>
<tr>
<td><strong><code>.capture</code></strong></td>
<td><code>@click.capture</code></td>
<td>捕获模式触发</td>
<td>需要父元素先于子元素响应的交互</td>
</tr>
<tr>
<td><strong><code>.passive</code></strong></td>
<td><code>@scroll.passive</code></td>
<td>立即执行默认行为</td>
<td><strong>移动端滚动优化</strong>，解决卡顿</td>
</tr>
</tbody></table>
<h3 id="🌊-事件流：捕获与冒泡"><a href="#🌊-事件流：捕获与冒泡" class="headerlink" title="🌊 事件流：捕获与冒泡"></a>🌊 事件流：捕获与冒泡</h3><p>代码中关于 <code>.box1</code>、<code>.box2</code> 和 <code>.btn3</code> 的嵌套结构，完美演示了 DOM 事件流的两种模式：</p>
<h4 id="1-默认的冒泡模式-Bubbling"><a href="#1-默认的冒泡模式-Bubbling" class="headerlink" title="1. 默认的冒泡模式 (Bubbling)"></a>1. 默认的冒泡模式 (Bubbling)</h4><p>在 <code>.box2</code> 和 <code>.btn3</code> 的代码中：</p>
<ul>
<li><strong>逻辑</strong>：当你点击按钮（<code>.btn3</code>）时，事件会先触发按钮的点击，再传递给父级（<code>.box2</code>），最后传递给祖父级（<code>.box1</code>）。</li>
<li><strong>代码</strong>：<code>@click</code>（默认写法）。</li>
</ul>
<h4 id="2-捕获模式-Capturing"><a href="#2-捕获模式-Capturing" class="headerlink" title="2. 捕获模式 (Capturing)"></a>2. 捕获模式 (Capturing)</h4><p>在 <code>.box1</code> 的代码中：</p>
<ul>
<li><strong>逻辑</strong>：加上 <code>.capture</code> 修饰符后，事件流的方向反转。Vue 会先检查父级（<code>.box1</code>）是否有捕获监听，如果有，<strong>先执行父级</strong>，然后再向下传递给子级（<code>.box2</code> -&gt; <code>.btn3</code>）。</li>
<li><strong>代码</strong>：<code>@click.capture</code>。</li>
<li><strong>输出顺序</strong>：点击按钮时，控制台会先输出 <code>box1</code>，再输出 <code>box2</code>，最后输出 <code>btn3</code>。</li>
</ul>
<h3 id="🚀-性能优化：-passive-的妙用"><a href="#🚀-性能优化：-passive-的妙用" class="headerlink" title="🚀 性能优化：.passive 的妙用"></a>🚀 性能优化：<code>.passive</code> 的妙用</h3><p>代码中的 <code>&lt;ul @scroll.passive=&quot;demo&quot;&gt;</code> 是一个非常高级的用法，它解决了 Web 开发中一个经典的性能痛点。</p>
<ul>
<li><strong>问题背景</strong>：在移动端，浏览器在触发 <code>scroll</code> 事件前，会等待事件回调执行完，以判断开发者是否会调用 <code>event.preventDefault()</code> 来阻止滚动。如果回调函数里有大量计算（如代码中的 <code>for</code> 循环），页面滚动就会变得极其卡顿。</li>
<li><strong>Vue 的解法</strong>：<code>.passive</code> 修饰符告诉浏览器：“<strong>我不会阻止滚动，请你直接滚动，不要等我</strong>”。</li>
<li><strong>效果</strong>：加上 <code>.passive</code> 后，滚动条会立即响应，无需等待 <code>demo</code> 函数里的循环执行完毕，极大地提升了用户体验。</li>
</ul>
<h3 id="⚠️-关于-this-的再次强调"><a href="#⚠️-关于-this-的再次强调" class="headerlink" title="⚠️ 关于 this 的再次强调"></a>⚠️ 关于 <code>this</code> 的再次强调</h3><p>在 <code>ClickInfo</code> 方法中，你再次验证了 Vue 的 <code>this</code> 绑定机制：</p>
<ul>
<li><strong>原生 JS</strong>：<code>this</code> 指向触发事件的 DOM 元素（<code>e.target</code>）。</li>
<li><strong>Vue Methods</strong>：Vue 自动将 <code>this</code> 绑定为 Vue 实例（<code>vm</code>）。这意味着你可以在 <code>ClickInfo</code> 中直接通过 <code>this.name</code> 访问数据，或者调用 <code>this</code> 上的其他方法，而不需要手动绑定 <code>this</code>。</li>
</ul>
<h3 id="📌-总结与建议"><a href="#📌-总结与建议" class="headerlink" title="📌 总结与建议"></a>📌 总结与建议</h3><p>这段代码是 Vue 事件处理的<strong>最佳实践指南</strong>。在实际开发中，建议你：</p>
<ol>
<li><strong>善用连写</strong>：如 <code>@click.prevent.self</code>，既阻止默认行为又防止冒泡，代码极其精简。</li>
<li>**移动端必加 <code>.passive</code>**：在处理 <code>touchstart</code>、<code>touchmove</code>、<code>scroll</code> 等高频事件时，如果不需要阻止默认行为，请务必加上 <code>.passive</code>，这是提升流畅度的关键。</li>
<li><strong>理解事件流</strong>：<code>.capture</code> 和 <code>.self</code> 虽然不常用，但在处理复杂的嵌套组件交互（如日历组件、拖拽库）时是解决问题的利器。</li>
</ol>
<hr>
<h2 id="计算属性"><a href="#计算属性" class="headerlink" title="计算属性"></a>计算属性</h2><blockquote>
<p>计算属性：</p>
<p>​          1.定义：要用的属性不存在，要通过已有属性计算得来。</p>
<p>​          2.原理：底层借助了Objcet.defineproperty方法提供的getter和setter。</p>
<p>​          3.get函数什么时候执行？</p>
<p>​                (1).初次读取时会执行一次。</p>
<p>​                (2).当依赖的数据发生改变时会被再次调用。</p>
<p>​          4.优势：与methods实现相比，内部有缓存机制（复用），效率更高，调试方便。</p>
<p>​          5.备注：</p>
<p>​              1.计算属性最终会出现在vm上，直接读取使用即可。</p>
<p>​              2.如果计算属性要被修改，那必须写set函数去响应修改，且set中要引起计算时依赖的数据发生改变。</p>
</blockquote>
<pre><code class="html">&lt;!doctype html&gt;
&lt;html lang=&quot;en&quot;&gt;
&lt;head&gt;
    &lt;meta charset=&quot;UTF-8&quot;&gt;
    &lt;meta name=&quot;viewport&quot;
          content=&quot;width=device-width, user-scalable=no, initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0&quot;&gt;
    &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;ie=edge&quot;&gt;
    &lt;title&gt;计算属性&lt;/title&gt;
    &lt;script src=&quot;../js/vue.js&quot;&gt;&lt;/script&gt;
&lt;/head&gt;
&lt;body&gt;
    &lt;div id=&quot;root&quot;&gt;
        &lt;!--v-model双向绑定--&gt;
        姓:&lt;input type=&quot;text&quot; v-model=&quot;firstName&quot;/&gt;
        &lt;br/&gt;&lt;br/&gt;
        名:&lt;input type=&quot;text&quot; v-model=&quot;lastName&quot;/&gt;
        &lt;br/&gt;&lt;br/&gt;
        全名-computed实现: &lt;span&gt;&#123;&#123; fullName &#125;&#125;&lt;/span&gt;
        &lt;br/&gt;&lt;br/&gt;
        全名: &lt;input type=&quot;text&quot; v-model=&quot;test&quot; placeholder=&quot;请输入全名&quot;/&gt;
        &lt;button @click=&quot;changeFullName&quot;&gt;修改&lt;/button&gt;
        &lt;br/&gt;&lt;br/&gt;
        &lt;!-- 全名-menthods实现: &lt;span&gt;&#123;&#123; fullName() &#125;&#125;&lt;/span&gt; --&gt;
    &lt;/div&gt;
    &lt;script type=&quot;text/javascript&quot;&gt;
        const vm = new Vue(&#123;
           el:&#39;#root&#39;,
           data:&#123;
               firstName:&#39;张&#39;,
               lastName: &#39;三&#39;,
               test: &#39;测--试&#39;
           &#125;, 
           computed: &#123;
               fullName: &#123;
                  get() &#123;
                    console.log(&#39;fullNameByComputed get()被调用了&#39;);
                    return this.firstName + &#39;--&#39; + this.lastName;
                  &#125;,
                  set(val) &#123;
                    console.log(&#39;fullNameByComputed set()被调用了&#39;);
                    const [firstName, lastName] = val.split(&#39;--&#39;);
                    this.firstName = firstName;
                    this.lastName = lastName;
                    console.log(&#39;fullNameByComputed set()被调用了&#39;);
                  &#125;
               &#125;
           &#125;,
            //简写形式
            //前提:计算属性只考虑读取不考虑修改 set丢了
            //简写计算书写为一个函数(这个函数当成getter使用), 注意不要写箭头函数
            //执行完getter之后，vm直接保存返回的数据为fullName属性的属性值,此时vm.fullName不是函数而是一个确切的计算值
        //    computed: &#123;
        //        fullName: function() &#123;
        //            console.log(&#39;fullName()被调用了&#39;);
        //            return this.firstName + &#39;--&#39; + this.lastName;
        //        &#125;
        //    &#125;,
           methods: &#123;
                changeFullName() &#123;
                    this.fullName = this.test;
                &#125;,
                // fullName() &#123;
                //     console.log(&#39;fullName()被调用了&#39;);
                //     return `$&#123;this.firstName.slice(0, 4)&#125; -- $&#123;this.lastName&#125;`;
                // &#125;
           &#125;
        &#125;);
    &lt;/script&gt;
&lt;/body&gt;
&lt;/html&gt;
</code></pre>
<p>这段代码非常清晰地展示了 Vue 中<strong>计算属性</strong>的核心概念。通过“姓”和“名”两个输入框动态拼接“全名”，完美体现了 <code>computed</code> 相比于普通方法的优势。</p>
<p>结合你的代码，我来为你深入拆解 <code>computed</code> 的工作原理和它为什么是 Vue 的“性能利器”：</p>
<h3 id="🧮-什么是计算属性？"><a href="#🧮-什么是计算属性？" class="headerlink" title="🧮 什么是计算属性？"></a>🧮 什么是计算属性？</h3><p>计算属性本质上是一个<strong>“会自动更新的值”</strong>。<br>它看起来像一个属性（在模板中使用时不需要加括号 <code>&#123;&#123; fullName &#125;&#125;</code>），但背后其实是一个函数，用来根据其他数据计算出新数据。</p>
<h3 id="⚙️-工作原理：依赖追踪与缓存"><a href="#⚙️-工作原理：依赖追踪与缓存" class="headerlink" title="⚙️ 工作原理：依赖追踪与缓存"></a>⚙️ 工作原理：依赖追踪与缓存</h3><p>这是 <code>computed</code> 和 <code>methods</code> 最大的区别。</p>
<ul>
<li><strong>你的代码逻辑</strong>：<ul>
<li><code>fullName</code> 依赖于 <code>this.firstName</code> 和 <code>this.lastName</code>。</li>
<li>当页面初次渲染时，Vue 会执行 <code>fullName</code> 函数，得到结果“张–三”。</li>
<li>Vue 会悄悄记住：“<code>fullName</code> 是由 <code>firstName</code> 和 <code>lastName</code> 算出来的”。</li>
</ul>
</li>
<li><strong>缓存机制（关键点）</strong>：<ul>
<li>假设你在页面上多次使用 <code>&#123;&#123; fullName &#125;&#125;</code>（比如用了 3 次），Vue <strong>只会执行 1 次</strong> <code>fullName</code> 函数，然后把结果复用 3 次。</li>
<li>只有当 <code>firstName</code> 或 <code>lastName</code> 的值发生变化时，Vue 才会“作废”旧缓存，并在下一次读取 <code>fullName</code> 时重新执行函数计算新值。</li>
</ul>
</li>
<li>**对比 <code>methods</code>**：<ul>
<li>如果你用 <code>methods</code> 实现，每次调用 <code>&#123;&#123; fullName() &#125;&#125;</code>，函数都会<strong>无条件执行</strong>，不管数据变没变。如果计算逻辑很复杂，这会浪费大量性能。</li>
</ul>
</li>
</ul>
<h3 id="📝-简写形式"><a href="#📝-简写形式" class="headerlink" title="📝 简写形式"></a>📝 简写形式</h3><p>你的代码使用了 <code>computed</code> 的<strong>简写形式</strong>。</p>
<ul>
<li><strong>适用场景</strong>：只需要读取计算属性的值，不需要修改它。</li>
<li><strong>写法</strong>：直接把 <code>get</code> 函数写成 <code>fullName: function() &#123;&#125;</code>。</li>
<li><strong>注意</strong>：简写形式的函数体里不能有 <code>this.xxx = yyy</code> 这种赋值操作（除非是修改其他无关数据），因为简写默认只有 <code>get</code>，没有 <code>set</code>。</li>
</ul>
<h3 id="🎬-代码运行流程图解"><a href="#🎬-代码运行流程图解" class="headerlink" title="🎬 代码运行流程图解"></a>🎬 代码运行流程图解</h3><ol>
<li><strong>初始化</strong>：Vue 实例创建，<code>firstName</code> 为“张”，<code>lastName</code> 为“三”。</li>
<li><strong>渲染</strong>：模板遇到 <code>&#123;&#123; fullName &#125;&#125;</code>。</li>
<li><strong>求值</strong>：Vue 发现 <code>fullName</code> 是计算属性，于是执行函数，控制台打印 <code>&#39;fullName()被调用了&#39;</code>，返回“张–三”。</li>
<li><strong>缓存</strong>：Vue 把“张–三”存起来。</li>
<li><strong>后续渲染</strong>：如果页面其他地方还有 <code>&#123;&#123; fullName &#125;&#125;</code>，Vue 直接拿缓存的值，<strong>不再打印</strong> <code>&#39;fullName()被调用了&#39;</code>。</li>
<li><strong>更新</strong>：当你在输入框修改“姓”时，<code>firstName</code> 变了。Vue 检测到依赖变化，标记 <code>fullName</code> 为“脏数据”。</li>
<li><strong>重新求值</strong>：当下次渲染需要 <code>fullName</code> 时，Vue 再次执行函数，打印日志，得到新值。</li>
</ol>
<h3 id="💡-总结"><a href="#💡-总结" class="headerlink" title="💡 总结"></a>💡 总结</h3><p><code>computed</code> 是 Vue 的“智能缓存器”。它利用 <strong>Getter</strong> 来派生数据，并利用 <strong>依赖追踪</strong> 来保证只有在必要时才重新计算。这让你的代码既声明式（像属性一样用），又高性能（自动缓存）。</p>
<hr>
<h2 id="监视属性"><a href="#监视属性" class="headerlink" title="监视属性"></a>监视属性</h2><blockquote>
<p>监视属性watch：</p>
<p>​          1.当被监视的属性变化时, 回调函数自动调用, 进行相关操作</p>
<p>​          2.监视的属性必须存在，才能进行监视！！</p>
<p>​          3.监视的两种写法：</p>
<p>​              (1).new Vue时传入watch配置</p>
<p>​              (2).通过vm.$watch监视</p>
</blockquote>
<pre><code class="html">&lt;!doctype html&gt;
&lt;html lang=&quot;en&quot;&gt;
&lt;head&gt;
    &lt;meta charset=&quot;UTF-8&quot;&gt;
    &lt;meta name=&quot;viewport&quot;
          content=&quot;width=device-width, user-scalable=no, initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0&quot;&gt;
    &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;ie=edge&quot;&gt;
    &lt;title&gt;天气案例&lt;/title&gt;
    &lt;script src=&quot;../js/vue.js&quot;&gt;&lt;/script&gt;
&lt;/head&gt;
&lt;body&gt;
&lt;div id=&quot;root&quot;&gt;
    &lt;h1&gt;今天天气很 &#123;&#123; info &#125;&#125;&lt;/h1&gt;
    &lt;button @click=&quot;changeWeather&quot;&gt;
        切换天气
    &lt;/button&gt;
    &lt;h2&gt;numbers.a: &#123;&#123; numbers.a &#125;&#125;&lt;/h2&gt;
    &lt;button @click=&quot;numbers.a++&quot;&gt;
        a++
    &lt;/button&gt;
    &lt;h2&gt;numbers.b: &#123;&#123; numbers.b &#125;&#125;&lt;/h2&gt;
    &lt;button @click=&quot;numbers.b++&quot;&gt;
        b++
    &lt;/button&gt;
    &lt;p&gt; 测试vue自身监测数据属性 &lt;/p&gt;
    &lt;h3&gt;numbers.c.d: &#123;&#123; numbers.c.d &#125;&#125;&lt;/h3&gt;
    &lt;button @click=&quot;numbers.c.d++&quot;&gt;
        d++
    &lt;/button&gt;
    &lt;h3&gt;numbers.c.e: &#123;&#123; numbers.c.e &#125;&#125;&lt;/h3&gt;
    &lt;button @click=&quot;numbers.c.e++&quot;&gt;
        e++
    &lt;/button&gt;
&lt;/div&gt;
&lt;script type=&quot;text/javascript&quot;&gt;
    Vue.config.productionTip = false;
    const vm = new Vue(&#123;
        el:&#39;#root&#39;,
        data:&#123;
            isHot: true,
            numbers: &#123;
                a: 100,
                b: 200,
                c: &#123;
                    d: 300,
                    e: 400
                &#125;
            &#125;
        &#125;,
        //计算属性
        computed: &#123;
            info()&#123;
                return this.isHot ? &#39;炎热&#39; : &#39;凉爽&#39;;
            &#125;
        &#125;,
        //改变模版数据的方法
        methods:&#123;
            changeWeather()&#123;
                this.isHot = !this.isHot;
            &#125;
        &#125;,
        //监视属性
        // watch: &#123;
        //     // isHot: &#123;
        //     //     // immediate: true, // 初始化时立即调用handler
        //     //     // handler 接收两个参数: 一个是新值, 一个是旧值
        //     //     // 当 isHot 变化时, 调用 handler
        //     //     handler(newVal, oldVal)&#123;
        //     //         console.log(&#39;ishot 被修改了&#39;);
        //     //         console.log(&#39;newVal: &#39;, newVal);
        //     //         if (newVal) &#123;
        //     //             console.log(&#39;天气炎热&#39;);
        //     //         &#125; else &#123;
        //     //             console.log(&#39;天气凉爽&#39;);
        //     //         &#125;
        //     //         console.log(&#39;oldVal: &#39;, oldVal);
        //     //         if (oldVal) &#123;
        //     //             console.log(&#39;之前天气炎热&#39;);
        //     //         &#125; else &#123;
        //     //             console.log(&#39;之前天气凉爽&#39;);
        //     //         &#125;
        //     //     &#125;
        //     // &#125;,
        //     isHot(newVal, oldVal) &#123; //简写的前提是watch属性不需要immediate和deep属性的时候
        //         console.log(&#39;ishot 被修改了&#39;);
        //         console.log(&#39;newVal: &#39;, newVal);
        //         if (newVal) &#123;
        //             console.log(&#39;天气炎热&#39;);
        //         &#125; else &#123;
        //             console.log(&#39;天气凉爽&#39;);
        //         &#125;
        //         console.log(&#39;oldVal: &#39;, oldVal);
        //         if (oldVal) &#123;
        //             console.log(&#39;之前天气炎热&#39;);
        //         &#125; else &#123;
        //             console.log(&#39;之前天气凉爽&#39;);
        //         &#125;
        //     &#125;,
        //     numbers: &#123;
        //         deep: true,
        //         handler() &#123;
        //             console.log(&#39;numbers 发生改变&#39;);
        //         &#125;
        //     &#125;
        // &#125;
    &#125;);
    // 完整写法
    vm.$watch(&#39;isHot&#39;, &#123;
        deep: true,
        immediate: true,
        handler(newVal, oldVal) &#123;
            console.log(&#39;ishot 被修改了&#39;);
            console.log(&#39;newVal: &#39;, newVal);
            if (newVal) &#123;
                console.log(&#39;天气炎热&#39;);
            &#125; else &#123;
                console.log(&#39;天气凉爽&#39;);
            &#125;
            console.log(&#39;oldVal: &#39;, oldVal);
            if (oldVal) &#123;
                console.log(&#39;之前天气炎热&#39;);
            &#125; else &#123;
                console.log(&#39;之前天气凉爽&#39;);
            &#125;
        &#125;
    &#125;)
&lt;/script&gt;
&lt;/body&gt;
&lt;/html&gt;
</code></pre>
<p>这段代码是一个非常经典的 Vue.js <strong>侦听属性（Watch）</strong> 教学案例。它清晰地展示了 Vue 如何自动追踪数据变化，并演示了<strong>浅层侦听</strong>与<strong>深层侦听</strong>的区别。</p>
<p>结合你的代码（目前 <code>watch</code> 选项被注释掉了，但逻辑在 <code>$watch</code> 中），我来为你深度解析 Vue 的“监测机制”：</p>
<h3 id="1-核心机制：vm-watch"><a href="#1-核心机制：vm-watch" class="headerlink" title="1. 核心机制：vm.$watch"></a>1. 核心机制：<code>vm.$watch</code></h3><p>虽然你在 <code>new Vue</code> 里注释掉了 <code>watch</code>，但你在实例创建后使用了 <code>vm.$watch</code>。这两者的效果是完全一样的。</p>
<ul>
<li><strong>侦听目标</strong>：<code>&#39;isHot&#39;</code></li>
<li><strong>配置项</strong>：<ul>
<li><code>immediate: true</code>：<strong>立即执行</strong>。通常 Watcher 是在数据变化后才执行，加上这个参数，页面加载完毕初始化时就会立刻执行一次 <code>handler</code>。</li>
<li><code>deep: true</code>：<strong>深度侦听</strong>。对于对象或数组，如果内部属性变化，也能监测到（后面会重点讲这个）。</li>
</ul>
</li>
<li>**回调函数 (handler)**：当被侦听的数据变化时，执行这里的逻辑。</li>
</ul>
<h3 id="2-Vue-的监测奥秘：numbers-对象"><a href="#2-Vue-的监测奥秘：numbers-对象" class="headerlink" title="2. Vue 的监测奥秘：numbers 对象"></a>2. Vue 的监测奥秘：<code>numbers</code> 对象</h3><p>页面上有一堆按钮在修改 <code>numbers</code> 对象里的值（<code>a</code>、<code>b</code>、<code>c.d</code>、<code>c.e</code>）。这里隐藏了一个 Vue 2 的重要特性：</p>
<h4 id="❓-问题：为什么修改-numbers-c-d-能被监测到？"><a href="#❓-问题：为什么修改-numbers-c-d-能被监测到？" class="headerlink" title="❓ 问题：为什么修改 numbers.c.d 能被监测到？"></a>❓ 问题：为什么修改 <code>numbers.c.d</code> 能被监测到？</h4><p>如果你在 <code>watch</code> 里写 <code>numbers: &#123; handler() &#123;&#125; &#125;</code>，你会发现：</p>
<ul>
<li>修改 <code>numbers.a</code>：<strong>能触发</strong>侦听。</li>
<li>修改 <code>numbers.c.d</code>：<strong>能触发</strong>侦听。</li>
</ul>
<p><strong>原因</strong>：Vue 2 的响应式系统是基于 <code>Object.defineProperty</code> 的<strong>递归遍历</strong>。当你把 <code>numbers</code> 对象交给 Vue 管理时，Vue 会立刻遍历它所有的嵌套属性（<code>a</code>, <code>b</code>, <code>c</code>, <code>d</code>, <code>e</code>），把它们都转换成 getter/setter。所以，无论你改到哪一层，Vue 都知道“数据变了”。</p>
<h4 id="⚠️-注意：deep-true-在这里是“多余”的？"><a href="#⚠️-注意：deep-true-在这里是“多余”的？" class="headerlink" title="⚠️ 注意：deep: true 在这里是“多余”的？"></a>⚠️ 注意：<code>deep: true</code> 在这里是“多余”的？</h4><p>在你的 <code>$watch</code> 代码中，你给 <code>isHot</code> 用了 <code>deep: true</code>，这没问题，因为 <code>isHot</code> 是布尔值，不需要深度遍历。<br>但是，如果你去侦听 <code>numbers</code> 对象：</p>
<ul>
<li>**如果不加 <code>deep</code>**：修改 <code>numbers.a</code> 会触发，修改 <code>numbers.c.d</code> 也会触发（因为 Vue 默认就追踪到了）。</li>
<li>**加了 <code>deep</code>**：Vue 会强制遍历对象的每一层。对于复杂对象，这会消耗性能。</li>
</ul>
<p><strong>结论</strong>：对于 Vue 实例中 <code>data</code> 定义的深层对象，通常不需要手动加 <code>deep: true</code>，Vue 已经帮你做好响应式了。</p>
<h3 id="3-计算属性-vs-侦听属性"><a href="#3-计算属性-vs-侦听属性" class="headerlink" title="3. 计算属性 vs. 侦听属性"></a>3. 计算属性 vs. 侦听属性</h3><p>你的代码里同时有 <code>computed</code> 和 <code>watch</code>，正好做个对比：</p>
<ul>
<li>**<code>computed</code> (计算属性)**：<ul>
<li><strong>用途</strong>：<strong>派生数据</strong>。比如 <code>fullName</code> 是由 <code>firstName</code> 和 <code>lastName</code> 算出来的。</li>
<li><strong>特点</strong>：有缓存，只有依赖的数据变了才会重新计算。</li>
</ul>
</li>
<li>**<code>watch</code> (侦听属性)**：<ul>
<li><strong>用途</strong>：<strong>异步操作</strong> 或 <strong>复杂逻辑</strong>。比如监听搜索关键词变化，然后去发 Ajax 请求；或者监听数据变化后做一个复杂的动画。</li>
<li><strong>特点</strong>：没有缓存，只要数据变（或初始化），就会执行回调。</li>
</ul>
</li>
</ul>
<h3 id="4-代码运行预测"><a href="#4-代码运行预测" class="headerlink" title="4. 代码运行预测"></a>4. 代码运行预测</h3><p>当你运行这段代码时，控制台会发生以下事情：</p>
<ol>
<li><strong>页面加载</strong>：因为 <code>immediate: true</code>，<code>handler</code> 会立刻执行一次。<ul>
<li><code>newVal</code> 是 <code>true</code>（天气炎热）。</li>
<li><code>oldVal</code> 是 <code>undefined</code>（因为是初始化，没有旧值）。</li>
</ul>
</li>
<li><strong>点击“切换天气”</strong>：<code>isHot</code> 变为 <code>false</code>。<ul>
<li><code>handler</code> 再次执行。</li>
<li><code>newVal</code> 是 <code>false</code>（天气凉爽）。</li>
<li><code>oldVal</code> 是 <code>true</code>（之前天气炎热）。</li>
</ul>
</li>
<li>**点击 <code>a++</code> / <code>d++</code>**：控制台会打印 <code>numbers 发生改变</code>（如果你取消注释 <code>watch</code> 里的 <code>numbers</code> 配置）。</li>
</ol>
<h3 id="📌-总结-3"><a href="#📌-总结-3" class="headerlink" title="📌 总结"></a>📌 总结</h3><p>这段代码展示了 Vue 的响应式核心：</p>
<ul>
<li><strong>自动追踪</strong>：Vue 在初始化时就把数据劫持了，不管你怎么改 <code>numbers</code> 的深层属性，它都能感知。</li>
<li><strong>侦听器</strong>：适合做“数据变化后的副作用处理”（比如发请求、改 DOM、打印日志）。</li>
<li><strong>深度侦听</strong>：虽然好用，但有性能开销，Vue 默认的对象监测已经很强大了。</li>
</ul>
<hr>
<h2 id="计算属性-amp-amp-监视属性"><a href="#计算属性-amp-amp-监视属性" class="headerlink" title="计算属性 &amp;&amp; 监视属性"></a>计算属性 &amp;&amp; 监视属性</h2><blockquote>
<p>computed和watch之间的区别：</p>
<p>​          1.computed能完成的功能，watch都可以完成。</p>
<p>​          2.watch能完成的功能，computed不一定能完成，例如：watch可以进行异步操作。</p>
<p>​        两个重要的小原则：</p>
<p>​          1.所被Vue管理的函数，最好写成普通函数，这样this的指向才是vm 或 组件实例对象。</p>
<p>​          2.所有不被Vue所管理的函数（定时器的回调函数、ajax的回调函数等、Promise的回调函数），最好写成箭头函数，</p>
<p>​          这样this的指向才是vm 或 组件实例对象。</p>
</blockquote>
<pre><code class="html">&lt;!doctype html&gt;
&lt;html lang=&quot;en&quot;&gt;
&lt;head&gt;
    &lt;meta charset=&quot;UTF-8&quot;&gt;
    &lt;meta name=&quot;viewport&quot;
          content=&quot;width=device-width, user-scalable=no, initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0&quot;&gt;
    &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;ie=edge&quot;&gt;
    &lt;title&gt;计算属性&lt;/title&gt;
    &lt;script src=&quot;../js/vue.js&quot;&gt;&lt;/script&gt;
&lt;/head&gt;
&lt;body&gt;
    &lt;div id=&quot;root&quot;&gt;
        &lt;!--v-model双向绑定--&gt;
        姓:&lt;input type=&quot;text&quot; v-model=&quot;firstName&quot;/&gt;
        &lt;br/&gt;&lt;br/&gt;
        名:&lt;input type=&quot;text&quot; v-model=&quot;lastName&quot;/&gt;
        &lt;br/&gt;&lt;br/&gt;
        全名: &lt;span&gt;&#123;&#123; fullName &#125;&#125;&lt;/span&gt;
        &lt;br/&gt;&lt;br/&gt;
        test: &lt;input type=&quot;text&quot; v-model=&quot;test&quot; placeholder=&quot;请输入全名&quot;/&gt;
        &lt;button @click=&quot;changeFullName&quot;&gt;修改&lt;/button&gt;
        &lt;br/&gt;&lt;br/&gt;
        &lt;!-- 全名-menthods实现: &lt;span&gt;&#123;&#123; fullName() &#125;&#125;&lt;/span&gt; --&gt;
    &lt;/div&gt;
    &lt;script type=&quot;text/javascript&quot;&gt;
        const vm = new Vue(&#123;
           el:&#39;#root&#39;,
           data:&#123;
               firstName:&#39;张&#39;,
               lastName: &#39;三&#39;,
               fullName: &#39;zhang--san&#39;,
               test: &#39;测--试&#39;
           &#125;, 
           watch: &#123;
                firstName(newF) &#123;
                    setTimeout(() =&gt; &#123;
                        this.fullName = newF + &#39;--&#39; + this.lastName;
                    &#125;, 1000);
                &#125;,            
                lastName(newL) &#123;
                    setTimeout(() =&gt; &#123;
                        this.fullName = this.firstName + &#39;--&#39; + newL;
                    &#125;, 1000);
                &#125;
           &#125;,
        //    computed: &#123;
        //        fullName: &#123;
        //           get() &#123;
        //             console.log(&#39;fullNameByComputed get()被调用了&#39;);
        //             return this.firstName + &#39;--&#39; + this.lastName;
        //           &#125;,
        //           set(val) &#123;
        //             console.log(&#39;fullNameByComputed set()被调用了&#39;);
        //             const [firstName, lastName] = val.split(&#39;--&#39;);
        //             this.firstName = firstName;
        //             this.lastName = lastName;
        //             console.log(&#39;fullNameByComputed set()被调用了&#39;);
        //           &#125;
        //        &#125;
        //    &#125;,
            //简写形式
            //前提:计算属性只考虑读取不考虑修改 set丢了
            //简写计算书写为一个函数(这个函数当成getter使用), 注意不要写箭头函数
            //执行完getter之后，vm直接保存返回的数据为fullName属性的属性值,此时vm.fullName不是函数而是一个确切的计算值
        //    computed: &#123;
        //        fullName: function() &#123;
        //            console.log(&#39;fullName()被调用了&#39;);
        //            return this.firstName + &#39;--&#39; + this.lastName;
        //        &#125;
        //    &#125;,
           methods: &#123;
                changeFullName() &#123;
                    this.firstName = this.test.split(&#39;--&#39;)[0];
                    this.lastName = this.test.split(&#39;--&#39;)[1];
                &#125;,
                // fullName() &#123;
                //     console.log(&#39;fullName()被调用了&#39;);
                //     return `$&#123;this.firstName.slice(0, 4)&#125; -- $&#123;this.lastName&#125;`;
                // &#125;
           &#125;
        &#125;);
    &lt;/script&gt;
&lt;/body&gt;
&lt;/html&gt;
</code></pre>
<blockquote>
<p><code>computed</code> 和 <code>watch</code> 的本质区别和使用场景。</p>
</blockquote>
<p>深入剖析一下为什么说 <strong>“<code>watch</code> 能做异步，<code>computed</code> 不能”</strong>，以及 <strong>“箭头函数的 this 指向”</strong> 这两个原则。</p>
<h3 id="1-computed-vs-watch：同步与异步的鸿沟"><a href="#1-computed-vs-watch：同步与异步的鸿沟" class="headerlink" title="1. computed vs watch：同步与异步的鸿沟"></a>1. <code>computed</code> vs <code>watch</code>：同步与异步的鸿沟</h3><p>你的代码完美地证明了这一点。</p>
<h4 id="computed-的局限性（纯同步）"><a href="#computed-的局限性（纯同步）" class="headerlink" title="computed 的局限性（纯同步）"></a><code>computed</code> 的局限性（纯同步）</h4><ul>
<li><strong>机制</strong>：<code>computed</code> 是一个<strong>纯函数</strong>。给定相同的输入（<code>firstName</code> 和 <code>lastName</code>），它必须立刻返回相同的输出。</li>
<li><strong>限制</strong>：它不能包含“等待”逻辑。你不能在 <code>computed</code> 里写 <code>setTimeout</code>，因为计算属性必须立即返回一个值，否则页面渲染就会卡住。</li>
<li><strong>适用</strong>：简单的拼接、数学运算、过滤数组等。</li>
</ul>
<h4 id="watch-的灵活性（可异步）"><a href="#watch-的灵活性（可异步）" class="headerlink" title="watch 的灵活性（可异步）"></a><code>watch</code> 的灵活性（可异步）</h4><ul>
<li><strong>机制</strong>：<code>watch</code> 是一个<strong>监听器</strong>。它不负责返回值，它负责“执行任务”。</li>
<li><strong>优势</strong>：在你的代码中，<code>watch</code> 里用了 <code>setTimeout</code>。这意味着：<ul>
<li>Vue 不需要立刻得到结果。</li>
<li>Vue 只是“看着”数据变化，然后在后台开启一个定时器。</li>
<li>1秒后，定时器回调函数执行，再去修改数据。</li>
</ul>
</li>
<li><strong>适用</strong>：搜索建议（输入后等用户停顿再发请求）、表单验证、路由监听等。</li>
</ul>
<h3 id="2-关于-this-指向的两个原则"><a href="#2-关于-this-指向的两个原则" class="headerlink" title="2. 关于 this 指向的两个原则"></a>2. 关于 <code>this</code> 指向的两个原则</h3><p>你的代码也是这两个原则的<strong>最佳实践范例</strong>。</p>
<h4 id="原则一：Vue-管理的函数，用普通函数"><a href="#原则一：Vue-管理的函数，用普通函数" class="headerlink" title="原则一：Vue 管理的函数，用普通函数"></a>原则一：Vue 管理的函数，用普通函数</h4><ul>
<li><strong>例子</strong>：<code>watch</code> 里的 <code>firstName(newF) &#123; ... &#125;</code>。</li>
<li><strong>分析</strong>：<code>firstName</code> 是 Vue 帮你调用的。Vue 内部会把 <code>this</code> 绑定为 Vue 实例（<code>vm</code>）。如果你写成箭头函数 <code>firstName: (newF) =&gt; &#123; ... &#125;</code>，虽然 <code>this</code> 也能指向 <code>vm</code>（因为外层是全局作用域），但在严格模式下可能会出问题，且不符合 Vue 的设计规范。使用普通函数是最稳妥、最符合直觉的写法。</li>
</ul>
<h4 id="原则二：非-Vue-管理的函数，用箭头函数"><a href="#原则二：非-Vue-管理的函数，用箭头函数" class="headerlink" title="原则二：非 Vue 管理的函数，用箭头函数"></a>原则二：非 Vue 管理的函数，用箭头函数</h4><ul>
<li><strong>例子</strong>：<code>setTimeout(() =&gt; &#123; ... &#125;, 1000)</code>。</li>
<li><strong>分析</strong>：<ul>
<li><code>setTimeout</code> 是浏览器的 API，不是 Vue 调用的。</li>
<li>如果你写成普通函数 <code>setTimeout(function() &#123; this.fullName = ... &#125;, 1000)</code>，这里的 <code>this</code> 会指向 <code>window</code>（非严格模式）或 <code>undefined</code>（严格模式），导致报错。</li>
<li>**箭头函数没有自己的 <code>this</code>**，它会向外层作用域（Vue 的 <code>watch</code> 函数）查找。在 <code>watch</code> 函数里，<code>this</code> 指向 <code>vm</code>，所以箭头函数里的 <code>this</code> 也指向 <code>vm</code>。</li>
</ul>
</li>
</ul>
<h3 id="3-代码运行流程图解"><a href="#3-代码运行流程图解" class="headerlink" title="3. 代码运行流程图解"></a>3. 代码运行流程图解</h3><ol>
<li><strong>初始化</strong>：<code>firstName</code> 是“张”，<code>lastName</code> 是“三”，<code>fullName</code> 是“zhang–san”。</li>
<li><strong>输入</strong>：你在“姓”的输入框输入“李”。</li>
<li><strong>触发</strong>：<code>data.firstName</code> 变为“李”，触发 <code>watch.firstName</code> 回调。</li>
<li><strong>异步</strong>：<code>watch</code> 启动一个 1 秒的倒计时。</li>
<li><strong>更新</strong>：1 秒后，倒计时结束，执行回调，将 <code>fullName</code> 修改为“李–三”。</li>
<li><strong>渲染</strong>：页面上的“全名”从旧值变为“李–三”。</li>
</ol>
<h3 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h3><p>你的理解完全正确：</p>
<ul>
<li><strong>用 <code>computed</code><strong>：当你需要一个</strong>实时的、基于数据计算出来的值</strong>，且这个计算是<strong>同步</strong>的。</li>
<li><strong>用 <code>watch</code><strong>：当你需要在数据变化时</strong>执行一段代码</strong>，且这段代码可能包含<strong>异步操作</strong>（如 <code>setTimeout</code>、<code>axios</code> 请求）或<strong>复杂的业务逻辑</strong>。</li>
</ul>
<p>这段代码就是 <code>watch</code> 处理异步场景（模拟网络请求延迟）的经典例子。</p>
<hr>
<h2 id="绑定样式"><a href="#绑定样式" class="headerlink" title="绑定样式"></a>绑定样式</h2><blockquote>
<p>:class=”XXX”</p>
</blockquote>
<pre><code class="html">&lt;!doctype html&gt;
&lt;html lang=&quot;en&quot;&gt;
&lt;head&gt;
    &lt;meta charset=&quot;UTF-8&quot;&gt;
    &lt;meta name=&quot;viewport&quot;
          content=&quot;width=device-width, user-scalable=no, initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0&quot;&gt;
    &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;ie=edge&quot;&gt;
    &lt;title&gt;vue绑定样式&lt;/title&gt;
    &lt;style&gt;
        .basic&#123;
            width: 400px;
            height: 100px;
            border: 1px solid black;
        &#125;
        .happy&#123;
            border: 4px solid red;;
            background-color: rgba(255, 255, 0, 0.644);
            background: linear-gradient(30deg,yellow,pink,orange,yellow);
        &#125;
        .sad&#123;
            border: 4px dashed rgb(2, 197, 2);
            background-color: gray;
        &#125;
        .normal&#123;
            background-color: skyblue;
        &#125;
        .atguigu1&#123;
            background-color: yellowgreen;
        &#125;
        .atguigu2&#123;
            font-size: 30px;
            text-shadow:2px 2px 10px red;
        &#125;
        .atguigu3&#123;
            border-radius: 20px;
        &#125;
    &lt;/style&gt;
    &lt;script src=&quot;../js/vue.js&quot;&gt;&lt;/script&gt;
&lt;/head&gt;
&lt;body&gt;
&lt;div id=&quot;root&quot;&gt;
    &lt;hr/&gt;&lt;!--:class 绑定class样式字符串写法 适用于样式的类名不确定需要动态琢磨的状况--&gt;
    &lt;div class=&quot;basic&quot; :class=&quot;mood&quot; @click=&quot;changeMood&quot;&gt;&#123;&#123; name &#125;&#125;&lt;/div&gt;
    &lt;hr/&gt;&lt;!--:class 绑定class样式数组写法 适用于要绑定的样式个数不确定，名字也不确定的状况--&gt;
    &lt;div class=&quot;basic&quot; :class=&quot;classArr&quot;&gt;&#123;&#123; name &#125;&#125;&lt;/div&gt;
    &lt;hr/&gt;&lt;!--:class 绑定class样式对象写法 适用于要绑定的样式个数确定，名字确定，但动态决定要不要用的状况--&gt;
    &lt;div class=&quot;basic&quot; :class=&quot;classObj&quot;&gt;&#123;&#123; name &#125;&#125;&lt;/div&gt;
    &lt;hr/&gt;
&lt;/div&gt;
&lt;script type=&quot;text/javascript&quot;&gt;
    const vm = new Vue(&#123;
       el:&#39;#root&#39;,
       data: &#123;
           name:&#39;test&#39;,
           mood: &#39;normal&#39;,
           classArr: [&#39;atguigu1&#39;,&#39;atguigu2&#39;,&#39;atguigu3&#39;],
           classObj: &#123;
               atguigu1: true,
               atguigu2: true,
               atguigu3: true
           &#125;
       &#125;,
       methods:&#123;
         changeMood()&#123;
             //vue绑定事件
             //不要亲手操作dom
             //随机切换心情
             const moods = [&#39;happy&#39;,&#39;sad&#39;,&#39;normal&#39;];
             const random = Math.floor(Math.random() * moods.length);
             this.mood = moods[random];
         &#125;
       &#125;
    &#125;);
&lt;/script&gt;
&lt;/body&gt;
&lt;/html&gt;
</code></pre>
<p>这段代码是 Vue.js <strong>动态样式绑定</strong> 的教科书级范例。它清晰地展示了如何通过 <code>:class</code> 指令，用三种不同的数据结构（字符串、数组、对象）来动态控制 DOM 的 CSS 类名。</p>
<p>结合你的注释和代码，我来为你深度拆解这三种写法的适用场景和底层逻辑：</p>
<h3 id="1-字符串写法-v-bind-class-class"><a href="#1-字符串写法-v-bind-class-class" class="headerlink" title="1. 字符串写法 (v-bind:class / :class)"></a>1. 字符串写法 (<code>v-bind:class</code> / <code>:class</code>)</h3><p><strong>代码：</strong></p>
<pre><code class="html">&lt;div class=&quot;basic&quot; :class=&quot;mood&quot; @click=&quot;changeMood&quot;&gt;&#123;&#123; name &#125;&#125;&lt;/div&gt;
data: &#123;
    mood: &#39;normal&#39;
&#125;,
methods: &#123;
    changeMood() &#123;
        const moods = [&#39;happy&#39;,&#39;sad&#39;,&#39;normal&#39;];
        const random = Math.floor(Math.random() * moods.length);
        this.mood = moods[random]; // 动态改变字符串值
    &#125;
&#125;
</code></pre>
<ul>
<li><strong>原理</strong>：直接将 <code>data</code> 中的一个字符串变量绑定到 <code>class</code> 上。</li>
<li><strong>效果</strong>：HTML 渲染为 <code>&lt;div class=&quot;basic happy&quot;&gt;</code>（假设 mood 为 happy）。</li>
<li><strong>适用场景</strong>：<strong>“状态切换”</strong>。比如心情切换、主题切换（白天/黑夜模式）、选项卡高亮。类名是动态的，且互斥。</li>
<li><strong>关键点</strong>：<code>class</code> 可以和普通的 <code>class</code> 共存（<code>basic</code> 一直存在，<code>mood</code> 动态变化）。</li>
</ul>
<h3 id="2-数组写法-class"><a href="#2-数组写法-class" class="headerlink" title="2. 数组写法 (:class)"></a>2. 数组写法 (<code>:class</code>)</h3><p><strong>代码：</strong></p>
<pre><code class="html">&lt;div class=&quot;basic&quot; :class=&quot;classArr&quot;&gt;&#123;&#123; name &#125;&#125;&lt;/div&gt;
data: &#123;
    classArr: [&#39;atguigu1&#39;,&#39;atguigu2&#39;,&#39;atguigu3&#39;]
&#125;
</code></pre>
<ul>
<li><strong>原理</strong>：绑定一个数组，数组的每一项都是一个字符串类名。</li>
<li><strong>效果</strong>：HTML 渲染为 <code>&lt;div class=&quot;basic atguigu1 atguigu2 atguigu3&quot;&gt;</code>。</li>
<li><strong>适用场景</strong>：<strong>“组合式样式”</strong>。当样式的个数不确定，或者名字需要通过循环/接口动态生成时。</li>
<li><strong>动态性</strong>：你可以通过 <code>push</code>、<code>splice</code> 等数组方法动态修改 <code>classArr</code>，DOM 会自动更新。</li>
</ul>
<h3 id="3-对象写法-class"><a href="#3-对象写法-class" class="headerlink" title="3. 对象写法 (:class)"></a>3. 对象写法 (<code>:class</code>)</h3><p><strong>代码：</strong></p>
<pre><code class="html">&lt;div class=&quot;basic&quot; :class=&quot;classObj&quot;&gt;&#123;&#123; name &#125;&#125;&lt;/div&gt;
data: &#123;
    classObj: &#123;
        atguigu1: true,
        atguigu2: true,
        atguigu3: true
    &#125;
&#125;
</code></pre>
<ul>
<li><strong>原理</strong>：绑定一个对象。<strong>键 (key)</strong> 是类名，<strong>值 (value)</strong> 是布尔值。</li>
<li><strong>效果</strong>：只有值为 <code>true</code> 的键，才会被渲染到页面上。</li>
<li><strong>适用场景</strong>：<strong>“开关式样式”</strong>。样式的个数和名字是确定的，但需要根据业务逻辑（如是否选中、是否禁用）来决定是否应用。</li>
<li><strong>优势</strong>：逻辑非常清晰，一眼就能看出哪个样式开，哪个样式关。</li>
</ul>
<h3 id="📌-总结与对比"><a href="#📌-总结与对比" class="headerlink" title="📌 总结与对比"></a>📌 总结与对比</h3><table>
<thead>
<tr>
<th>写法</th>
<th>数据类型</th>
<th>核心特点</th>
<th>典型应用场景</th>
</tr>
</thead>
<tbody><tr>
<td><strong>字符串</strong></td>
<td><code>String</code></td>
<td>值直接对应类名</td>
<td>状态切换（如：<code>active</code>, <code>error</code>, <code>success</code>）</td>
</tr>
<tr>
<td><strong>数组</strong></td>
<td><code>Array</code></td>
<td>多个类名的列表</td>
<td>动态组合（如：从接口获取标签样式列表）</td>
</tr>
<tr>
<td><strong>对象</strong></td>
<td><code>Object</code></td>
<td>键值对，值为布尔值</td>
<td>条件渲染（如：<code>&#123; bold: isBold, hidden: isHidden &#125;</code>）</td>
</tr>
</tbody></table>
<h3 id="💡-补充建议"><a href="#💡-补充建议" class="headerlink" title="💡 补充建议"></a>💡 补充建议</h3><ol>
<li><p><strong>三元表达式</strong>：<br>你也可以在数组或对象中使用三元表达式：</p>
<pre><code class="html">&lt;!-- 如果 isActive 为真，应用 activeClass，否则应用 defaultClass --&gt;
&lt;div :class=&quot;[isActive ? activeClass : defaultClass]&quot;&gt;&lt;/div&gt;
</code></pre>
</li>
<li><p><strong>混合使用</strong>：<br>Vue 允许你同时使用静态 <code>class</code> 和动态 <code>:class</code>，它们会自动合并，不会冲突。</p>
</li>
<li><p>**内联样式绑定 (<code>:style</code>)**：<br>虽然这段代码没展示，但 <code>:style</code> 的用法与 <code>:class</code> 类似，通常使用对象写法（<code>&#123; color: activeColor, fontSize: fontSize + &#39;px&#39; &#125;</code>）来动态修改内联样式。</p>
</li>
</ol>
<p>你的代码注释写得非常棒，准确地概括了每种写法的适用场景！</p>
<hr>
<h2 id="条件渲染"><a href="#条件渲染" class="headerlink" title="条件渲染"></a>条件渲染</h2><blockquote>
<p>v-if=”XXX” v-else-if=”XXX” v-else=”XXX”</p>
<p>v-show=”XXX”</p>
</blockquote>
<pre><code class="html">&lt;!doctype html&gt;
&lt;html lang=&quot;en&quot;&gt;
&lt;head&gt;
    &lt;meta charset=&quot;UTF-8&quot;&gt;
    &lt;meta name=&quot;viewport&quot;
          content=&quot;width=device-width, user-scalable=no, initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0&quot;&gt;
    &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;ie=edge&quot;&gt;
    &lt;title&gt;条件渲染&lt;/title&gt;
    &lt;script src=&quot;../js/vue.js&quot;&gt;&lt;/script&gt;
&lt;/head&gt;
&lt;body&gt;
&lt;!--
                条件渲染：
                            1.v-if
                                        写法：
                                                (1).v-if=&quot;表达式&quot;
                                                (2).v-else-if=&quot;表达式&quot;
                                                (3).v-else=&quot;表达式&quot;
                                        适用于：切换频率较低的场景。
                                        特点：不展示的DOM元素直接被移除。
                                        注意：v-if可以和:v-else-if、v-else一起使用，但要求结构不能被“打断”。

                            2.v-show
                                        写法：v-show=&quot;表达式&quot;
                                        适用于：切换频率较高的场景。
                                        特点：不展示的DOM元素未被移除，仅仅是使用样式隐藏掉

                            3.备注：使用v-if的时，元素可能无法获取到，而使用v-show一定可以获取到。
         --&gt;

&lt;div id=&quot;root&quot;&gt;
    &lt;!--v-show要能转换为一个布尔值 v-show条件渲染--&gt;
&lt;!--    &lt;h2 v-show=&quot;a&quot;&gt;欢迎来到&#123;&#123; name &#125;&#125;&lt;/h2&gt;--&gt;

&lt;!--    &lt;h2 v-show=&quot;1===1&quot;&gt;欢迎来到&#123;&#123; name &#125;&#125;&lt;/h2&gt;--&gt;
&lt;!--    &lt;button @click=&#39;a = !a&#39;&gt;&#123;&#123; a ? '隐藏': '显示' &#125;&#125;&lt;/button&gt;--&gt;
    &lt;!--使用v-if来进行条件渲染 --&gt;
&lt;!--    &lt;h2 v-if=&quot;1&quot;&gt;欢迎来到&#123;&#123; name &#125;&#125;&lt;/h2&gt;--&gt;
    &lt;!--v-if v-else-if v-else记住不能打断，要连着写--&gt;
&lt;!--    &lt;h2&gt;当前的n值是&#123;&#123; n &#125;&#125;&lt;/h2&gt;--&gt;
    &lt;button @click=&quot;n++&quot;&gt;点我n+1&lt;/button&gt;
&lt;!--    &lt;div v-if=&quot;n === 1&quot;&gt;angular&lt;/div&gt;--&gt;
&lt;!--    &lt;div v-else-if=&quot;n === 2&quot;&gt;react&lt;/div&gt;--&gt;
&lt;!--&amp;lt;!&amp;ndash;    &lt;div&gt;111&lt;/div&gt;&amp;ndash;&amp;gt;--&gt;
&lt;!--    &lt;div v-else-if=&quot;n === 3&quot;&gt;vue js&lt;/div&gt;--&gt;
&lt;!--    &lt;div v-else&gt;not found&lt;/div&gt;--&gt;

    &lt;!--v-if与template的配合使用--&gt;
    &lt;template v-if=&quot;n === 1&quot;&gt;
        &lt;h2&gt;你好&lt;/h2&gt;
        &lt;h2&gt;shanghai&lt;/h2&gt;
        &lt;h2&gt;shenzhen&lt;/h2&gt;
    &lt;/template&gt;
&lt;/div&gt;
&lt;script type=&quot;text/javascript&quot;&gt;
    const vm = new Vue(&#123;
        el: &#39;#root&#39;,
        data:&#123;
            name: &#39;shanghai&#39;,
            n:0
        &#125;
    &#125;)
&lt;/script&gt;
&lt;/body&gt;
&lt;/html&gt;
</code></pre>
<p>这段代码是 Vue.js <strong>条件渲染</strong> 的完整指南。它清晰地展示了 <code>v-if</code> 和 <code>v-show</code> 这对“双胞胎”的区别，以及 <code>v-if</code> 在复杂逻辑和模板分组中的用法。</p>
<p>结合你的注释和代码，我来为你深度拆解这两个指令的底层逻辑和使用策略：</p>
<h3 id="1-v-if-vs-v-show：移除-vs-隐藏"><a href="#1-v-if-vs-v-show：移除-vs-隐藏" class="headerlink" title="1. v-if vs v-show：移除 vs 隐藏"></a>1. <code>v-if</code> vs <code>v-show</code>：移除 vs 隐藏</h3><p>这是 Vue 面试和实际开发中最常遇到的选择题。</p>
<h4 id="v-if：真正的“条件渲染”"><a href="#v-if：真正的“条件渲染”" class="headerlink" title="v-if：真正的“条件渲染”"></a><code>v-if</code>：真正的“条件渲染”</h4><ul>
<li><strong>机制</strong>：<strong>惰性渲染</strong>。如果初始条件为假，什么也不做；为真时，才会创建元素并添加到 DOM 中。切换时，会销毁/重建组件。</li>
<li><strong>本质</strong>：通过<strong>添加/移除</strong> DOM 元素来控制显示。</li>
<li><strong>代码验证</strong>：打开浏览器开发者工具，当你使用 <code>v-if</code> 时，条件为假的元素在 HTML 结构中<strong>完全消失</strong>。</li>
</ul>
<h4 id="v-show：CSS-的“开关”"><a href="#v-show：CSS-的“开关”" class="headerlink" title="v-show：CSS 的“开关”"></a><code>v-show</code>：CSS 的“开关”</h4><ul>
<li><strong>机制</strong>：<strong>强制渲染</strong>。无论条件真假，元素都会被创建并保留在 DOM 中。通过 <code>display: none</code> 样式来控制视觉上的隐藏。</li>
<li><strong>本质</strong>：通过<strong>CSS 样式</strong>控制显示。</li>
<li><strong>代码验证</strong>：使用 <code>v-show</code> 时，即使元素看不见了，它依然存在于 HTML 结构中，只是多了一个 <code>style=&quot;display: none;&quot;</code>。</li>
</ul>
<h3 id="2-性能与场景选择"><a href="#2-性能与场景选择" class="headerlink" title="2. 性能与场景选择"></a>2. 性能与场景选择</h3><h4 id="使用-v-if-的场景"><a href="#使用-v-if-的场景" class="headerlink" title="使用 v-if 的场景"></a>使用 <code>v-if</code> 的场景</h4><ul>
<li><strong>切换频率低</strong>：因为切换需要销毁和重建 DOM，开销较大。</li>
<li><strong>包含复杂组件</strong>：比如模态框、弹窗，内部可能有大量逻辑和子组件，关闭时销毁可以释放内存。</li>
<li><strong>首次渲染</strong>：如果初始状态是隐藏，<code>v-if</code> 不会渲染，节省了初始渲染时间。</li>
</ul>
<h4 id="使用-v-show-的场景"><a href="#使用-v-show-的场景" class="headerlink" title="使用 v-show 的场景"></a>使用 <code>v-show</code> 的场景</h4><ul>
<li><strong>切换频率高</strong>：只是切换 CSS，性能极高。</li>
<li><strong>简单元素</strong>：不需要频繁销毁重建的开销。</li>
</ul>
<h3 id="3-v-if-的进阶用法"><a href="#3-v-if-的进阶用法" class="headerlink" title="3. v-if 的进阶用法"></a>3. <code>v-if</code> 的进阶用法</h3><h4 id="1-v-else-if-与-v-else"><a href="#1-v-else-if-与-v-else" class="headerlink" title="1. v-else-if 与 v-else"></a>1. <code>v-else-if</code> 与 <code>v-else</code></h4><ul>
<li><strong>逻辑</strong>：完全等同于 JavaScript 的 <code>if...else if...else</code>。</li>
<li><strong>关键规则</strong>：<strong>不能被打断</strong>。必须连在一起写。如果你在 <code>v-if</code> 和 <code>v-else</code> 中间插入了一个普通 HTML 标签，<code>v-else</code> 就会失效，因为它找不到对应的“兄弟” <code>v-if</code> 了。</li>
<li><strong>你的代码测试</strong>：你注释掉的那段 <code>n === 1</code>、<code>n === 2</code>、<code>n === 3</code> 就是典型的多分支判断。</li>
</ul>
<h4 id="2-lt-template-gt-标签"><a href="#2-lt-template-gt-标签" class="headerlink" title="2. &lt;template&gt; 标签"></a>2. <code>&lt;template&gt;</code> 标签</h4><ul>
<li><strong>问题</strong>：如果你想要同时切换<strong>多个</strong>元素，是不是要给每个元素都写一遍 <code>v-if</code>？</li>
<li><strong>解法</strong>：使用 <code>&lt;template&gt;</code>。它是一个<strong>不可见的包装器</strong>。</li>
<li><strong>你的代码分析</strong>：<ul>
<li>当 <code>n === 1</code> 时，三个 <code>&lt;h2&gt;</code> 标签会同时显示。</li>
<li>当 <code>n !== 1</code> 时，这三个标签会被<strong>整体移除</strong>。</li>
<li><strong>注意</strong>：<code>&lt;template&gt;</code> 只能配合 <code>v-if</code>，不能配合 <code>v-show</code>（因为 <code>v-show</code> 是 CSS 控制，<code>&lt;template&gt;</code> 无法被渲染，也就无法应用 CSS）。</li>
</ul>
</li>
</ul>
<h3 id="4-关于“获取元素”的备注"><a href="#4-关于“获取元素”的备注" class="headerlink" title="4. 关于“获取元素”的备注"></a>4. 关于“获取元素”的备注</h3><p>你注释中提到的那句<strong>“使用 v-if 时，元素可能无法获取到，而使用 v-show 一定可以获取到”</strong>非常关键。</p>
<ul>
<li>**<code>v-show</code>**：元素始终在 DOM 树里。你可以随时通过 <code>document.getElementById</code> 或 <code>ref</code> 获取到它。</li>
<li>**<code>v-if</code>**：元素可能根本不存在。如果你在 <code>v-if=&quot;false&quot;</code> 的时候尝试获取该 DOM 元素，会得到 <code>null</code>。这在操作 DOM 或使用第三方库时需要特别注意。</li>
</ul>
<h3 id="总结-2"><a href="#总结-2" class="headerlink" title="总结"></a>总结</h3><ul>
<li><strong><code>v-if</code><strong>：</strong>“有无”**的问题。适合**懒加载**、</strong>节省内存<strong>、</strong>一次性展示**。</li>
<li><strong><code>v-show</code><strong>：</strong>“显隐”**的问题。适合**频繁切换**、</strong>保留状态**。</li>
</ul>
<p>在你的代码中，<code>&lt;template v-if&gt;</code> 的写法展示了如何优雅地控制一组元素的显示，这是编写复杂模板时非常实用的技巧。</p>
<hr>
<h2 id="列表渲染"><a href="#列表渲染" class="headerlink" title="列表渲染"></a>列表渲染</h2><h2 id="收集表单数据"><a href="#收集表单数据" class="headerlink" title="收集表单数据"></a>收集表单数据</h2><h2 id="过滤器"><a href="#过滤器" class="headerlink" title="过滤器"></a>过滤器</h2><h2 id="内置指令"><a href="#内置指令" class="headerlink" title="内置指令"></a>内置指令</h2><h2 id="自定义指令"><a href="#自定义指令" class="headerlink" title="自定义指令"></a>自定义指令</h2><h2 id="生命周期"><a href="#生命周期" class="headerlink" title="生命周期"></a>生命周期</h2><h2 id="非单文件组件"><a href="#非单文件组件" class="headerlink" title="非单文件组件"></a>非单文件组件</h2><h2 id="单文件组件"><a href="#单文件组件" class="headerlink" title="单文件组件"></a>单文件组件</h2>
      
       <hr><span style="font-style: italic;color: gray;"> 转载请注明来源，欢迎对文章中的引用来源进行考证，欢迎指出任何有错误或不够清晰的表达。可以在下面评论区评论，也可以邮件至 jungle8884@163.com </span>
    </div>
</article>


<p>
    <a  class="dashang" onclick="dashangToggle()">赏</a>
</p>




    <div id="comments"></div>
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/gitalk@1/dist/gitalk.css">

<script type="text/javascript">
    $.getScript('/js/gitalk.js', function () {
        var gitalk = new Gitalk({
            clientID: '6763cf342e4c3335d632',
            clientSecret: '91ee1b22f4c8e5eff96b6e0eae5bdda1f6580ebb',
            repo: 'jungle8884.github.io',
            owner: 'jungle8884',
            admin: ['jungle8884'],
            id: decodeURI(location.pathname),
            distractionFreeMode: 'true',
            language: 'zh-CN',
            perPage: parseInt('10',10)
        })
        gitalk.render('comments')
    })
</script>




    




    </div>
    <div class="copyright">
        <p class="footer-entry">
    ©2016-2020 Jungle
</p>
<p class="footer-entry">Built with <a href="https://hexo.io/" target="_blank">Hexo</a> and <a href="https://github.com/yelog/hexo-theme-3-hexo" target="_blank">3-hexo</a> theme</p>

    </div>
    <div class="full-toc">
        <button class="full" data-title="切换全屏 快捷键 s"><span class="min "></span></button>
<a class="" id="rocket" ></a>

    </div>
</div>

<div class="hide_box" onclick="dashangToggle()"></div>
<div class="shang_box">
    <a class="shang_close"  onclick="dashangToggle()">×</a>
    <div class="shang_tit">
        <p>喜欢就点赞,疼爱就打赏</p>
    </div>
    <div class="shang_payimg">
        <div class="pay_img">
            <img src="/img/alipay.jpg" class="alipay" title="扫码支持">
            <img src="/img/weixin.jpg" class="weixin" title="扫码支持">
        </div>
    </div>
    <div class="shang_payselect">
        <span><label><input type="radio" name="pay" checked value="alipay">支付宝</label></span><span><label><input type="radio" name="pay" value="weixin">微信</label></span>
    </div>
</div>


</body>
<script src="/js/jquery.pjax.js?v=1.1.0" ></script>

<script src="/js/script.js?v=1.1.0" ></script>
<script>
    var img_resize = 'default';
    function initArticle() {
        /*渲染对应的表格样式*/
        
            $("#post .pjax table").addClass("green_title");
        

        /*渲染打赏样式*/
        
        $("input[name=pay]").on("click", function () {
            if($("input[name=pay]:checked").val()=="weixin"){
                $(".shang_box .shang_payimg .pay_img").addClass("weixin_img");
            } else {
                $(".shang_box .shang_payimg .pay_img").removeClass("weixin_img");
            }
        })
        

        /*高亮代码块行号*/
        
        $('pre code').each(function(){
            var lines = $(this).text().trim().split('\n').length, widther='';
            if (lines>99) {
                widther = 'widther'
            }
            var $numbering = $('<ul/>').addClass('pre-numbering ' + widther).attr("unselectable","on");
            $(this).addClass('has-numbering ' + widther)
                    .parent()
                    .append($numbering);
            for(var i=1;i<=lines;i++){
                $numbering.append($('<li/>').text(i));
            }
        });
        

        /*访问数量*/
        
        $.getScript("//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js");
        

        /*代码高亮，行号对齐*/
        $('.pre-numbering').css('line-height',$('.has-numbering').css('line-height'));

        
        
    }

    /*打赏页面隐藏与展示*/
    
    function dashangToggle() {
        $(".shang_box").fadeToggle();
        $(".hide_box").fadeToggle();
    }
    

</script>

<!--加入行号的高亮代码块样式-->

<style>
    pre{
        position: relative;
        margin-bottom: 24px;
        border-radius: 10px;
        border: 1px solid #e2dede;
        background: #FFF;
        overflow: hidden;
    }
    code.has-numbering{
        margin-left: 30px;
    }
    code.has-numbering.widther{
        margin-left: 35px;
    }
    .pre-numbering{
        margin: 0;
        position: absolute;
        top: 0;
        left: 0;
        width: 20px;
        padding: 0.5em 3px 0.7em 5px;
        border-right: 1px solid #C3CCD0;
        text-align: right;
        color: #AAA;
        background-color: ;
    }
    .pre-numbering.widther {
        width: 35px;
    }
</style>

<!--自定义样式设置-->
<style>
    
    
    .nav {
        width: 542px;
    }
    .nav.fullscreen {
        margin-left: -542px;
    }
    .nav-left {
        width: 120px;
    }
    
    
    @media screen and (max-width: 1468px) {
        .nav {
            width: 492px;
        }
        .nav.fullscreen {
            margin-left: -492px;
        }
        .nav-left {
            width: 100px;
        }
    }
    
    
    @media screen and (max-width: 1024px) {
        .nav {
            width: 492px;
            margin-left: -492px
        }
        .nav.fullscreen {
            margin-left: 0;
        }
    }
    
    @media screen and (max-width: 426px) {
        .nav {
            width: 100%;
        }
        .nav-left {
            width: 100%;
        }
    }
    
    
    .nav-right .title-list nav a .post-title, .nav-right .title-list #local-search-result a .post-title {
        color: #383636;
    }
    
    
    .nav-right .title-list nav a .post-date, .nav-right .title-list #local-search-result a .post-date {
        color: #5e5e5f;
    }
    
    
    .nav-right nav a.hover, #local-search-result a.hover{
        background-color: #e2e0e0;
    }
    
    

    /*列表样式*/
    

    /* 背景图样式 */
    
    


    /*引用块样式*/
    

    /*文章列表背景图*/
    

    
</style>







<div>
<div id="musicMouseDrag" style="position:fixed; z-index: 9999; bottom: 0; right: 0;">
<div id="musicDragArea" style="position: absolute; top: 0; left: 0; width: 100%;height: 10px;cursor: move; z-index: 10;"></div>
<iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width=330 height=86 src="//music.163.com/outchain/player?type=2&id=1894278325&auto=1&height=66"></iframe>
</div>
<!-- 以下代码是为了支持随时拖动音乐控件的位置，如没有需求，可去掉下面代码 -->
<script>
var $DOC = $(document)
$('#musicMouseDrag').on ('mousedown', function (e) {
// 阻止文本选中
$DOC.bind ("selectstart", function () {
return false;
});
$('#musicDragArea').css ('height', '100%');
var $moveTarget = $('#musicMouseDrag');
$moveTarget.css ('border', '1px dashed grey')
var div_x = e.pageX - $moveTarget.offset ().left;
var div_y = e.pageY - $moveTarget.offset ().top;
$DOC.on ('mousemove', function (e) {
var targetX = e.pageX - div_x;
var targetY = e.pageY - div_y;
targetX = targetX < 0 ? 0 : (targetX + $moveTarget.outerWidth () >= window.innerWidth) ? window.innerWidth - $moveTarget.outerWidth () : targetX;
targetY = targetY < 0 ? 0 : (targetY + $moveTarget.outerHeight () >= window.innerHeight) ? window.innerHeight - $moveTarget.outerHeight () : targetY;
$moveTarget.css ({'left': targetX + 'px', 'top': targetY + 'px', 'bottom': 'inherit', 'right': 'inherit'})
}).on ('mouseup', function () {
$DOC.unbind ("selectstart");
$DOC.off ('mousemove')
$DOC.off ('mouseup')
$moveTarget.css ('border', 'none')
$('#musicDragArea').css ('height', '10px');
})
})
</script>

</html>
